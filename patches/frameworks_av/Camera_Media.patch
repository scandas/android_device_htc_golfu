diff '--exclude=.git' -crB a/camera/ICameraRecordingProxy.cpp b/camera/ICameraRecordingProxy.cpp
*** a/camera/ICameraRecordingProxy.cpp	2018-09-22 10:19:51.601277927 +0200
--- b/camera/ICameraRecordingProxy.cpp	2018-09-22 10:11:05.436312592 +0200
***************
*** 31,41 ****
      RELEASE_RECORDING_FRAME,
  };
  
- uint8_t ICameraRecordingProxy::baseObject = 0;
- 
- size_t ICameraRecordingProxy::getCommonBaseAddress() {
-     return (size_t)&baseObject;
- }
  
  class BpCameraRecordingProxy: public BpInterface<ICameraRecordingProxy>
  {
--- 31,36 ----
diff '--exclude=.git' -crB a/drm/common/IDrmManagerService.cpp b/drm/common/IDrmManagerService.cpp
*** a/drm/common/IDrmManagerService.cpp	2018-09-22 10:19:51.605277935 +0200
--- b/drm/common/IDrmManagerService.cpp	2018-09-22 10:11:05.436312592 +0200
***************
*** 741,751 ****
      const status_t status = reply.readInt32();
      ALOGV("Return value of decrypt() is %d", status);
  
!     if (status == NO_ERROR) {
!         const int size = reply.readInt32();
!         (*decBuffer)->length = size;
!         reply.read((void *)(*decBuffer)->data, size);
!     }
  
      return status;
  }
--- 741,749 ----
      const status_t status = reply.readInt32();
      ALOGV("Return value of decrypt() is %d", status);
  
!     const int size = reply.readInt32();
!     (*decBuffer)->length = size;
!     reply.read((void *)(*decBuffer)->data, size);
  
      return status;
  }
***************
*** 1440,1450 ****
  
          reply->writeInt32(status);
  
!         if (status == NO_ERROR) {
!             const int size = decBuffer->length;
!             reply->writeInt32(size);
!             reply->write(decBuffer->data, size);
!         }
  
          clearDecryptHandle(&handle);
          delete encBuffer; encBuffer = NULL;
--- 1438,1446 ----
  
          reply->writeInt32(status);
  
!         const int size = decBuffer->length;
!         reply->writeInt32(size);
!         reply->write(decBuffer->data, size);
  
          clearDecryptHandle(&handle);
          delete encBuffer; encBuffer = NULL;
diff '--exclude=.git' -crB a/include/camera/ICameraRecordingProxy.h b/include/camera/ICameraRecordingProxy.h
*** a/include/camera/ICameraRecordingProxy.h	2018-09-22 10:19:51.613277949 +0200
--- b/include/camera/ICameraRecordingProxy.h	2018-09-22 10:11:05.436312592 +0200
***************
*** 83,94 ****
      virtual status_t        startRecording(const sp<ICameraRecordingProxyListener>& listener) = 0;
      virtual void            stopRecording() = 0;
      virtual void            releaseRecordingFrame(const sp<IMemory>& mem) = 0;
- 
-     // b/28466701
-     static  size_t          getCommonBaseAddress();
-   private:
- 
-     static  uint8_t         baseObject;
  };
  
  // ----------------------------------------------------------------------------
--- 83,88 ----
diff '--exclude=.git' -crB a/include/media/IMediaDeathNotifier.h b/include/media/IMediaDeathNotifier.h
*** a/include/media/IMediaDeathNotifier.h	2018-09-22 10:19:51.617277956 +0200
--- b/include/media/IMediaDeathNotifier.h	2018-09-22 10:11:05.436312592 +0200
***************
*** 30,36 ****
      virtual ~IMediaDeathNotifier() { removeObitRecipient(this); }
  
      virtual void died() = 0;
!     static const sp<IMediaPlayerService> getMediaPlayerService();
  
  private:
      IMediaDeathNotifier &operator=(const IMediaDeathNotifier &);
--- 30,36 ----
      virtual ~IMediaDeathNotifier() { removeObitRecipient(this); }
  
      virtual void died() = 0;
!     static const sp<IMediaPlayerService>& getMediaPlayerService();
  
  private:
      IMediaDeathNotifier &operator=(const IMediaDeathNotifier &);
diff '--exclude=.git' -crB a/include/media/IOMX.h b/include/media/IOMX.h
*** a/include/media/IOMX.h	2018-09-22 10:19:51.617277956 +0200
--- b/include/media/IOMX.h	2018-09-22 10:11:05.436312592 +0200
***************
*** 99,105 ****
  
      virtual status_t useBuffer(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer, OMX_BOOL crossProcess = OMX_FALSE) = 0;
  
      virtual status_t useGraphicBuffer(
              node_id node, OMX_U32 port_index,
--- 99,105 ----
  
      virtual status_t useBuffer(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer) = 0;
  
      virtual status_t useGraphicBuffer(
              node_id node, OMX_U32 port_index,
***************
*** 125,131 ****
  
      virtual status_t allocateBufferWithBackup(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer, OMX_BOOL crossProcess = OMX_FALSE) = 0;
  
      virtual status_t freeBuffer(
              node_id node, OMX_U32 port_index, buffer_id buffer) = 0;
--- 125,131 ----
  
      virtual status_t allocateBufferWithBackup(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer) = 0;
  
      virtual status_t freeBuffer(
              node_id node, OMX_U32 port_index, buffer_id buffer) = 0;
***************
*** 227,238 ****
      virtual status_t onTransact(
              uint32_t code, const Parcel &data, Parcel *reply,
              uint32_t flags = 0);
- 
- protected:
-     // check if the codec is secure.
-     virtual bool isSecure(IOMX::node_id node) {
-         return false;
-     }
  };
  
  class BnOMXObserver : public BnInterface<IOMXObserver> {
--- 227,232 ----
diff '--exclude=.git' -crB a/include/media/mediametadataretriever.h b/include/media/mediametadataretriever.h
*** a/include/media/mediametadataretriever.h	2018-09-22 10:19:51.617277956 +0200
--- b/include/media/mediametadataretriever.h	2018-09-22 10:11:05.436312592 +0200
***************
*** 77,83 ****
      const char* extractMetadata(int keyCode);
  
  private:
!     static const sp<IMediaPlayerService> getService();
  
      class DeathNotifier: public IBinder::DeathRecipient
      {
--- 77,83 ----
      const char* extractMetadata(int keyCode);
  
  private:
!     static const sp<IMediaPlayerService>& getService();
  
      class DeathNotifier: public IBinder::DeathRecipient
      {
diff '--exclude=.git' -crB a/include/media/SoundPool.h b/include/media/SoundPool.h
*** a/include/media/SoundPool.h	2018-09-22 10:19:51.617277956 +0200
--- b/include/media/SoundPool.h	2018-09-22 10:11:05.436312592 +0200
***************
*** 188,194 ****
  
      // called from SoundPoolThread
      void sampleLoaded(int sampleID);
-     sp<Sample> findSample(int sampleID);
  
      // called from AudioTrack thread
      void done_l(SoundChannel* channel);
--- 188,193 ----
***************
*** 200,206 ****
  private:
      SoundPool() {} // no default constructor
      bool startThreads();
!     sp<Sample> findSample_l(int sampleID);
      SoundChannel* findChannel (int channelID);
      SoundChannel* findNextChannel (int channelID);
      SoundChannel* allocateChannel_l(int priority);
--- 199,206 ----
  private:
      SoundPool() {} // no default constructor
      bool startThreads();
!     void doLoad(sp<Sample>& sample);
!     sp<Sample> findSample(int sampleID) { return mSamples.valueFor(sampleID); }
      SoundChannel* findChannel (int channelID);
      SoundChannel* findNextChannel (int channelID);
      SoundChannel* allocateChannel_l(int priority);
diff '--exclude=.git' -crB a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
*** a/include/media/stagefright/ACodec.h	2018-09-22 10:19:51.621277963 +0200
--- b/include/media/stagefright/ACodec.h	2018-09-22 10:11:05.436312592 +0200
***************
*** 188,194 ****
      bool mSentFormat;
      bool mIsEncoder;
      bool mUseMetadataOnEncoderOutput;
-     bool mFatalError;
      bool mShutdownInProgress;
      bool mIsConfiguredForAdaptivePlayback;
  
--- 188,193 ----
diff '--exclude=.git' -crB a/include/media/stagefright/CameraSource.h b/include/media/stagefright/CameraSource.h
*** a/include/media/stagefright/CameraSource.h	2018-09-22 10:19:51.621277963 +0200
--- b/include/media/stagefright/CameraSource.h	2018-09-22 10:11:05.436312592 +0200
***************
*** 239,247 ****
      status_t checkFrameRate(const CameraParameters& params,
                      int32_t frameRate);
  
-     static void adjustIncomingANWBuffer(IMemory* data);
-     static void adjustOutgoingANWBuffer(IMemory* data);
- 
      void stopCameraRecording();
      void releaseCamera();
      status_t reset();
--- 239,244 ----
diff '--exclude=.git' -crB a/include/media/stagefright/DataSource.h b/include/media/stagefright/DataSource.h
*** a/include/media/stagefright/DataSource.h	2018-09-22 10:19:51.621277963 +0200
--- b/include/media/stagefright/DataSource.h	2018-09-22 10:11:05.436312592 +0200
***************
*** 19,25 ****
  #define DATA_SOURCE_H_
  
  #include <sys/types.h>
! #include <media/stagefright/foundation/ADebug.h>
  #include <media/stagefright/MediaErrors.h>
  #include <utils/Errors.h>
  #include <utils/KeyedVector.h>
--- 19,25 ----
  #define DATA_SOURCE_H_
  
  #include <sys/types.h>
! 
  #include <media/stagefright/MediaErrors.h>
  #include <utils/Errors.h>
  #include <utils/KeyedVector.h>
***************
*** 93,112 ****
      bool getUInt32(off64_t offset, uint32_t *x);
      bool getUInt64(off64_t offset, uint64_t *x);
  
-     // Reads in "count" entries of type T into vector *x.
-     // Returns true if "count" entries can be read.
-     // If fewer than "count" entries can be read, return false. In this case,
-     // the output vector *x will still have those entries that were read. Call
-     // x->size() to obtain the number of entries read.
-     // The optional parameter chunkSize specifies how many entries should be
-     // read from the data source at one time into a temporary buffer. Increasing
-     // chunkSize can improve the performance at the cost of extra memory usage.
-     // The default value for chunkSize is set to read at least 4k bytes at a
-     // time, depending on sizeof(T).
-     template <typename T>
-     bool getVector(off64_t offset, Vector<T>* x, size_t count,
-                    size_t chunkSize = (4095 / sizeof(T)) + 1);
- 
      // May return ERROR_UNSUPPORTED.
      virtual status_t getSize(off64_t *size);
  
--- 93,98 ----
***************
*** 154,204 ****
      DataSource &operator=(const DataSource &);
  };
  
- template <typename T>
- bool DataSource::getVector(off64_t offset, Vector<T>* x, size_t count,
-                            size_t chunkSize)
- {
-     x->clear();
-     if (chunkSize == 0) {
-         return false;
-     }
-     if (count == 0) {
-         return true;
-     }
- 
-     T tmp[chunkSize];
-     ssize_t numBytesRead;
-     size_t numBytesPerChunk = chunkSize * sizeof(T);
-     size_t i;
- 
-     for (i = 0; i + chunkSize < count; i += chunkSize) {
-         // This loops is executed when more than chunkSize records need to be
-         // read.
-         numBytesRead = this->readAt(offset, (void*)&tmp, numBytesPerChunk);
-         if (numBytesRead == -1) { // If readAt() returns -1, there is an error.
-             return false;
-         }
-         if (numBytesRead < numBytesPerChunk) {
-             // This case is triggered when the stream ends before the whole
-             // chunk is read.
-             x->appendArray(tmp, (size_t)numBytesRead / sizeof(T));
-             return false;
-         }
-         x->appendArray(tmp, chunkSize);
-         offset += numBytesPerChunk;
-     }
- 
-     // There are (count - i) more records to read.
-     // Right now, (count - i) <= chunkSize.
-     // We do the same thing as above, but with chunkSize replaced by count - i.
-     numBytesRead = this->readAt(offset, (void*)&tmp, (count - i) * sizeof(T));
-     if (numBytesRead == -1) {
-         return false;
-     }
-     x->appendArray(tmp, (size_t)numBytesRead / sizeof(T));
-     return x->size() == count;
- }
- 
  }  // namespace android
  
  #endif  // DATA_SOURCE_H_
--- 140,145 ----
Nur in a/include/media/stagefright/foundation: AUtils.h.
diff '--exclude=.git' -crB a/include/media/stagefright/MetaData.h b/include/media/stagefright/MetaData.h
*** a/include/media/stagefright/MetaData.h	2018-09-22 10:19:51.621277963 +0200
--- b/include/media/stagefright/MetaData.h	2018-09-22 10:11:05.436312592 +0200
***************
*** 298,304 ****
              return mSize <= sizeof(u.reservoir);
          }
  
!         void *allocateStorage(size_t size);
          void freeStorage();
  
          void *storage() {
--- 298,304 ----
              return mSize <= sizeof(u.reservoir);
          }
  
!         void allocateStorage(size_t size);
          void freeStorage();
  
          void *storage() {
diff '--exclude=.git' -crB a/media/libeffects/downmix/EffectDownmix.c b/media/libeffects/downmix/EffectDownmix.c
*** a/media/libeffects/downmix/EffectDownmix.c	2018-09-22 10:19:51.645278008 +0200
--- b/media/libeffects/downmix/EffectDownmix.c	2018-09-22 10:11:05.436312592 +0200
***************
*** 160,167 ****
  /*--- Effect Library Interface Implementation ---*/
  
  int32_t DownmixLib_Create(const effect_uuid_t *uuid,
!         int32_t sessionId __unused,
!         int32_t ioId __unused,
          effect_handle_t *pHandle) {
      int ret;
      int i;
--- 160,167 ----
  /*--- Effect Library Interface Implementation ---*/
  
  int32_t DownmixLib_Create(const effect_uuid_t *uuid,
!         int32_t sessionId,
!         int32_t ioId,
          effect_handle_t *pHandle) {
      int ret;
      int i;
***************
*** 384,390 ****
  
      switch (cmdCode) {
      case EFFECT_CMD_INIT:
!         if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          *(int *) pReplyData = Downmix_Init(pDwmModule);
--- 384,390 ----
  
      switch (cmdCode) {
      case EFFECT_CMD_INIT:
!         if (pReplyData == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          *(int *) pReplyData = Downmix_Init(pDwmModule);
***************
*** 392,398 ****
  
      case EFFECT_CMD_SET_CONFIG:
          if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
!                 || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          *(int *) pReplyData = Downmix_Configure(pDwmModule,
--- 392,398 ----
  
      case EFFECT_CMD_SET_CONFIG:
          if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
!                 || pReplyData == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          *(int *) pReplyData = Downmix_Configure(pDwmModule,
***************
*** 407,413 ****
          ALOGV("Downmix_Command EFFECT_CMD_GET_PARAM pCmdData %p, *replySize %d, pReplyData: %p",
                  pCmdData, *replySize, pReplyData);
          if (pCmdData == NULL || cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||
!                 pReplyData == NULL || replySize == NULL ||
                  *replySize < (int) sizeof(effect_param_t) + 2 * sizeof(int32_t)) {
              return -EINVAL;
          }
--- 407,413 ----
          ALOGV("Downmix_Command EFFECT_CMD_GET_PARAM pCmdData %p, *replySize %d, pReplyData: %p",
                  pCmdData, *replySize, pReplyData);
          if (pCmdData == NULL || cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||
!                 pReplyData == NULL ||
                  *replySize < (int) sizeof(effect_param_t) + 2 * sizeof(int32_t)) {
              return -EINVAL;
          }
***************
*** 424,430 ****
          ALOGV("Downmix_Command EFFECT_CMD_SET_PARAM cmdSize %d pCmdData %p, *replySize %d, " \
                  "pReplyData %p", cmdSize, pCmdData, *replySize, pReplyData);
          if (pCmdData == NULL || (cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)))
!                 || pReplyData == NULL || replySize == NULL || *replySize != (int)sizeof(int32_t)) {
              return -EINVAL;
          }
          effect_param_t *cmd = (effect_param_t *) pCmdData;
--- 424,430 ----
          ALOGV("Downmix_Command EFFECT_CMD_SET_PARAM cmdSize %d pCmdData %p, *replySize %d, " \
                  "pReplyData %p", cmdSize, pCmdData, *replySize, pReplyData);
          if (pCmdData == NULL || (cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)))
!                 || pReplyData == NULL || *replySize != (int)sizeof(int32_t)) {
              return -EINVAL;
          }
          effect_param_t *cmd = (effect_param_t *) pCmdData;
***************
*** 443,449 ****
          break;
  
      case EFFECT_CMD_ENABLE:
!         if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          if (pDownmixer->state != DOWNMIX_STATE_INITIALIZED) {
--- 443,449 ----
          break;
  
      case EFFECT_CMD_ENABLE:
!         if (pReplyData == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          if (pDownmixer->state != DOWNMIX_STATE_INITIALIZED) {
***************
*** 455,461 ****
          break;
  
      case EFFECT_CMD_DISABLE:
!         if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          if (pDownmixer->state != DOWNMIX_STATE_ACTIVE) {
--- 455,461 ----
          break;
  
      case EFFECT_CMD_DISABLE:
!         if (pReplyData == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          if (pDownmixer->state != DOWNMIX_STATE_ACTIVE) {
***************
*** 670,676 ****
   *----------------------------------------------------------------------------
   */
  
! int Downmix_Reset(downmix_object_t *pDownmixer __unused, bool init __unused) {
      // nothing to do here
      return 0;
  }
--- 670,676 ----
   *----------------------------------------------------------------------------
   */
  
! int Downmix_Reset(downmix_object_t *pDownmixer, bool init) {
      // nothing to do here
      return 0;
  }
diff '--exclude=.git' -crB a/media/libeffects/loudness/EffectLoudnessEnhancer.cpp b/media/libeffects/loudness/EffectLoudnessEnhancer.cpp
*** a/media/libeffects/loudness/EffectLoudnessEnhancer.cpp	2018-09-22 10:19:51.645278008 +0200
--- b/media/libeffects/loudness/EffectLoudnessEnhancer.cpp	2018-09-22 10:11:05.436312592 +0200
***************
*** 189,196 ****
  //
  
  int LELib_Create(const effect_uuid_t *uuid,
!                          int32_t sessionId __unused,
!                          int32_t ioId __unused,
                           effect_handle_t *pHandle) {
      ALOGV("LELib_Create()");
      int ret;
--- 189,196 ----
  //
  
  int LELib_Create(const effect_uuid_t *uuid,
!                          int32_t sessionId,
!                          int32_t ioId,
                           effect_handle_t *pHandle) {
      ALOGV("LELib_Create()");
      int ret;
***************
*** 327,333 ****
          break;
      case EFFECT_CMD_SET_CONFIG:
          if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
!                 || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          *(int *) pReplyData = LE_setConfig(pContext,
--- 327,333 ----
          break;
      case EFFECT_CMD_SET_CONFIG:
          if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
!                 || pReplyData == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          *(int *) pReplyData = LE_setConfig(pContext,
***************
*** 344,350 ****
          LE_reset(pContext);
          break;
      case EFFECT_CMD_ENABLE:
!         if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          if (pContext->mState != LOUDNESS_ENHANCER_STATE_INITIALIZED) {
--- 344,350 ----
          LE_reset(pContext);
          break;
      case EFFECT_CMD_ENABLE:
!         if (pReplyData == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          if (pContext->mState != LOUDNESS_ENHANCER_STATE_INITIALIZED) {
***************
*** 368,374 ****
      case EFFECT_CMD_GET_PARAM: {
          if (pCmdData == NULL ||
              cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
!             pReplyData == NULL || replySize == NULL ||
              *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
              return -EINVAL;
          }
--- 368,374 ----
      case EFFECT_CMD_GET_PARAM: {
          if (pCmdData == NULL ||
              cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
!             pReplyData == NULL ||
              *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
              return -EINVAL;
          }
***************
*** 394,400 ****
      case EFFECT_CMD_SET_PARAM: {
          if (pCmdData == NULL ||
              cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
!             pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
              return -EINVAL;
          }
          *(int32_t *)pReplyData = 0;
--- 394,400 ----
      case EFFECT_CMD_SET_PARAM: {
          if (pCmdData == NULL ||
              cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
!             pReplyData == NULL || *replySize != sizeof(int32_t)) {
              return -EINVAL;
          }
          *(int32_t *)pReplyData = 0;
diff '--exclude=.git' -crB a/media/libeffects/lvm/wrapper/Bundle/EffectBundle.cpp b/media/libeffects/lvm/wrapper/Bundle/EffectBundle.cpp
*** a/media/libeffects/lvm/wrapper/Bundle/EffectBundle.cpp	2018-09-22 10:19:51.657278030 +0200
--- b/media/libeffects/lvm/wrapper/Bundle/EffectBundle.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 2762,2768 ****
  
      switch (cmdCode){
          case EFFECT_CMD_INIT:
!             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){
                  ALOGV("\tLVM_ERROR, EFFECT_CMD_INIT: ERROR for effect type %d",
                          pContext->EffectType);
                  return -EINVAL;
--- 2762,2768 ----
  
      switch (cmdCode){
          case EFFECT_CMD_INIT:
!             if (pReplyData == NULL || *replySize != sizeof(int)){
                  ALOGV("\tLVM_ERROR, EFFECT_CMD_INIT: ERROR for effect type %d",
                          pContext->EffectType);
                  return -EINVAL;
***************
*** 2789,2796 ****
  
          case EFFECT_CMD_SET_CONFIG:
              //ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_SET_CONFIG start");
!             if (pCmdData    == NULL || cmdSize     != sizeof(effect_config_t) ||
!                     pReplyData  == NULL || replySize == NULL || *replySize  != sizeof(int)) {
                  ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: "
                          "EFFECT_CMD_SET_CONFIG: ERROR");
                  return -EINVAL;
--- 2789,2798 ----
  
          case EFFECT_CMD_SET_CONFIG:
              //ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_SET_CONFIG start");
!             if (pCmdData    == NULL||
!                 cmdSize     != sizeof(effect_config_t)||
!                 pReplyData  == NULL||
!                 *replySize  != sizeof(int)){
                  ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: "
                          "EFFECT_CMD_SET_CONFIG: ERROR");
                  return -EINVAL;
***************
*** 2800,2806 ****
              break;
  
          case EFFECT_CMD_GET_CONFIG:
!             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {
                  ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: "
                          "EFFECT_CMD_GET_CONFIG: ERROR");
                  return -EINVAL;
--- 2802,2809 ----
              break;
  
          case EFFECT_CMD_GET_CONFIG:
!             if (pReplyData == NULL ||
!                 *replySize != sizeof(effect_config_t)) {
                  ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: "
                          "EFFECT_CMD_GET_CONFIG: ERROR");
                  return -EINVAL;
***************
*** 2818,2847 ****
          case EFFECT_CMD_GET_PARAM:{
              //ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_GET_PARAM start");
  
!             effect_param_t *p = (effect_param_t *)pCmdData;
!             if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {
!                 android_errorWriteLog(0x534e4554, "26347509");
!                 return -EINVAL;
!             }
!             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||
!                     cmdSize < (sizeof(effect_param_t) + p->psize) ||
!                     pReplyData == NULL || replySize == NULL ||
!                     *replySize < (sizeof(effect_param_t) + p->psize)) {
!                 ALOGV("\tLVM_ERROR : EFFECT_CMD_GET_PARAM: ERROR");
!                 return -EINVAL;
!             }
  
!             memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
  
!             p = (effect_param_t *)pReplyData;
  
!             int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
  
-             if(pContext->EffectType == LVM_BASS_BOOST){
                  p->status = android::BassBoost_getParameter(pContext,
                                                              p->data,
                                                              (size_t  *)&p->vsize,
                                                              p->data + voffset);
                  //ALOGV("\tBassBoost_command EFFECT_CMD_GET_PARAM "
                  //        "*pCmdData %d, *replySize %d, *pReplyData %d ",
                  //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
--- 2821,2850 ----
          case EFFECT_CMD_GET_PARAM:{
              //ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_GET_PARAM start");
  
!             if(pContext->EffectType == LVM_BASS_BOOST){
!                 if (pCmdData == NULL ||
!                         cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||
!                         pReplyData == NULL ||
!                         *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))){
!                     ALOGV("\tLVM_ERROR : BassBoost_command cmdCode Case: "
!                             "EFFECT_CMD_GET_PARAM: ERROR");
!                     return -EINVAL;
!                 }
!                 effect_param_t *p = (effect_param_t *)pCmdData;
  
!                 memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
  
!                 p = (effect_param_t *)pReplyData;
  
!                 int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
  
                  p->status = android::BassBoost_getParameter(pContext,
                                                              p->data,
                                                              (size_t  *)&p->vsize,
                                                              p->data + voffset);
+ 
+                 *replySize = sizeof(effect_param_t) + voffset + p->vsize;
+ 
                  //ALOGV("\tBassBoost_command EFFECT_CMD_GET_PARAM "
                  //        "*pCmdData %d, *replySize %d, *pReplyData %d ",
                  //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
***************
*** 2850,2860 ****
--- 2853,2881 ----
              }
  
              if(pContext->EffectType == LVM_VIRTUALIZER){
+                 if (pCmdData == NULL ||
+                         cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||
+                         pReplyData == NULL ||
+                         *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))){
+                     ALOGV("\tLVM_ERROR : Virtualizer_command cmdCode Case: "
+                             "EFFECT_CMD_GET_PARAM: ERROR");
+                     return -EINVAL;
+                 }
+                 effect_param_t *p = (effect_param_t *)pCmdData;
+ 
+                 memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
+ 
+                 p = (effect_param_t *)pReplyData;
+ 
+                 int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
+ 
                  p->status = android::Virtualizer_getParameter(pContext,
                                                               (void *)p->data,
                                                               (size_t  *)&p->vsize,
                                                                p->data + voffset);
  
+                 *replySize = sizeof(effect_param_t) + voffset + p->vsize;
+ 
                  //ALOGV("\tVirtualizer_command EFFECT_CMD_GET_PARAM "
                  //        "*pCmdData %d, *replySize %d, *pReplyData %d ",
                  //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
***************
*** 2864,2874 ****
--- 2885,2913 ----
              if(pContext->EffectType == LVM_EQUALIZER){
                  //ALOGV("\tEqualizer_command cmdCode Case: "
                  //        "EFFECT_CMD_GET_PARAM start");
+                 if (pCmdData == NULL ||
+                     cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||
+                     pReplyData == NULL ||
+                     *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))) {
+                     ALOGV("\tLVM_ERROR : Equalizer_command cmdCode Case: "
+                             "EFFECT_CMD_GET_PARAM");
+                     return -EINVAL;
+                 }
+                 effect_param_t *p = (effect_param_t *)pCmdData;
+ 
+                 memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
+ 
+                 p = (effect_param_t *)pReplyData;
+ 
+                 int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
+ 
                  p->status = android::Equalizer_getParameter(pContext,
                                                              p->data,
                                                              &p->vsize,
                                                              p->data + voffset);
  
+                 *replySize = sizeof(effect_param_t) + voffset + p->vsize;
+ 
                  //ALOGV("\tEqualizer_command EFFECT_CMD_GET_PARAM *pCmdData %d, *replySize %d, "
                  //       "*pReplyData %08x %08x",
                  //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)), *replySize,
***************
*** 2878,2896 ****
              }
              if(pContext->EffectType == LVM_VOLUME){
                  //ALOGV("\tVolume_command cmdCode Case: EFFECT_CMD_GET_PARAM start");
                  p->status = android::Volume_getParameter(pContext,
                                                           (void *)p->data,
                                                           (size_t  *)&p->vsize,
                                                           p->data + voffset);
  
                  //ALOGV("\tVolume_command EFFECT_CMD_GET_PARAM "
                  //        "*pCmdData %d, *replySize %d, *pReplyData %d ",
                  //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
                  //        *replySize,
                  //        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));
              }
-             *replySize = sizeof(effect_param_t) + voffset + p->vsize;
- 
              //ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_GET_PARAM end");
          } break;
          case EFFECT_CMD_SET_PARAM:{
--- 2917,2951 ----
              }
              if(pContext->EffectType == LVM_VOLUME){
                  //ALOGV("\tVolume_command cmdCode Case: EFFECT_CMD_GET_PARAM start");
+                 if (pCmdData == NULL ||
+                         cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||
+                         pReplyData == NULL ||
+                         *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))){
+                     ALOGV("\tLVM_ERROR : Volume_command cmdCode Case: "
+                             "EFFECT_CMD_GET_PARAM: ERROR");
+                     return -EINVAL;
+                 }
+                 effect_param_t *p = (effect_param_t *)pCmdData;
+ 
+                 memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
+ 
+                 p = (effect_param_t *)pReplyData;
+ 
+                 int voffset = ((p->psize - 1) / sizeof(int32_t) + 1) * sizeof(int32_t);
+ 
                  p->status = android::Volume_getParameter(pContext,
                                                           (void *)p->data,
                                                           (size_t  *)&p->vsize,
                                                           p->data + voffset);
  
+                 *replySize = sizeof(effect_param_t) + voffset + p->vsize;
+ 
                  //ALOGV("\tVolume_command EFFECT_CMD_GET_PARAM "
                  //        "*pCmdData %d, *replySize %d, *pReplyData %d ",
                  //        *(int32_t *)((char *)pCmdData + sizeof(effect_param_t)),
                  //        *replySize,
                  //        *(int16_t *)((char *)pReplyData + sizeof(effect_param_t) + voffset));
              }
              //ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_GET_PARAM end");
          } break;
          case EFFECT_CMD_SET_PARAM:{
***************
*** 2901,2909 ****
                  //       *replySize,
                  //       *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));
  
!                 if (pCmdData   == NULL ||
!                         cmdSize    != (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||
!                         pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
                      ALOGV("\tLVM_ERROR : BassBoost_command cmdCode Case: "
                              "EFFECT_CMD_SET_PARAM: ERROR");
                      return -EINVAL;
--- 2956,2965 ----
                  //       *replySize,
                  //       *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));
  
!                 if (pCmdData   == NULL||
!                     cmdSize    != (int)(sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t))||
!                     pReplyData == NULL||
!                     *replySize != sizeof(int32_t)){
                      ALOGV("\tLVM_ERROR : BassBoost_command cmdCode Case: "
                              "EFFECT_CMD_SET_PARAM: ERROR");
                      return -EINVAL;
***************
*** 2933,2943 ****
                //        *replySize,
                //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));
  
!                 if (pCmdData   == NULL ||
!                         // legal parameters are int16_t or int32_t
!                         cmdSize    > (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int32_t)) ||
!                         cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t)) ||
!                         pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
                      ALOGV("\tLVM_ERROR : Virtualizer_command cmdCode Case: "
                              "EFFECT_CMD_SET_PARAM: ERROR");
                      return -EINVAL;
--- 2989,2998 ----
                //        *replySize,
                //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));
  
!                 if (pCmdData   == NULL||
!                     cmdSize    != (int)(sizeof(effect_param_t) + sizeof(int32_t) +sizeof(int16_t))||
!                     pReplyData == NULL||
!                     *replySize != sizeof(int32_t)){
                      ALOGV("\tLVM_ERROR : Virtualizer_command cmdCode Case: "
                              "EFFECT_CMD_SET_PARAM: ERROR");
                      return -EINVAL;
***************
*** 2969,2976 ****
                 //        *replySize,
                 //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));
  
!                 if (pCmdData == NULL || cmdSize < (sizeof(effect_param_t) + sizeof(int32_t)) ||
!                         pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
                      ALOGV("\tLVM_ERROR : Equalizer_command cmdCode Case: "
                              "EFFECT_CMD_SET_PARAM: ERROR");
                      return -EINVAL;
--- 3024,3031 ----
                 //        *replySize,
                 //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));
  
!                 if (pCmdData == NULL || cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||
!                     pReplyData == NULL || *replySize != sizeof(int32_t)) {
                      ALOGV("\tLVM_ERROR : Equalizer_command cmdCode Case: "
                              "EFFECT_CMD_SET_PARAM: ERROR");
                      return -EINVAL;
***************
*** 2988,2997 ****
                  //        *replySize,
                  //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) +sizeof(int32_t)));
  
!                 if (pCmdData   == NULL ||
!                         cmdSize    < (sizeof(effect_param_t) + sizeof(int32_t)) ||
!                         pReplyData == NULL || replySize == NULL ||
!                         *replySize != sizeof(int32_t)) {
                      ALOGV("\tLVM_ERROR : Volume_command cmdCode Case: "
                              "EFFECT_CMD_SET_PARAM: ERROR");
                      return -EINVAL;
--- 3043,3052 ----
                  //        *replySize,
                  //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) +sizeof(int32_t)));
  
!                 if (    pCmdData   == NULL||
!                         cmdSize    < (int)(sizeof(effect_param_t) + sizeof(int32_t))||
!                         pReplyData == NULL||
!                         *replySize != sizeof(int32_t)){
                      ALOGV("\tLVM_ERROR : Volume_command cmdCode Case: "
                              "EFFECT_CMD_SET_PARAM: ERROR");
                      return -EINVAL;
***************
*** 3007,3013 ****
  
          case EFFECT_CMD_ENABLE:
              ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_ENABLE start");
!             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
                  ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_ENABLE: ERROR");
                  return -EINVAL;
              }
--- 3062,3068 ----
  
          case EFFECT_CMD_ENABLE:
              ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_ENABLE start");
!             if (pReplyData == NULL || *replySize != sizeof(int)){
                  ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_ENABLE: ERROR");
                  return -EINVAL;
              }
***************
*** 3017,3023 ****
  
          case EFFECT_CMD_DISABLE:
              //ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_DISABLE start");
!             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
                  ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_DISABLE: ERROR");
                  return -EINVAL;
              }
--- 3072,3078 ----
  
          case EFFECT_CMD_DISABLE:
              //ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_DISABLE start");
!             if (pReplyData == NULL || *replySize != sizeof(int)){
                  ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_DISABLE: ERROR");
                  return -EINVAL;
              }
***************
*** 3027,3037 ****
          case EFFECT_CMD_SET_DEVICE:
          {
              ALOGV("\tEffect_command cmdCode Case: EFFECT_CMD_SET_DEVICE start");
-             if (pCmdData   == NULL){
-                 ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: EFFECT_CMD_SET_DEVICE: ERROR");
-                 return -EINVAL;
-             }
- 
              uint32_t device = *(uint32_t *)pCmdData;
  
              if (pContext->EffectType == LVM_BASS_BOOST) {
--- 3082,3087 ----
***************
*** 3118,3125 ****
                  break;
              }
  
!             if (pCmdData == NULL || cmdSize != 2 * sizeof(uint32_t) || pReplyData == NULL ||
!                     replySize == NULL || *replySize < 2*sizeof(int32_t)) {
                  ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: "
                          "EFFECT_CMD_SET_VOLUME: ERROR");
                  return -EINVAL;
--- 3168,3175 ----
                  break;
              }
  
!             if (pCmdData == NULL ||
!                 cmdSize != 2 * sizeof(uint32_t)) {
                  ALOGV("\tLVM_ERROR : Effect_command cmdCode Case: "
                          "EFFECT_CMD_SET_VOLUME: ERROR");
                  return -EINVAL;
diff '--exclude=.git' -crB a/media/libeffects/lvm/wrapper/Reverb/EffectReverb.cpp b/media/libeffects/lvm/wrapper/Reverb/EffectReverb.cpp
*** a/media/libeffects/lvm/wrapper/Reverb/EffectReverb.cpp	2018-09-22 10:19:51.657278030 +0200
--- b/media/libeffects/lvm/wrapper/Reverb/EffectReverb.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 188,195 ****
  /* Effect Library Interface Implementation */
  
  extern "C" int EffectCreate(const effect_uuid_t *uuid,
!                             int32_t             sessionId __unused,
!                             int32_t             ioId __unused,
                              effect_handle_t  *pHandle){
      int ret;
      int i;
--- 188,195 ----
  /* Effect Library Interface Implementation */
  
  extern "C" int EffectCreate(const effect_uuid_t *uuid,
!                             int32_t             sessionId,
!                             int32_t             ioId,
                              effect_handle_t  *pHandle){
      int ret;
      int i;
***************
*** 1912,1918 ****
              //ALOGV("\tReverb_command cmdCode Case: "
              //        "EFFECT_CMD_INIT start");
  
!             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){
                  ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
                          "EFFECT_CMD_INIT: ERROR");
                  return -EINVAL;
--- 1912,1918 ----
              //ALOGV("\tReverb_command cmdCode Case: "
              //        "EFFECT_CMD_INIT start");
  
!             if (pReplyData == NULL || *replySize != sizeof(int)){
                  ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
                          "EFFECT_CMD_INIT: ERROR");
                  return -EINVAL;
***************
*** 1923,1930 ****
          case EFFECT_CMD_SET_CONFIG:
              //ALOGV("\tReverb_command cmdCode Case: "
              //        "EFFECT_CMD_SET_CONFIG start");
!             if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) ||
!                     pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
                  ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
                          "EFFECT_CMD_SET_CONFIG: ERROR");
                  return -EINVAL;
--- 1923,1932 ----
          case EFFECT_CMD_SET_CONFIG:
              //ALOGV("\tReverb_command cmdCode Case: "
              //        "EFFECT_CMD_SET_CONFIG start");
!             if (pCmdData == NULL ||
!                 cmdSize != sizeof(effect_config_t) ||
!                 pReplyData == NULL ||
!                 *replySize != sizeof(int)) {
                  ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
                          "EFFECT_CMD_SET_CONFIG: ERROR");
                  return -EINVAL;
***************
*** 1934,1940 ****
              break;
  
          case EFFECT_CMD_GET_CONFIG:
!             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(effect_config_t)) {
                  ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
                          "EFFECT_CMD_GET_CONFIG: ERROR");
                  return -EINVAL;
--- 1936,1943 ----
              break;
  
          case EFFECT_CMD_GET_CONFIG:
!             if (pReplyData == NULL ||
!                 *replySize != sizeof(effect_config_t)) {
                  ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
                          "EFFECT_CMD_GET_CONFIG: ERROR");
                  return -EINVAL;
***************
*** 1952,1970 ****
          case EFFECT_CMD_GET_PARAM:{
              //ALOGV("\tReverb_command cmdCode Case: "
              //        "EFFECT_CMD_GET_PARAM start");
!             effect_param_t *p = (effect_param_t *)pCmdData;
!             if (SIZE_MAX - sizeof(effect_param_t) < (size_t)p->psize) {
!                 android_errorWriteLog(0x534e4554, "26347509");
!                 return -EINVAL;
!             }
!             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||
!                     cmdSize < (sizeof(effect_param_t) + p->psize) ||
!                     pReplyData == NULL || replySize == NULL ||
!                     *replySize < (sizeof(effect_param_t) + p->psize)) {
                  ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
                          "EFFECT_CMD_GET_PARAM: ERROR");
                  return -EINVAL;
              }
  
              memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
  
--- 1955,1969 ----
          case EFFECT_CMD_GET_PARAM:{
              //ALOGV("\tReverb_command cmdCode Case: "
              //        "EFFECT_CMD_GET_PARAM start");
!             if (pCmdData == NULL ||
!                     cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) ||
!                     pReplyData == NULL ||
!                     *replySize < (int) (sizeof(effect_param_t) + sizeof(int32_t))){
                  ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
                          "EFFECT_CMD_GET_PARAM: ERROR");
                  return -EINVAL;
              }
+             effect_param_t *p = (effect_param_t *)pCmdData;
  
              memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
  
***************
*** 1995,2002 ****
              //        *replySize,
              //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));
  
!             if (pCmdData == NULL || (cmdSize < (sizeof(effect_param_t) + sizeof(int32_t))) ||
!                     pReplyData == NULL ||  replySize == NULL || *replySize != sizeof(int32_t)) {
                  ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
                          "EFFECT_CMD_SET_PARAM: ERROR");
                  return -EINVAL;
--- 1994,2001 ----
              //        *replySize,
              //        *(int16_t *)((char *)pCmdData + sizeof(effect_param_t) + sizeof(int32_t)));
  
!             if (pCmdData == NULL || (cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)))
!                     || pReplyData == NULL || *replySize != (int)sizeof(int32_t)) {
                  ALOGV("\tLVM_ERROR : Reverb_command cmdCode Case: "
                          "EFFECT_CMD_SET_PARAM: ERROR");
                  return -EINVAL;
diff '--exclude=.git' -crB a/media/libeffects/preprocessing/PreProcessing.cpp b/media/libeffects/preprocessing/PreProcessing.cpp
*** a/media/libeffects/preprocessing/PreProcessing.cpp	2018-09-22 10:19:51.657278030 +0200
--- b/media/libeffects/preprocessing/PreProcessing.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 575,592 ****
      return 0;
  }
  
! int NsGetParameter(preproc_effect_t  *effect __unused,
!                    void              *pParam __unused,
!                    uint32_t          *pValueSize __unused,
!                    void              *pValue __unused)
  {
      int status = 0;
      return status;
  }
  
! int NsSetParameter (preproc_effect_t *effect __unused,
!                     void *pParam __unused,
!                     void *pValue __unused)
  {
      int status = 0;
      return status;
--- 575,590 ----
      return 0;
  }
  
! int NsGetParameter(preproc_effect_t     *effect,
!                    void              *pParam,
!                    size_t            *pValueSize,
!                    void              *pValue)
  {
      int status = 0;
      return status;
  }
  
! int NsSetParameter (preproc_effect_t *effect, void *pParam, void *pValue)
  {
      int status = 0;
      return status;
***************
*** 1436,1452 ****
              }
              break;
  
!         case EFFECT_CMD_GET_PARAM: {
!             effect_param_t *p = (effect_param_t *)pCmdData;
! 
!             if (pCmdData == NULL || cmdSize < sizeof(effect_param_t) ||
!                     cmdSize < (sizeof(effect_param_t) + p->psize) ||
!                     pReplyData == NULL || replySize == NULL ||
!                     *replySize < (sizeof(effect_param_t) + p->psize)){
                  ALOGV("PreProcessingFx_Command cmdCode Case: "
                          "EFFECT_CMD_GET_PARAM: ERROR");
                  return -EINVAL;
              }
  
              memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
  
--- 1434,1449 ----
              }
              break;
  
!         case EFFECT_CMD_GET_PARAM:{
!             if (pCmdData == NULL ||
!                     cmdSize < (int)sizeof(effect_param_t) ||
!                     pReplyData == NULL ||
!                     *replySize < (int)sizeof(effect_param_t)){
                  ALOGV("PreProcessingFx_Command cmdCode Case: "
                          "EFFECT_CMD_GET_PARAM: ERROR");
                  return -EINVAL;
              }
+             effect_param_t *p = (effect_param_t *)pCmdData;
  
              memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + p->psize);
  
***************
*** 1464,1471 ****
  
          case EFFECT_CMD_SET_PARAM:{
              if (pCmdData == NULL||
!                     cmdSize < sizeof(effect_param_t) ||
!                     pReplyData == NULL || replySize == NULL ||
                      *replySize != sizeof(int32_t)){
                  ALOGV("PreProcessingFx_Command cmdCode Case: "
                          "EFFECT_CMD_SET_PARAM: ERROR");
--- 1461,1468 ----
  
          case EFFECT_CMD_SET_PARAM:{
              if (pCmdData == NULL||
!                     cmdSize < (int)sizeof(effect_param_t) ||
!                     pReplyData == NULL ||
                      *replySize != sizeof(int32_t)){
                  ALOGV("PreProcessingFx_Command cmdCode Case: "
                          "EFFECT_CMD_SET_PARAM: ERROR");
***************
*** 1486,1492 ****
          } break;
  
          case EFFECT_CMD_ENABLE:
!             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){
                  ALOGV("PreProcessingFx_Command cmdCode Case: EFFECT_CMD_ENABLE: ERROR");
                  return -EINVAL;
              }
--- 1483,1489 ----
          } break;
  
          case EFFECT_CMD_ENABLE:
!             if (pReplyData == NULL || *replySize != sizeof(int)){
                  ALOGV("PreProcessingFx_Command cmdCode Case: EFFECT_CMD_ENABLE: ERROR");
                  return -EINVAL;
              }
***************
*** 1494,1500 ****
              break;
  
          case EFFECT_CMD_DISABLE:
!             if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)){
                  ALOGV("PreProcessingFx_Command cmdCode Case: EFFECT_CMD_DISABLE: ERROR");
                  return -EINVAL;
              }
--- 1491,1497 ----
              break;
  
          case EFFECT_CMD_DISABLE:
!             if (pReplyData == NULL || *replySize != sizeof(int)){
                  ALOGV("PreProcessingFx_Command cmdCode Case: EFFECT_CMD_DISABLE: ERROR");
                  return -EINVAL;
              }
***************
*** 1714,1720 ****
  
  int PreProcessingFx_ProcessReverse(effect_handle_t     self,
                                     audio_buffer_t    *inBuffer,
!                                    audio_buffer_t    *outBuffer __unused)
  {
      preproc_effect_t * effect = (preproc_effect_t *)self;
      int    status = 0;
--- 1711,1717 ----
  
  int PreProcessingFx_ProcessReverse(effect_handle_t     self,
                                     audio_buffer_t    *inBuffer,
!                                    audio_buffer_t    *outBuffer)
  {
      preproc_effect_t * effect = (preproc_effect_t *)self;
      int    status = 0;
diff '--exclude=.git' -crB a/media/libeffects/visualizer/EffectVisualizer.cpp b/media/libeffects/visualizer/EffectVisualizer.cpp
*** a/media/libeffects/visualizer/EffectVisualizer.cpp	2018-09-22 10:19:51.661278036 +0200
--- b/media/libeffects/visualizer/EffectVisualizer.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 24,30 ****
  #include <time.h>
  #include <math.h>
  #include <audio_effects/effect_visualizer.h>
- #include <cutils/log.h>
  
  
  extern "C" {
--- 24,29 ----
***************
*** 423,443 ****
  
      switch (cmdCode) {
      case EFFECT_CMD_INIT:
!         if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          *(int *) pReplyData = Visualizer_init(pContext);
          break;
      case EFFECT_CMD_SET_CONFIG:
          if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
!                 || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          *(int *) pReplyData = Visualizer_setConfig(pContext,
                  (effect_config_t *) pCmdData);
          break;
      case EFFECT_CMD_GET_CONFIG:
!         if (pReplyData == NULL || replySize == NULL ||
              *replySize != sizeof(effect_config_t)) {
              return -EINVAL;
          }
--- 422,442 ----
  
      switch (cmdCode) {
      case EFFECT_CMD_INIT:
!         if (pReplyData == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          *(int *) pReplyData = Visualizer_init(pContext);
          break;
      case EFFECT_CMD_SET_CONFIG:
          if (pCmdData == NULL || cmdSize != sizeof(effect_config_t)
!                 || pReplyData == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          *(int *) pReplyData = Visualizer_setConfig(pContext,
                  (effect_config_t *) pCmdData);
          break;
      case EFFECT_CMD_GET_CONFIG:
!         if (pReplyData == NULL ||
              *replySize != sizeof(effect_config_t)) {
              return -EINVAL;
          }
***************
*** 447,453 ****
          Visualizer_reset(pContext);
          break;
      case EFFECT_CMD_ENABLE:
!         if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {
--- 446,452 ----
          Visualizer_reset(pContext);
          break;
      case EFFECT_CMD_ENABLE:
!         if (pReplyData == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          if (pContext->mState != VISUALIZER_STATE_INITIALIZED) {
***************
*** 458,464 ****
          *(int *)pReplyData = 0;
          break;
      case EFFECT_CMD_DISABLE:
!         if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          if (pContext->mState != VISUALIZER_STATE_ACTIVE) {
--- 457,463 ----
          *(int *)pReplyData = 0;
          break;
      case EFFECT_CMD_DISABLE:
!         if (pReplyData == NULL || *replySize != sizeof(int)) {
              return -EINVAL;
          }
          if (pContext->mState != VISUALIZER_STATE_ACTIVE) {
***************
*** 471,477 ****
      case EFFECT_CMD_GET_PARAM: {
          if (pCmdData == NULL ||
              cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
!             pReplyData == NULL || replySize == NULL ||
              *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
              return -EINVAL;
          }
--- 470,476 ----
      case EFFECT_CMD_GET_PARAM: {
          if (pCmdData == NULL ||
              cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t)) ||
!             pReplyData == NULL ||
              *replySize < (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t))) {
              return -EINVAL;
          }
***************
*** 509,515 ****
      case EFFECT_CMD_SET_PARAM: {
          if (pCmdData == NULL ||
              cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
!             pReplyData == NULL || replySize == NULL || *replySize != sizeof(int32_t)) {
              return -EINVAL;
          }
          *(int32_t *)pReplyData = 0;
--- 508,514 ----
      case EFFECT_CMD_SET_PARAM: {
          if (pCmdData == NULL ||
              cmdSize != (int)(sizeof(effect_param_t) + sizeof(uint32_t) + sizeof(uint32_t)) ||
!             pReplyData == NULL || *replySize != sizeof(int32_t)) {
              return -EINVAL;
          }
          *(int32_t *)pReplyData = 0;
***************
*** 545,555 ****
          break;
  
  
!     case VISUALIZER_CMD_CAPTURE: {
!         uint32_t captureSize = pContext->mCaptureSize;
!         if (pReplyData == NULL || replySize == NULL || *replySize != captureSize) {
!             ALOGV("VISUALIZER_CMD_CAPTURE() error *replySize %" PRIu32 " captureSize %" PRIu32,
!                     *replySize, captureSize);
              return -EINVAL;
          }
          if (pContext->mState == VISUALIZER_STATE_ACTIVE) {
--- 544,553 ----
          break;
  
  
!     case VISUALIZER_CMD_CAPTURE:
!         if (pReplyData == NULL || *replySize != pContext->mCaptureSize) {
!             ALOGV("VISUALIZER_CMD_CAPTURE() error *replySize %d pContext->mCaptureSize %d",
!                     *replySize, pContext->mCaptureSize);
              return -EINVAL;
          }
          if (pContext->mState == VISUALIZER_STATE_ACTIVE) {
***************
*** 594,611 ****
          } else {
              memset(pReplyData, 0x80, pContext->mCaptureSize);
          }
!         }
          break;
  
      case VISUALIZER_CMD_MEASURE: {
-         if (pReplyData == NULL || replySize == NULL ||
-                 *replySize < (sizeof(int32_t) * MEASUREMENT_COUNT)) {
-             ALOGV("VISUALIZER_CMD_MEASURE() error *replySize %" PRIu32
-                     " < (sizeof(int32_t) * MEASUREMENT_COUNT) %" PRIu32, *replySize,
-                     sizeof(int32_t) * MEASUREMENT_COUNT);
-             android_errorWriteLog(0x534e4554, "30229821");
-             return -EINVAL;
-         }
          uint16_t peakU16 = 0;
          float sumRmsSquared = 0.0f;
          uint8_t nbValidMeasurements = 0;
--- 592,601 ----
          } else {
              memset(pReplyData, 0x80, pContext->mCaptureSize);
          }
! 
          break;
  
      case VISUALIZER_CMD_MEASURE: {
          uint16_t peakU16 = 0;
          float sumRmsSquared = 0.0f;
          uint8_t nbValidMeasurements = 0;
diff '--exclude=.git' -crB a/media/libmedia/Android.mk b/media/libmedia/Android.mk
*** a/media/libmedia/Android.mk	2018-09-22 10:19:51.661278036 +0200
--- b/media/libmedia/Android.mk	2018-09-22 10:11:05.440312600 +0200
***************
*** 45,51 ****
      IRemoteDisplay.cpp \
      IRemoteDisplayClient.cpp \
      IStreamSource.cpp \
-     MediaUtils.cpp \
      Metadata.cpp \
      mediarecorder.cpp \
      IMediaMetadataRetriever.cpp \
--- 45,50 ----
diff '--exclude=.git' -crB a/media/libmedia/IAudioFlinger.cpp b/media/libmedia/IAudioFlinger.cpp
*** a/media/libmedia/IAudioFlinger.cpp	2018-09-22 10:19:51.661278036 +0200
--- b/media/libmedia/IAudioFlinger.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 842,848 ****
              int sessionId = data.readInt32();
              int clientUid = data.readInt32();
              String8 name;
!             status_t status = NO_ERROR;
              sp<IAudioTrack> track;
              if ((haveSharedBuffer && (buffer == 0)) ||
                      ((buffer != 0) && (buffer->pointer() == NULL))) {
--- 842,848 ----
              int sessionId = data.readInt32();
              int clientUid = data.readInt32();
              String8 name;
!             status_t status;
              sp<IAudioTrack> track;
              if ((haveSharedBuffer && (buffer == 0)) ||
                      ((buffer != 0) && (buffer->pointer() == NULL))) {
***************
*** 891,897 ****
              track_flags_t flags = (track_flags_t) data.readInt32();
              pid_t tid = (pid_t) data.readInt32();
              int sessionId = data.readInt32();
!             status_t status = NO_ERROR;
              sp<IAudioRecord> record = openRecord(input,
                      sampleRate, format, channelMask, frameCount, &flags, tid, &sessionId, &status);
              LOG_ALWAYS_FATAL_IF((record != 0) != (status == NO_ERROR));
--- 891,897 ----
              track_flags_t flags = (track_flags_t) data.readInt32();
              pid_t tid = (pid_t) data.readInt32();
              int sessionId = data.readInt32();
!             status_t status;
              sp<IAudioRecord> record = openRecord(input,
                      sampleRate, format, channelMask, frameCount, &flags, tid, &sessionId, &status);
              LOG_ALWAYS_FATAL_IF((record != 0) != (status == NO_ERROR));
***************
*** 1109,1116 ****
          case GET_RENDER_POSITION: {
              CHECK_INTERFACE(IAudioFlinger, data, reply);
              audio_io_handle_t output = (audio_io_handle_t) data.readInt32();
!             size_t halFrames = 0;
!             size_t dspFrames = 0;
              status_t status = getRenderPosition(&halFrames, &dspFrames, output);
              reply->writeInt32(status);
              if (status == NO_ERROR) {
--- 1109,1116 ----
          case GET_RENDER_POSITION: {
              CHECK_INTERFACE(IAudioFlinger, data, reply);
              audio_io_handle_t output = (audio_io_handle_t) data.readInt32();
!             size_t halFrames;
!             size_t dspFrames;
              status_t status = getRenderPosition(&halFrames, &dspFrames, output);
              reply->writeInt32(status);
              if (status == NO_ERROR) {
***************
*** 1144,1150 ****
          } break;
          case QUERY_NUM_EFFECTS: {
              CHECK_INTERFACE(IAudioFlinger, data, reply);
!             uint32_t numEffects = 0;
              status_t status = queryNumberEffects(&numEffects);
              reply->writeInt32(status);
              if (status == NO_ERROR) {
--- 1144,1150 ----
          } break;
          case QUERY_NUM_EFFECTS: {
              CHECK_INTERFACE(IAudioFlinger, data, reply);
!             uint32_t numEffects;
              status_t status = queryNumberEffects(&numEffects);
              reply->writeInt32(status);
              if (status == NO_ERROR) {
***************
*** 1154,1160 ****
          }
          case QUERY_EFFECT: {
              CHECK_INTERFACE(IAudioFlinger, data, reply);
!             effect_descriptor_t desc = {};
              status_t status = queryEffect(data.readInt32(), &desc);
              reply->writeInt32(status);
              if (status == NO_ERROR) {
--- 1154,1160 ----
          }
          case QUERY_EFFECT: {
              CHECK_INTERFACE(IAudioFlinger, data, reply);
!             effect_descriptor_t desc;
              status_t status = queryEffect(data.readInt32(), &desc);
              reply->writeInt32(status);
              if (status == NO_ERROR) {
***************
*** 1166,1172 ****
              CHECK_INTERFACE(IAudioFlinger, data, reply);
              effect_uuid_t uuid;
              data.read(&uuid, sizeof(effect_uuid_t));
!             effect_descriptor_t desc = {};
              status_t status = getEffectDescriptor(&uuid, &desc);
              reply->writeInt32(status);
              if (status == NO_ERROR) {
--- 1166,1172 ----
              CHECK_INTERFACE(IAudioFlinger, data, reply);
              effect_uuid_t uuid;
              data.read(&uuid, sizeof(effect_uuid_t));
!             effect_descriptor_t desc;
              status_t status = getEffectDescriptor(&uuid, &desc);
              reply->writeInt32(status);
              if (status == NO_ERROR) {
***************
*** 1176,1192 ****
          }
          case CREATE_EFFECT: {
              CHECK_INTERFACE(IAudioFlinger, data, reply);
!             effect_descriptor_t desc = {};
!             if (data.read(&desc, sizeof(effect_descriptor_t)) != NO_ERROR) {
!                 ALOGE("b/23905951");
!             }
              sp<IEffectClient> client = interface_cast<IEffectClient>(data.readStrongBinder());
              int32_t priority = data.readInt32();
              audio_io_handle_t output = (audio_io_handle_t) data.readInt32();
              int sessionId = data.readInt32();
!             status_t status = NO_ERROR;
!             int id = 0;
!             int enabled = 0;
  
              sp<IEffect> effect = createEffect(&desc, client, priority, output, sessionId,
                      &status, &id, &enabled);
--- 1176,1190 ----
          }
          case CREATE_EFFECT: {
              CHECK_INTERFACE(IAudioFlinger, data, reply);
!             effect_descriptor_t desc;
!             data.read(&desc, sizeof(effect_descriptor_t));
              sp<IEffectClient> client = interface_cast<IEffectClient>(data.readStrongBinder());
              int32_t priority = data.readInt32();
              audio_io_handle_t output = (audio_io_handle_t) data.readInt32();
              int sessionId = data.readInt32();
!             status_t status;
!             int id;
!             int enabled;
  
              sp<IEffect> effect = createEffect(&desc, client, priority, output, sessionId,
                      &status, &id, &enabled);
diff '--exclude=.git' -crB a/media/libmedia/IAudioPolicyService.cpp b/media/libmedia/IAudioPolicyService.cpp
*** a/media/libmedia/IAudioPolicyService.cpp	2018-09-22 10:19:51.661278036 +0200
--- b/media/libmedia/IAudioPolicyService.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 567,573 ****
              audio_stream_type_t stream =
                      static_cast <audio_stream_type_t>(data.readInt32());
              audio_devices_t device = static_cast <audio_devices_t>(data.readInt32());
!             int index = 0;
              status_t status = getStreamVolumeIndex(stream, &index, device);
              reply->writeInt32(index);
              reply->writeInt32(static_cast <uint32_t>(status));
--- 567,573 ----
              audio_stream_type_t stream =
                      static_cast <audio_stream_type_t>(data.readInt32());
              audio_devices_t device = static_cast <audio_devices_t>(data.readInt32());
!             int index;
              status_t status = getStreamVolumeIndex(stream, &index, device);
              reply->writeInt32(index);
              reply->writeInt32(static_cast <uint32_t>(status));
diff '--exclude=.git' -crB a/media/libmedia/ICrypto.cpp b/media/libmedia/ICrypto.cpp
*** a/media/libmedia/ICrypto.cpp	2018-09-22 10:19:51.661278036 +0200
--- b/media/libmedia/ICrypto.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 236,242 ****
  
              size_t totalSize = data.readInt32();
              void *srcData = malloc(totalSize);
-             memset(srcData, 0, totalSize);
              data.read(srcData, totalSize);
  
              int32_t numSubSamples = data.readInt32();
--- 236,241 ----
***************
*** 248,293 ****
                      subSamples,
                      sizeof(CryptoPlugin::SubSample) * numSubSamples);
  
!             void *secureBufferId, *dstPtr;
              if (secure) {
!                 secureBufferId = (void *)data.readIntPtr();
              } else {
                  dstPtr = malloc(totalSize);
-                 memset(dstPtr, 0, totalSize);
              }
  
              AString errorDetailMsg;
!             ssize_t result;
! 
!             size_t sumSubsampleSizes = 0;
!             bool overflow = false;
!             for (int32_t i = 0; i < numSubSamples; ++i) {
!                 CryptoPlugin::SubSample &ss = subSamples[i];
!                 if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfEncryptedData) {
!                     sumSubsampleSizes += ss.mNumBytesOfEncryptedData;
!                 } else {
!                     overflow = true;
!                 }
!                 if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfClearData) {
!                     sumSubsampleSizes += ss.mNumBytesOfClearData;
!                 } else {
!                     overflow = true;
!                 }
!             }
! 
!             if (overflow || sumSubsampleSizes != totalSize) {
!                 result = -EINVAL;
!             } else {
!                 result = decrypt(
                      secure,
                      key,
                      iv,
                      mode,
                      srcData,
                      subSamples, numSubSamples,
!                     secure ? secureBufferId : dstPtr,
                      &errorDetailMsg);
-             }
  
              reply->writeInt32(result);
  
--- 247,269 ----
                      subSamples,
                      sizeof(CryptoPlugin::SubSample) * numSubSamples);
  
!             void *dstPtr;
              if (secure) {
!                 dstPtr = (void *)data.readIntPtr();
              } else {
                  dstPtr = malloc(totalSize);
              }
  
              AString errorDetailMsg;
!             ssize_t result = decrypt(
                      secure,
                      key,
                      iv,
                      mode,
                      srcData,
                      subSamples, numSubSamples,
!                     dstPtr,
                      &errorDetailMsg);
  
              reply->writeInt32(result);
  
diff '--exclude=.git' -crB a/media/libmedia/IEffect.cpp b/media/libmedia/IEffect.cpp
*** a/media/libmedia/IEffect.cpp	2018-09-22 10:19:51.661278036 +0200
--- b/media/libmedia/IEffect.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 85,99 ****
          data.writeInt32(size);
  
          status_t status = remote()->transact(COMMAND, data, &reply);
-         if (status == NO_ERROR) {
-             status = reply.readInt32();
-         }
          if (status != NO_ERROR) {
              if (pReplySize != NULL)
                  *pReplySize = 0;
              return status;
          }
  
          size = reply.readInt32();
          if (size != 0 && pReplyData != NULL && pReplySize != NULL) {
              reply.read(pReplyData, size);
--- 85,97 ----
          data.writeInt32(size);
  
          status_t status = remote()->transact(COMMAND, data, &reply);
          if (status != NO_ERROR) {
              if (pReplySize != NULL)
                  *pReplySize = 0;
              return status;
          }
  
+         status = reply.readInt32();
          size = reply.readInt32();
          if (size != 0 && pReplyData != NULL && pReplySize != NULL) {
              reply.read(pReplyData, size);
***************
*** 153,186 ****
              uint32_t cmdSize = data.readInt32();
              char *cmd = NULL;
              if (cmdSize) {
!                 cmd = (char *)calloc(cmdSize, 1);
!                 if (cmd == NULL) {
!                     reply->writeInt32(NO_MEMORY);
!                     return NO_ERROR;
!                 }
                  data.read(cmd, cmdSize);
              }
              uint32_t replySize = data.readInt32();
              uint32_t replySz = replySize;
              char *resp = NULL;
              if (replySize) {
!                 resp = (char *)calloc(replySize, 1);
!                 if (resp == NULL) {
!                     free(cmd);
!                     reply->writeInt32(NO_MEMORY);
!                     return NO_ERROR;
!                 }
              }
              status_t status = command(cmdCode, cmdSize, cmd, &replySz, resp);
              reply->writeInt32(status);
!             if (status == NO_ERROR) {
!                 if (replySz < replySize) {
!                     replySize = replySz;
!                 }
!                 reply->writeInt32(replySize);
!                 if (replySize) {
!                     reply->write(resp, replySize);
!                 }
              }
              if (cmd) {
                  free(cmd);
--- 151,173 ----
              uint32_t cmdSize = data.readInt32();
              char *cmd = NULL;
              if (cmdSize) {
!                 cmd = (char *)malloc(cmdSize);
                  data.read(cmd, cmdSize);
              }
              uint32_t replySize = data.readInt32();
              uint32_t replySz = replySize;
              char *resp = NULL;
              if (replySize) {
!                 resp = (char *)malloc(replySize);
              }
              status_t status = command(cmdCode, cmdSize, cmd, &replySz, resp);
              reply->writeInt32(status);
!             if (replySz < replySize) {
!                 replySize = replySz;
!             }
!             reply->writeInt32(replySize);
!             if (replySize) {
!                 reply->write(resp, replySize);
              }
              if (cmd) {
                  free(cmd);
diff '--exclude=.git' -crB a/media/libmedia/IHDCP.cpp b/media/libmedia/IHDCP.cpp
*** a/media/libmedia/IHDCP.cpp	2018-09-22 10:19:51.661278036 +0200
--- b/media/libmedia/IHDCP.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 241,259 ****
          case HDCP_ENCRYPT:
          {
              size_t size = data.readInt32();
-             size_t bufSize = 2 * size;
- 
-             // watch out for overflow
-             void *inData = NULL;
-             if (bufSize > size) {
-                 inData = malloc(bufSize);
-             }
- 
-             if (inData == NULL) {
-                 reply->writeInt32(ERROR_OUT_OF_RANGE);
-                 return OK;
-             }
  
              void *outData = (uint8_t *)inData + size;
  
              data.read(inData, size);
--- 241,248 ----
          case HDCP_ENCRYPT:
          {
              size_t size = data.readInt32();
  
+             void *inData = malloc(2 * size);
              void *outData = (uint8_t *)inData + size;
  
              data.read(inData, size);
***************
*** 306,324 ****
          case HDCP_DECRYPT:
          {
              size_t size = data.readInt32();
-             size_t bufSize = 2 * size;
- 
-             // watch out for overflow
-             void *inData = NULL;
-             if (bufSize > size) {
-                 inData = malloc(bufSize);
-             }
- 
-             if (inData == NULL) {
-                 reply->writeInt32(ERROR_OUT_OF_RANGE);
-                 return OK;
-             }
  
              void *outData = (uint8_t *)inData + size;
  
              data.read(inData, size);
--- 295,302 ----
          case HDCP_DECRYPT:
          {
              size_t size = data.readInt32();
  
+             void *inData = malloc(2 * size);
              void *outData = (uint8_t *)inData + size;
  
              data.read(inData, size);
diff '--exclude=.git' -crB a/media/libmedia/IMediaDeathNotifier.cpp b/media/libmedia/IMediaDeathNotifier.cpp
*** a/media/libmedia/IMediaDeathNotifier.cpp	2018-09-22 10:19:51.661278036 +0200
--- b/media/libmedia/IMediaDeathNotifier.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 31,37 ****
  SortedVector< wp<IMediaDeathNotifier> > IMediaDeathNotifier::sObitRecipients;
  
  // establish binder interface to MediaPlayerService
! /*static*/const sp<IMediaPlayerService>
  IMediaDeathNotifier::getMediaPlayerService()
  {
      ALOGV("getMediaPlayerService");
--- 31,37 ----
  SortedVector< wp<IMediaDeathNotifier> > IMediaDeathNotifier::sObitRecipients;
  
  // establish binder interface to MediaPlayerService
! /*static*/const sp<IMediaPlayerService>&
  IMediaDeathNotifier::getMediaPlayerService()
  {
      ALOGV("getMediaPlayerService");
diff '--exclude=.git' -crB a/media/libmedia/IMediaPlayer.cpp b/media/libmedia/IMediaPlayer.cpp
*** a/media/libmedia/IMediaPlayer.cpp	2018-09-22 10:19:51.661278036 +0200
--- b/media/libmedia/IMediaPlayer.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 441,447 ****
          } break;
          case GET_CURRENT_POSITION: {
              CHECK_INTERFACE(IMediaPlayer, data, reply);
!             int msec = 0;
              status_t ret = getCurrentPosition(&msec);
              reply->writeInt32(msec);
              reply->writeInt32(ret);
--- 441,447 ----
          } break;
          case GET_CURRENT_POSITION: {
              CHECK_INTERFACE(IMediaPlayer, data, reply);
!             int msec;
              status_t ret = getCurrentPosition(&msec);
              reply->writeInt32(msec);
              reply->writeInt32(ret);
***************
*** 449,455 ****
          } break;
          case GET_DURATION: {
              CHECK_INTERFACE(IMediaPlayer, data, reply);
!             int msec = 0;
              status_t ret = getDuration(&msec);
              reply->writeInt32(msec);
              reply->writeInt32(ret);
--- 449,455 ----
          } break;
          case GET_DURATION: {
              CHECK_INTERFACE(IMediaPlayer, data, reply);
!             int msec;
              status_t ret = getDuration(&msec);
              reply->writeInt32(msec);
              reply->writeInt32(ret);
***************
*** 528,534 ****
              CHECK_INTERFACE(IMediaPlayer, data, reply);
  
              struct sockaddr_in endpoint;
-             memset(&endpoint, 0, sizeof(endpoint));
              int amt = data.readInt32();
              if (amt == sizeof(endpoint)) {
                  data.read(&endpoint, sizeof(struct sockaddr_in));
--- 528,533 ----
***************
*** 543,549 ****
              CHECK_INTERFACE(IMediaPlayer, data, reply);
  
              struct sockaddr_in endpoint;
-             memset(&endpoint, 0, sizeof(endpoint));
              status_t res = getRetransmitEndpoint(&endpoint);
  
              reply->writeInt32(res);
--- 542,547 ----
diff '--exclude=.git' -crB a/media/libmedia/IOMX.cpp b/media/libmedia/IOMX.cpp
*** a/media/libmedia/IOMX.cpp	2018-09-22 10:19:51.661278036 +0200
--- b/media/libmedia/IOMX.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 18,25 ****
  #define LOG_TAG "IOMX"
  #include <utils/Log.h>
  
- #include <sys/mman.h>
- 
  #include <binder/IMemory.h>
  #include <binder/Parcel.h>
  #include <media/IOMX.h>
--- 18,23 ----
***************
*** 251,257 ****
  
      virtual status_t useBuffer(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer, OMX_BOOL /* crossProcess */) {
          Parcel data, reply;
          data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
          data.writeIntPtr((intptr_t)node);
--- 249,255 ----
  
      virtual status_t useBuffer(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer) {
          Parcel data, reply;
          data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
          data.writeIntPtr((intptr_t)node);
***************
*** 501,507 ****
  
      virtual status_t allocateBufferWithBackup(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer, OMX_BOOL /* crossProcess */) {
          Parcel data, reply;
          data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
          data.writeIntPtr((intptr_t)node);
--- 499,505 ----
  
      virtual status_t allocateBufferWithBackup(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer) {
          Parcel data, reply;
          data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
          data.writeIntPtr((intptr_t)node);
***************
*** 706,783 ****
  
              size_t size = data.readInt32();
  
!             status_t err = NOT_ENOUGH_DATA;
!             void *params = NULL;
!             size_t pageSize = 0;
!             size_t allocSize = 0;
!             // this only applies to a subset of devices, and was obsoleted in M
!             bool mightBeThumbnailMode = (code == SET_CONFIG && size == sizeof(OMX_BOOL));
!             if (!mightBeThumbnailMode && (code != SET_INTERNAL_OPTION && size < 8)) {
!                 // we expect the structure to contain at least the size and
!                 // version, 8 bytes total
!                 ALOGE("b/27207275 (%zu)", size);
!                 android_errorWriteLog(0x534e4554, "27207275");
!             } else {
!                 err = NO_MEMORY;
!                 pageSize = (size_t) sysconf(_SC_PAGE_SIZE);
!                 if (size > SIZE_MAX - (pageSize * 2)) {
!                     ALOGE("requested param size too big");
!                 } else {
!                     allocSize = (size + pageSize * 2) & ~(pageSize - 1);
!                     params = mmap(NULL, allocSize, PROT_READ | PROT_WRITE,
!                             MAP_PRIVATE | MAP_ANONYMOUS, -1 /* fd */, 0 /* offset */);
!                 }
!                 if (params != MAP_FAILED) {
!                     err = data.read(params, size);
!                     if (err != OK) {
!                         android_errorWriteLog(0x534e4554, "26914474");
!                     } else {
!                         err = NOT_ENOUGH_DATA;
!                         OMX_U32 declaredSize = *(OMX_U32*)params;
!                         if (!mightBeThumbnailMode &&
!                                 code != SET_INTERNAL_OPTION && declaredSize > size) {
!                             // the buffer says it's bigger than it actually is
!                             ALOGE("b/27207275 (%u/%zu)", declaredSize, size);
!                             android_errorWriteLog(0x534e4554, "27207275");
!                         } else {
!                             // mark the last page as inaccessible, to avoid exploitation
!                             // of codecs that access past the end of the allocation because
!                             // they didn't check the size
!                             if (mprotect((char*)params + allocSize - pageSize, pageSize,
!                                     PROT_NONE) != 0) {
!                                 ALOGE("mprotect failed: %s", strerror(errno));
!                             } else {
!                                 switch (code) {
!                                     case GET_PARAMETER:
!                                         err = getParameter(node, index, params, size);
!                                         break;
!                                     case SET_PARAMETER:
!                                         err = setParameter(node, index, params, size);
!                                         break;
!                                     case GET_CONFIG:
!                                         err = getConfig(node, index, params, size);
!                                         break;
!                                     case SET_CONFIG:
!                                         err = setConfig(node, index, params, size);
!                                         break;
!                                     case SET_INTERNAL_OPTION:
!                                     {
!                                         InternalOptionType type =
!                                             (InternalOptionType)data.readInt32();
! 
!                                         err = setInternalOption(node, index, type, params, size);
!                                         break;
!                                     }
! 
!                                     default:
!                                         TRESPASS();
!                                 }
!                             }
!                         }
!                     }
!                 } else {
!                     ALOGE("couldn't map: %s", strerror(errno));
                  }
              }
  
              reply->writeInt32(err);
--- 704,737 ----
  
              size_t size = data.readInt32();
  
!             void *params = malloc(size);
!             data.read(params, size);
! 
!             status_t err;
!             switch (code) {
!                 case GET_PARAMETER:
!                     err = getParameter(node, index, params, size);
!                     break;
!                 case SET_PARAMETER:
!                     err = setParameter(node, index, params, size);
!                     break;
!                 case GET_CONFIG:
!                     err = getConfig(node, index, params, size);
!                     break;
!                 case SET_CONFIG:
!                     err = setConfig(node, index, params, size);
!                     break;
!                 case SET_INTERNAL_OPTION:
!                 {
!                     InternalOptionType type =
!                         (InternalOptionType)data.readInt32();
! 
!                     err = setInternalOption(node, index, type, params, size);
!                     break;
                  }
+ 
+                 default:
+                     TRESPASS();
              }
  
              reply->writeInt32(err);
***************
*** 786,794 ****
                  reply->write(params, size);
              }
  
!             if (params) {
!                 munmap(params, allocSize);
!             }
              params = NULL;
  
              return NO_ERROR;
--- 740,746 ----
                  reply->write(params, size);
              }
  
!             free(params);
              params = NULL;
  
              return NO_ERROR;
***************
*** 847,854 ****
                  interface_cast<IMemory>(data.readStrongBinder());
  
              buffer_id buffer;
!             status_t err = useBuffer(
!                     node, port_index, params, &buffer, OMX_TRUE /* crossProcess */);
              reply->writeInt32(err);
  
              if (err == OK) {
--- 799,805 ----
                  interface_cast<IMemory>(data.readStrongBinder());
  
              buffer_id buffer;
!             status_t err = useBuffer(node, port_index, params, &buffer);
              reply->writeInt32(err);
  
              if (err == OK) {
***************
*** 936,945 ****
              OMX_U32 port_index = data.readInt32();
              OMX_BOOL enable = (OMX_BOOL)data.readInt32();
  
!             status_t err =
!                 // only control output metadata via Binder
!                 port_index != 1 /* kOutputPortIndex */ ? BAD_VALUE :
!                 storeMetaDataInBuffers(node, port_index, enable);
              reply->writeInt32(err);
  
              return NO_ERROR;
--- 887,893 ----
              OMX_U32 port_index = data.readInt32();
              OMX_BOOL enable = (OMX_BOOL)data.readInt32();
  
!             status_t err = storeMetaDataInBuffers(node, port_index, enable);
              reply->writeInt32(err);
  
              return NO_ERROR;
***************
*** 1058,1069 ****
  
              node_id node = (void*)data.readIntPtr();
              OMX_U32 port_index = data.readInt32();
-             if (!isSecure(node) || port_index != 0 /* kPortIndexInput */) {
-                 ALOGE("b/24310423");
-                 reply->writeInt32(INVALID_OPERATION);
-                 return NO_ERROR;
-             }
- 
              size_t size = data.readInt32();
  
              buffer_id buffer;
--- 1006,1011 ----
***************
*** 1091,1097 ****
  
              buffer_id buffer;
              status_t err = allocateBufferWithBackup(
!                     node, port_index, params, &buffer, OMX_TRUE /* crossProcess */);
  
              reply->writeInt32(err);
  
--- 1033,1039 ----
  
              buffer_id buffer;
              status_t err = allocateBufferWithBackup(
!                     node, port_index, params, &buffer);
  
              reply->writeInt32(err);
  
diff '--exclude=.git' -crB a/media/libmedia/mediametadataretriever.cpp b/media/libmedia/mediametadataretriever.cpp
*** a/media/libmedia/mediametadataretriever.cpp	2018-09-22 10:19:51.665278044 +0200
--- b/media/libmedia/mediametadataretriever.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 32,38 ****
  sp<IMediaPlayerService> MediaMetadataRetriever::sService;
  sp<MediaMetadataRetriever::DeathNotifier> MediaMetadataRetriever::sDeathNotifier;
  
! const sp<IMediaPlayerService> MediaMetadataRetriever::getService()
  {
      Mutex::Autolock lock(sServiceLock);
      if (sService == 0) {
--- 32,38 ----
  sp<IMediaPlayerService> MediaMetadataRetriever::sService;
  sp<MediaMetadataRetriever::DeathNotifier> MediaMetadataRetriever::sDeathNotifier;
  
! const sp<IMediaPlayerService>& MediaMetadataRetriever::getService()
  {
      Mutex::Autolock lock(sServiceLock);
      if (sService == 0) {
***************
*** 59,65 ****
  MediaMetadataRetriever::MediaMetadataRetriever()
  {
      ALOGV("constructor");
!     const sp<IMediaPlayerService> service(getService());
      if (service == 0) {
          ALOGE("failed to obtain MediaMetadataRetrieverService");
          return;
--- 59,65 ----
  MediaMetadataRetriever::MediaMetadataRetriever()
  {
      ALOGV("constructor");
!     const sp<IMediaPlayerService>& service(getService());
      if (service == 0) {
          ALOGE("failed to obtain MediaMetadataRetrieverService");
          return;
diff '--exclude=.git' -crB a/media/libmedia/mediaplayer.cpp b/media/libmedia/mediaplayer.cpp
*** a/media/libmedia/mediaplayer.cpp	2018-09-22 10:19:51.665278044 +0200
--- b/media/libmedia/mediaplayer.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 141,147 ****
      ALOGV("setDataSource(%s)", url);
      status_t err = BAD_VALUE;
      if (url != NULL) {
!         const sp<IMediaPlayerService> service(getMediaPlayerService());
          if (service != 0) {
              sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
              if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
--- 141,147 ----
      ALOGV("setDataSource(%s)", url);
      status_t err = BAD_VALUE;
      if (url != NULL) {
!         const sp<IMediaPlayerService>& service(getMediaPlayerService());
          if (service != 0) {
              sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
              if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
***************
*** 158,164 ****
  {
      ALOGV("setDataSource(%d, %lld, %lld)", fd, offset, length);
      status_t err = UNKNOWN_ERROR;
!     const sp<IMediaPlayerService> service(getMediaPlayerService());
      if (service != 0) {
          sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
          if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
--- 158,164 ----
  {
      ALOGV("setDataSource(%d, %lld, %lld)", fd, offset, length);
      status_t err = UNKNOWN_ERROR;
!     const sp<IMediaPlayerService>& service(getMediaPlayerService());
      if (service != 0) {
          sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
          if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
***************
*** 174,180 ****
  {
      ALOGV("setDataSource");
      status_t err = UNKNOWN_ERROR;
!     const sp<IMediaPlayerService> service(getMediaPlayerService());
      if (service != 0) {
          sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
          if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
--- 174,180 ----
  {
      ALOGV("setDataSource");
      status_t err = UNKNOWN_ERROR;
!     const sp<IMediaPlayerService>& service(getMediaPlayerService());
      if (service != 0) {
          sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
          if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
***************
*** 794,800 ****
  {
      ALOGV("decode(%s)", url);
      status_t status;
!     const sp<IMediaPlayerService> service = getMediaPlayerService();
      if (service != 0) {
          status = service->decode(url, pSampleRate, pNumChannels, pFormat, heap, pSize);
      } else {
--- 794,800 ----
  {
      ALOGV("decode(%s)", url);
      status_t status;
!     const sp<IMediaPlayerService>& service = getMediaPlayerService();
      if (service != 0) {
          status = service->decode(url, pSampleRate, pNumChannels, pFormat, heap, pSize);
      } else {
***************
*** 818,824 ****
  {
      ALOGV("decode(%d, %lld, %lld)", fd, offset, length);
      status_t status;
!     const sp<IMediaPlayerService> service = getMediaPlayerService();
      if (service != 0) {
          status = service->decode(fd, offset, length, pSampleRate,
                                   pNumChannels, pFormat, heap, pSize);
--- 818,824 ----
  {
      ALOGV("decode(%d, %lld, %lld)", fd, offset, length);
      status_t status;
!     const sp<IMediaPlayerService>& service = getMediaPlayerService();
      if (service != 0) {
          status = service->decode(fd, offset, length, pSampleRate,
                                   pNumChannels, pFormat, heap, pSize);
***************
*** 846,852 ****
  
  status_t MediaPlayer::updateProxyConfig(
          const char *host, int32_t port, const char *exclusionList) {
!     const sp<IMediaPlayerService> service = getMediaPlayerService();
  
      if (service != NULL) {
          return service->updateProxyConfig(host, port, exclusionList);
--- 846,852 ----
  
  status_t MediaPlayer::updateProxyConfig(
          const char *host, int32_t port, const char *exclusionList) {
!     const sp<IMediaPlayerService>& service = getMediaPlayerService();
  
      if (service != NULL) {
          return service->updateProxyConfig(host, port, exclusionList);
diff '--exclude=.git' -crB a/media/libmedia/mediarecorder.cpp b/media/libmedia/mediarecorder.cpp
*** a/media/libmedia/mediarecorder.cpp	2018-09-22 10:19:51.665278044 +0200
--- b/media/libmedia/mediarecorder.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 642,648 ****
  {
      ALOGV("constructor");
  
!     const sp<IMediaPlayerService> service(getMediaPlayerService());
      if (service != NULL) {
          mMediaRecorder = service->createMediaRecorder();
      }
--- 642,648 ----
  {
      ALOGV("constructor");
  
!     const sp<IMediaPlayerService>& service(getMediaPlayerService());
      if (service != NULL) {
          mMediaRecorder = service->createMediaRecorder();
      }
Nur in a/media/libmedia: MediaUtils.cpp.
Nur in a/media/libmedia: MediaUtils.h.
diff '--exclude=.git' -crB a/media/libmedia/SoundPool.cpp b/media/libmedia/SoundPool.cpp
*** a/media/libmedia/SoundPool.cpp	2018-09-22 10:19:51.665278044 +0200
--- b/media/libmedia/SoundPool.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 179,195 ****
      return mDecodeThread != NULL;
  }
  
- sp<Sample> SoundPool::findSample(int sampleID)
- {
-     Mutex::Autolock lock(&mLock);
-     return findSample_l(sampleID);
- }
- 
- sp<Sample> SoundPool::findSample_l(int sampleID)
- {
-     return mSamples.valueFor(sampleID);
- }
- 
  SoundChannel* SoundPool::findChannel(int channelID)
  {
      for (int i = 0; i < mMaxChannels; ++i) {
--- 179,184 ----
***************
*** 213,254 ****
  int SoundPool::load(const char* path, int priority)
  {
      ALOGV("load: path=%s, priority=%d", path, priority);
!     int sampleID;
!     {
!         Mutex::Autolock lock(&mLock);
!         sampleID = ++mNextSampleID;
!         sp<Sample> sample = new Sample(sampleID, path);
!         mSamples.add(sampleID, sample);
!         sample->startLoad();
!     }
!     // mDecodeThread->loadSample() must be called outside of mLock.
!     // mDecodeThread->loadSample() may block on mDecodeThread message queue space;
!     // the message queue emptying may block on SoundPool::findSample().
!     //
!     // It theoretically possible that sample loads might decode out-of-order.
!     mDecodeThread->loadSample(sampleID);
!     return sampleID;
  }
  
  int SoundPool::load(int fd, int64_t offset, int64_t length, int priority)
  {
      ALOGV("load: fd=%d, offset=%lld, length=%lld, priority=%d",
              fd, offset, length, priority);
!     int sampleID;
!     {
!         Mutex::Autolock lock(&mLock);
!         sampleID = ++mNextSampleID;
!         sp<Sample> sample = new Sample(sampleID, fd, offset, length);
!         mSamples.add(sampleID, sample);
!         sample->startLoad();
!     }
!     // mDecodeThread->loadSample() must be called outside of mLock.
!     // mDecodeThread->loadSample() may block on mDecodeThread message queue space;
!     // the message queue emptying may block on SoundPool::findSample().
!     //
!     // It theoretically possible that sample loads might decode out-of-order.
!     mDecodeThread->loadSample(sampleID);
!     return sampleID;
  }
  
  bool SoundPool::unload(int sampleID)
--- 202,230 ----
  int SoundPool::load(const char* path, int priority)
  {
      ALOGV("load: path=%s, priority=%d", path, priority);
!     Mutex::Autolock lock(&mLock);
!     sp<Sample> sample = new Sample(++mNextSampleID, path);
!     mSamples.add(sample->sampleID(), sample);
!     doLoad(sample);
!     return sample->sampleID();
  }
  
  int SoundPool::load(int fd, int64_t offset, int64_t length, int priority)
  {
      ALOGV("load: fd=%d, offset=%lld, length=%lld, priority=%d",
              fd, offset, length, priority);
!     Mutex::Autolock lock(&mLock);
!     sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length);
!     mSamples.add(sample->sampleID(), sample);
!     doLoad(sample);
!     return sample->sampleID();
! }
! 
! void SoundPool::doLoad(sp<Sample>& sample)
! {
!     ALOGV("doLoad: loading sample sampleID=%d", sample->sampleID());
!     sample->startLoad();
!     mDecodeThread->loadSample(sample->sampleID());
  }
  
  bool SoundPool::unload(int sampleID)
***************
*** 263,268 ****
--- 239,245 ----
  {
      ALOGV("play sampleID=%d, leftVolume=%f, rightVolume=%f, priority=%d, loop=%d, rate=%f",
              sampleID, leftVolume, rightVolume, priority, loop, rate);
+     sp<Sample> sample;
      SoundChannel* channel;
      int channelID;
  
***************
*** 272,278 ****
          return 0;
      }
      // is sample ready?
!     sp<Sample> sample(findSample_l(sampleID));
      if ((sample == 0) || (sample->state() != Sample::READY)) {
          ALOGW("  sample %d not READY", sampleID);
          return 0;
--- 249,255 ----
          return 0;
      }
      // is sample ready?
!     sample = findSample(sampleID);
      if ((sample == 0) || (sample->state() != Sample::READY)) {
          ALOGW("  sample %d not READY", sampleID);
          return 0;
diff '--exclude=.git' -crB a/media/libmediaplayerservice/MediaPlayerService.cpp b/media/libmediaplayerservice/MediaPlayerService.cpp
*** a/media/libmediaplayerservice/MediaPlayerService.cpp	2018-09-22 10:19:51.665278044 +0200
--- b/media/libmediaplayerservice/MediaPlayerService.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 503,514 ****
      mClients.remove(client);
  }
  
- bool MediaPlayerService::hasClient(wp<Client> client)
- {
-     Mutex::Autolock lock(mLock);
-     return mClients.indexOf(client) != NAME_NOT_FOUND;
- }
- 
  MediaPlayerService::Client::Client(
          const sp<MediaPlayerService>& service, pid_t pid,
          int32_t connId, const sp<IMediaPlayerClient>& client,
--- 503,508 ----
***************
*** 938,947 ****
      ALOGD("gapless:setNextPlayer");
      Mutex::Autolock l(mLock);
      sp<Client> c = static_cast<Client*>(player.get());
-     if (c != NULL && !mService->hasClient(c)) {
-       return BAD_VALUE;
-     }
- 
      mNextClient = c;
  
      if (c != NULL) {
--- 932,937 ----
diff '--exclude=.git' -crB a/media/libmediaplayerservice/MediaPlayerService.h b/media/libmediaplayerservice/MediaPlayerService.h
*** a/media/libmediaplayerservice/MediaPlayerService.h	2018-09-22 10:19:51.665278044 +0200
--- b/media/libmediaplayerservice/MediaPlayerService.h	2018-09-22 10:11:05.440312600 +0200
***************
*** 292,298 ****
              const char *host, int32_t port, const char *exclusionList);
  
              void                removeClient(wp<Client> client);
-             bool                hasClient(wp<Client> client);
  
      // For battery usage tracking purpose
      struct BatteryUsageInfo {
--- 292,297 ----
diff '--exclude=.git' -crB a/media/libmediaplayerservice/MetadataRetrieverClient.cpp b/media/libmediaplayerservice/MetadataRetrieverClient.cpp
*** a/media/libmediaplayerservice/MetadataRetrieverClient.cpp	2018-09-22 10:19:51.665278044 +0200
--- b/media/libmediaplayerservice/MetadataRetrieverClient.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 212,218 ****
      ALOGV("rotation: %d", frameCopy->mRotationAngle);
      frameCopy->mData = (uint8_t *)frameCopy + sizeof(VideoFrame);
      memcpy(frameCopy->mData, frame->mData, frame->mSize);
-     frameCopy->mData = 0;
      delete frame;  // Fix memory leakage
      return mThumbnail;
  }
--- 212,217 ----
diff '--exclude=.git' -crB a/media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp
*** a/media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp	2018-09-22 10:19:51.669278051 +0200
--- b/media/libmediaplayerservice/nuplayer/NuPlayerStreamListener.cpp	2018-09-22 10:11:05.440312600 +0200
***************
*** 144,160 ****
          copy = size;
      }
  
-     if (entry->mIndex >= mBuffers.size()) {
-         return ERROR_MALFORMED;
-     }
- 
-     sp<IMemory> mem = mBuffers.editItemAt(entry->mIndex);
-     if (mem == NULL || mem->size() < copy || mem->size() - copy < entry->mOffset) {
-         return ERROR_MALFORMED;
-     }
- 
      memcpy(data,
!            (const uint8_t *)mem->pointer()
              + entry->mOffset,
             copy);
  
--- 144,151 ----
          copy = size;
      }
  
      memcpy(data,
!            (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
              + entry->mOffset,
             copy);
  
diff '--exclude=.git' -crB a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
*** a/media/libstagefright/ACodec.cpp	2018-09-22 10:19:51.669278051 +0200
--- b/media/libstagefright/ACodec.cpp	2018-09-22 10:11:05.444312607 +0200
***************
*** 383,389 ****
        mSentFormat(false),
        mIsEncoder(false),
        mUseMetadataOnEncoderOutput(false),
-       mFatalError(false),
        mShutdownInProgress(false),
        mIsConfiguredForAdaptivePlayback(false),
        mEncoderDelay(0),
--- 383,388 ----
***************
*** 526,534 ****
  
              for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
                  sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
!                 if (mem == NULL || mem->pointer() == NULL) {
!                     return NO_MEMORY;
!                 }
  
                  BufferInfo info;
                  info.mStatus = BufferInfo::OWNED_BY_US;
--- 525,531 ----
  
              for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
                  sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
!                 CHECK(mem.get() != NULL);
  
                  BufferInfo info;
                  info.mStatus = BufferInfo::OWNED_BY_US;
***************
*** 866,874 ****
  
          sp<IMemory> mem = mDealer[kPortIndexOutput]->allocate(
                  sizeof(struct VideoDecoderOutputMetaData));
!         if (mem == NULL || mem->pointer() == NULL) {
!             return NO_MEMORY;
!         }
          info.mData = new ABuffer(mem->pointer(), mem->size());
  
          // we use useBuffer for metadata regardless of quirks
--- 863,869 ----
  
          sp<IMemory> mem = mDealer[kPortIndexOutput]->allocate(
                  sizeof(struct VideoDecoderOutputMetaData));
!         CHECK(mem.get() != NULL);
          info.mData = new ABuffer(mem->pointer(), mem->size());
  
          // we use useBuffer for metadata regardless of quirks
***************
*** 944,955 ****
      ANativeWindowBuffer *buf;
      int fenceFd = -1;
      CHECK(mNativeWindow.get() != NULL);
- 
-     if (mFatalError) {
-         ALOGW("not dequeuing from native window due to fatal error");
-         return NULL;
-     }
- 
      if (native_window_dequeue_buffer_and_wait(mNativeWindow.get(), &buf) != 0) {
          ALOGE("dequeueBuffer failed.");
          return NULL;
--- 939,944 ----
***************
*** 993,1000 ****
          VideoDecoderOutputMetaData *metaData =
              reinterpret_cast<VideoDecoderOutputMetaData *>(
                      oldest->mData->base());
!         // metaData is only readable if codec is in the same process
!         //CHECK_EQ(metaData->eType, kMetadataBufferTypeGrallocSource);
  
          ALOGV("replaced oldest buffer #%u with age %u (%p/%p stored in %p)",
                  oldest - &mBuffers[kPortIndexOutput][0],
--- 982,988 ----
          VideoDecoderOutputMetaData *metaData =
              reinterpret_cast<VideoDecoderOutputMetaData *>(
                      oldest->mData->base());
!         CHECK_EQ(metaData->eType, kMetadataBufferTypeGrallocSource);
  
          ALOGV("replaced oldest buffer #%u with age %u (%p/%p stored in %p)",
                  oldest - &mBuffers[kPortIndexOutput][0],
***************
*** 2938,2946 ****
      sp<AMessage> notify = mNotify->dup();
      notify->setInt32("what", ACodec::kWhatError);
      notify->setInt32("omx-error", error);
- 
-     mFatalError = true;
- 
      notify->setInt32("err", internalError);
      notify->post();
  }
--- 2926,2931 ----
diff '--exclude=.git' -crB a/media/libstagefright/AudioSource.cpp b/media/libstagefright/AudioSource.cpp
*** a/media/libstagefright/AudioSource.cpp	2018-09-22 10:19:51.669278051 +0200
--- b/media/libstagefright/AudioSource.cpp	2018-09-22 10:11:05.444312607 +0200
***************
*** 64,74 ****
      : mStarted(false),
  #endif
        mSampleRate(sampleRate),
-       mTrackMaxAmplitude(false),
-       mStartTimeUs(0),
-       mMaxAmplitude(0),
        mPrevSampleTimeUs(0),
-       mInitialReadTimeUs(0),
        mRecPaused(false),
        mNumFramesReceived(0),
  #ifdef QCOM_HARDWARE
--- 64,70 ----
diff '--exclude=.git' -crB a/media/libstagefright/AwesomePlayer.cpp b/media/libstagefright/AwesomePlayer.cpp
*** a/media/libstagefright/AwesomePlayer.cpp	2018-09-22 10:19:51.669278051 +0200
--- b/media/libstagefright/AwesomePlayer.cpp	2018-09-22 10:11:05.444312607 +0200
***************
*** 2862,2872 ****
              // The widevine extractor does its own caching.
  
  #if 0
!             mCachedSource = NuCachedSource2::Create(
                      new ThrottledSource(
                          mConnectingDataSource, 50 * 1024 /* bytes/sec */));
  #else
!             mCachedSource = NuCachedSource2::Create(
                      mConnectingDataSource,
                      cacheConfig.isEmpty() ? NULL : cacheConfig.string(),
                      disconnectAtHighwatermark);
--- 2862,2872 ----
              // The widevine extractor does its own caching.
  
  #if 0
!             mCachedSource = new NuCachedSource2(
                      new ThrottledSource(
                          mConnectingDataSource, 50 * 1024 /* bytes/sec */));
  #else
!             mCachedSource = new NuCachedSource2(
                      mConnectingDataSource,
                      cacheConfig.isEmpty() ? NULL : cacheConfig.string(),
                      disconnectAtHighwatermark);
diff '--exclude=.git' -crB a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
*** a/media/libstagefright/CameraSource.cpp	2018-09-22 10:19:51.669278051 +0200
--- b/media/libstagefright/CameraSource.cpp	2018-09-22 10:11:05.444312607 +0200
***************
*** 25,34 ****
  #include <media/stagefright/MediaDefs.h>
  #include <media/stagefright/MediaErrors.h>
  #include <media/stagefright/MetaData.h>
- #include <media/hardware/HardwareAPI.h>
  #include <camera/Camera.h>
  #include <camera/CameraParameters.h>
- #include <camera/ICameraRecordingProxy.h>
  #include <gui/Surface.h>
  #include <utils/String8.h>
  #include <cutils/properties.h>
--- 25,32 ----
***************
*** 805,812 ****
      List<sp<IMemory> >::iterator it;
      while (!mFramesReceived.empty()) {
          it = mFramesReceived.begin();
-         // b/28466701
-         adjustOutgoingANWBuffer(it->get());
          releaseRecordingFrame(*it);
          mFramesReceived.erase(it);
          ++mNumFramesDropped;
--- 803,808 ----
***************
*** 827,835 ****
      for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin();
           it != mFramesBeingEncoded.end(); ++it) {
          if ((*it)->pointer() ==  buffer->data()) {
-             // b/28466701
-             adjustOutgoingANWBuffer(it->get());
- 
              releaseOneRecordingFrame((*it));
              mFramesBeingEncoded.erase(it);
              ++mNumFramesEncoded;
--- 823,828 ----
***************
*** 946,955 ****
      ++mNumFramesReceived;
  
      CHECK(data != NULL && data->size() > 0);
- 
-     // b/28466701
-     adjustIncomingANWBuffer(data.get());
- 
      mFramesReceived.push_back(data);
      int64_t timeUs = mStartTimeUs + (timestampUs - mFirstFrameTimeUs);
      mFrameTimes.push_back(timeUs);
--- 939,944 ----
***************
*** 963,988 ****
      return mIsMetaDataStoredInVideoBuffers;
  }
  
- void CameraSource::adjustIncomingANWBuffer(IMemory* data) {
-     uint8_t *payload =
-             reinterpret_cast<uint8_t*>(data->pointer());
-     if (*(uint32_t*)payload == kMetadataBufferTypeGrallocSource) {
-         buffer_handle_t* pBuffer = (buffer_handle_t*)(payload + 4);
-         *pBuffer = (buffer_handle_t)((uint8_t*)(*pBuffer) +
-                 ICameraRecordingProxy::getCommonBaseAddress());
-     }
- }
- 
- void CameraSource::adjustOutgoingANWBuffer(IMemory* data) {
-     uint8_t *payload =
-             reinterpret_cast<uint8_t*>(data->pointer());
-     if (*(uint32_t*)payload == kMetadataBufferTypeGrallocSource) {
-         buffer_handle_t* pBuffer = (buffer_handle_t*)(payload + 4);
-         *pBuffer = (buffer_handle_t)((uint8_t*)(*pBuffer) -
-                 ICameraRecordingProxy::getCommonBaseAddress());
-     }
- }
- 
  CameraSource::ProxyListener::ProxyListener(const sp<CameraSource>& source) {
      mSource = source;
  }
--- 952,957 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/aacdec/SoftAAC2.cpp b/media/libstagefright/codecs/aacdec/SoftAAC2.cpp
*** a/media/libstagefright/codecs/aacdec/SoftAAC2.cpp	2018-09-22 10:19:51.677278066 +0200
--- b/media/libstagefright/codecs/aacdec/SoftAAC2.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 162,171 ****
              OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =
                  (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;
  
-             if (!isValidOMXParam(aacParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (aacParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 162,167 ----
***************
*** 201,210 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 197,202 ----
***************
*** 245,254 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (strncmp((const char *)roleParams->cRole,
                          "audio_decoder.aac",
                          OMX_MAX_STRINGNAME_SIZE - 1)) {
--- 237,242 ----
***************
*** 263,272 ****
              const OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =
                  (const OMX_AUDIO_PARAM_AACPROFILETYPE *)params;
  
-             if (!isValidOMXParam(aacParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (aacParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 251,256 ----
***************
*** 288,297 ****
              const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 272,277 ----
***************
*** 465,479 ****
                  } else {
                      adtsHeaderSize = (protectionAbsent ? 7 : 9);
  
!                     if (aac_frame_length < adtsHeaderSize) {
!                         signalError = true;
!                     } else {
!                         inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;
!                         inBufferLength[0] = aac_frame_length - adtsHeaderSize;
! 
!                         inHeader->nOffset += adtsHeaderSize;
!                         inHeader->nFilledLen -= adtsHeaderSize;
!                     }
                  }
              }
  
--- 445,455 ----
                  } else {
                      adtsHeaderSize = (protectionAbsent ? 7 : 9);
  
!                     inBuffer[0] = (UCHAR *)adtsHeader + adtsHeaderSize;
!                     inBufferLength[0] = aac_frame_length - adtsHeaderSize;
! 
!                     inHeader->nOffset += adtsHeaderSize;
!                     inHeader->nFilledLen -= adtsHeaderSize;
                  }
              }
  
diff '--exclude=.git' -crB a/media/libstagefright/codecs/aacenc/SoftAACEncoder2.cpp b/media/libstagefright/codecs/aacenc/SoftAACEncoder2.cpp
*** a/media/libstagefright/codecs/aacenc/SoftAACEncoder2.cpp	2018-09-22 10:19:51.681278073 +0200
--- b/media/libstagefright/codecs/aacenc/SoftAACEncoder2.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 120,129 ****
              OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
                  (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;
  
-             if (!isValidOMXParam(formatParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (formatParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
--- 120,125 ----
***************
*** 144,153 ****
              OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =
                  (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;
  
-             if (!isValidOMXParam(aacParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (aacParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 140,145 ----
***************
*** 172,181 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 164,169 ----
***************
*** 207,216 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (strncmp((const char *)roleParams->cRole,
                          "audio_encoder.aac",
                          OMX_MAX_STRINGNAME_SIZE - 1)) {
--- 195,200 ----
***************
*** 225,234 ****
              const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
                  (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;
  
-             if (!isValidOMXParam(formatParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (formatParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
--- 209,214 ----
***************
*** 252,261 ****
              OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =
                  (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;
  
-             if (!isValidOMXParam(aacParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (aacParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 232,237 ----
***************
*** 279,288 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 255,260 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/aacenc/SoftAACEncoder.cpp b/media/libstagefright/codecs/aacenc/SoftAACEncoder.cpp
*** a/media/libstagefright/codecs/aacenc/SoftAACEncoder.cpp	2018-09-22 10:19:51.677278066 +0200
--- b/media/libstagefright/codecs/aacenc/SoftAACEncoder.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 154,163 ****
              OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
                  (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;
  
-             if (!isValidOMXParam(formatParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (formatParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
--- 154,159 ----
***************
*** 178,187 ****
              OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =
                  (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;
  
-             if (!isValidOMXParam(aacParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (aacParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 174,179 ----
***************
*** 206,215 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 198,203 ----
***************
*** 241,250 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (strncmp((const char *)roleParams->cRole,
                          "audio_encoder.aac",
                          OMX_MAX_STRINGNAME_SIZE - 1)) {
--- 229,234 ----
***************
*** 259,268 ****
              const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
                  (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;
  
-             if (!isValidOMXParam(formatParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (formatParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
--- 243,248 ----
***************
*** 286,295 ****
              OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =
                  (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;
  
-             if (!isValidOMXParam(aacParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (aacParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 266,271 ----
***************
*** 310,319 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 286,291 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp b/media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp
*** a/media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp	2018-09-22 10:19:51.697278103 +0200
--- b/media/libstagefright/codecs/amrnb/dec/SoftAMR.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 148,157 ****
              OMX_AUDIO_PARAM_AMRTYPE *amrParams =
                  (OMX_AUDIO_PARAM_AMRTYPE *)params;
  
-             if (!isValidOMXParam(amrParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (amrParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 148,153 ----
***************
*** 178,187 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 174,179 ----
***************
*** 215,224 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (mMode == MODE_NARROW) {
                  if (strncmp((const char *)roleParams->cRole,
                              "audio_decoder.amrnb",
--- 207,212 ----
***************
*** 241,250 ****
              const OMX_AUDIO_PARAM_AMRTYPE *aacParams =
                  (const OMX_AUDIO_PARAM_AMRTYPE *)params;
  
-             if (!isValidOMXParam(aacParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (aacParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 229,234 ----
***************
*** 257,266 ****
              const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 241,246 ----
***************
*** 323,335 ****
              return;
          }
  
-         if (inHeader->nFilledLen == 0) {
-             inInfo->mOwnedByUs = false;
-             inQueue.erase(inQueue.begin());
-             notifyEmptyBufferDone(inHeader);
-             continue;
-         }
- 
          if (inHeader->nOffset == 0) {
              mAnchorTimeUs = inHeader->nTimeStamp;
              mNumSamplesOutput = 0;
--- 303,308 ----
***************
*** 339,364 ****
          int32_t numBytesRead;
  
          if (mMode == MODE_NARROW) {
-             if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) {
-                 ALOGE("b/27662364: NB expected output buffer %zu bytes vs %u",
-                        kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen);
-                 android_errorWriteLog(0x534e4554, "27662364");
-                 notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
-                 mSignalledError = true;
-                 return;
-             }
- 
-             int16 mode = ((inputPtr[0] >> 3) & 0x0f);
-             // for WMF since MIME_IETF is used when calling AMRDecode.
-             size_t frameSize = WmfDecBytesPerFrame[mode] + 1;
- 
-             if (inHeader->nFilledLen < frameSize) {
-                 ALOGE("b/27662364: expected %zu bytes vs %u", frameSize, inHeader->nFilledLen);
-                 notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
-                 mSignalledError = true;
-                 return;
-             }
- 
              numBytesRead =
                  AMRDecode(mState,
                    (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f),
--- 312,317 ----
***************
*** 386,400 ****
                  return;
              }
          } else {
-             if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) {
-                 ALOGE("b/27662364: WB expected output buffer %zu bytes vs %u",
-                        kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen);
-                 android_errorWriteLog(0x534e4554, "27662364");
-                 notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL);
-                 mSignalledError = true;
-                 return;
-             }
- 
              int16 mode = ((inputPtr[0] >> 3) & 0x0f);
  
              if (mode >= 10 && mode <= 13) {
--- 339,344 ----
***************
*** 409,416 ****
  
              size_t frameSize = getFrameSize(mode);
              if (inHeader->nFilledLen < frameSize) {
!                 ALOGE("b/27662364: expected %zu bytes vs %u", frameSize, inHeader->nFilledLen);
!                 notify(OMX_EventError, OMX_ErrorStreamCorrupt, 0, NULL);
                  mSignalledError = true;
                  return;
              }
--- 353,362 ----
  
              size_t frameSize = getFrameSize(mode);
              if (inHeader->nFilledLen < frameSize) {
!                 ALOGE("Filled length vs frameSize %d vs %d. Corrupt clip?",
!                    inHeader->nFilledLen, frameSize);
! 
!                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
                  mSignalledError = true;
                  return;
              }
diff '--exclude=.git' -crB a/media/libstagefright/codecs/amrnb/dec/src/amrdecode.h b/media/libstagefright/codecs/amrnb/dec/src/amrdecode.h
*** a/media/libstagefright/codecs/amrnb/dec/src/amrdecode.h	2018-09-22 10:19:51.697278103 +0200
--- b/media/libstagefright/codecs/amrnb/dec/src/amrdecode.h	2018-09-22 10:11:05.448312615 +0200
***************
*** 104,109 ****
--- 104,110 ----
  ; INCLUDES
  ----------------------------------------------------------------------------*/
  #include    "typedef.h"
+ #include    "mode.h"
  #include    "frame_type_3gpp.h"
  
  /*--------------------------------------------------------------------------*/
diff '--exclude=.git' -crB a/media/libstagefright/codecs/amrnb/dec/src/gsmamr_dec.h b/media/libstagefright/codecs/amrnb/dec/src/gsmamr_dec.h
*** a/media/libstagefright/codecs/amrnb/dec/src/gsmamr_dec.h	2018-09-22 10:19:51.701278109 +0200
--- b/media/libstagefright/codecs/amrnb/dec/src/gsmamr_dec.h	2018-09-22 10:11:05.448312615 +0200
***************
*** 87,93 ****
  
  #include "gsm_amr_typedefs.h"
  #include "frame_type_3gpp.h"
- #include "amrdecode.h"
  
  /*--------------------------------------------------------------------------*/
  #ifdef __cplusplus
--- 87,92 ----
***************
*** 137,142 ****
--- 136,154 ----
                           Word8 *id);
  
      /*
+      * AMRDecode steps into the part of the library that decodes the raw data
+      * speech bits for the decoding process. It returns the address offset of
+      * the next frame to be decoded.
+      */
+     Word16 AMRDecode(
+         void                      *state_data,
+         enum Frame_Type_3GPP      frame_type,
+         UWord8                    *speech_bits_ptr,
+         Word16                    *raw_pcm_buffer,
+         Word16                    input_format
+     );
+ 
+     /*
       * This function resets the state memory used by the GSM AMR decoder. This
       * function returns zero. It will return negative one if there is an error.
       */
diff '--exclude=.git' -crB a/media/libstagefright/codecs/amrnb/enc/SoftAMRNBEncoder.cpp b/media/libstagefright/codecs/amrnb/enc/SoftAMRNBEncoder.cpp
*** a/media/libstagefright/codecs/amrnb/enc/SoftAMRNBEncoder.cpp	2018-09-22 10:19:51.701278109 +0200
--- b/media/libstagefright/codecs/amrnb/enc/SoftAMRNBEncoder.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 120,129 ****
              OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
                  (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;
  
-             if (!isValidOMXParam(formatParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (formatParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
--- 120,125 ----
***************
*** 144,153 ****
              OMX_AUDIO_PARAM_AMRTYPE *amrParams =
                  (OMX_AUDIO_PARAM_AMRTYPE *)params;
  
-             if (!isValidOMXParam(amrParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (amrParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 140,145 ----
***************
*** 166,175 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 158,163 ----
***************
*** 200,209 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (strncmp((const char *)roleParams->cRole,
                          "audio_encoder.amrnb",
                          OMX_MAX_STRINGNAME_SIZE - 1)) {
--- 188,193 ----
***************
*** 218,227 ****
              const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
                  (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;
  
-             if (!isValidOMXParam(formatParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (formatParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
--- 202,207 ----
***************
*** 245,254 ****
              OMX_AUDIO_PARAM_AMRTYPE *amrParams =
                  (OMX_AUDIO_PARAM_AMRTYPE *)params;
  
-             if (!isValidOMXParam(amrParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (amrParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 225,230 ----
***************
*** 276,285 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 252,257 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/amrwbenc/SoftAMRWBEncoder.cpp b/media/libstagefright/codecs/amrwbenc/SoftAMRWBEncoder.cpp
*** a/media/libstagefright/codecs/amrwbenc/SoftAMRWBEncoder.cpp	2018-09-22 10:19:51.713278132 +0200
--- b/media/libstagefright/codecs/amrwbenc/SoftAMRWBEncoder.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 155,164 ****
              OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
                  (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;
  
-             if (!isValidOMXParam(formatParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (formatParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
--- 155,160 ----
***************
*** 179,188 ****
              OMX_AUDIO_PARAM_AMRTYPE *amrParams =
                  (OMX_AUDIO_PARAM_AMRTYPE *)params;
  
-             if (!isValidOMXParam(amrParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (amrParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 175,180 ----
***************
*** 204,213 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 196,201 ----
***************
*** 238,247 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (strncmp((const char *)roleParams->cRole,
                          "audio_encoder.amrwb",
                          OMX_MAX_STRINGNAME_SIZE - 1)) {
--- 226,231 ----
***************
*** 256,265 ****
              const OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =
                  (const OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;
  
-             if (!isValidOMXParam(formatParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (formatParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
--- 240,245 ----
***************
*** 283,292 ****
              OMX_AUDIO_PARAM_AMRTYPE *amrParams =
                  (OMX_AUDIO_PARAM_AMRTYPE *)params;
  
-             if (!isValidOMXParam(amrParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (amrParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 263,268 ----
***************
*** 323,332 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 299,304 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/amrwbenc/src/util.c b/media/libstagefright/codecs/amrwbenc/src/util.c
*** a/media/libstagefright/codecs/amrwbenc/src/util.c	2018-09-22 10:19:51.717278139 +0200
--- b/media/libstagefright/codecs/amrwbenc/src/util.c	2018-09-22 10:11:05.448312615 +0200
***************
*** 35,44 ****
  	     )
  {
  	Word32 num = (Word32)L;
! 	while (num > 0) {
  		*x++ = 0;
!                 --num;
! 	}
  }
  
  
--- 35,43 ----
  	     )
  {
  	Word32 num = (Word32)L;
! 	do{
  		*x++ = 0;
! 	}while(--num !=0);
  }
  
  
***************
*** 55,76 ****
  	 )
  {
  	Word32	temp1,temp2,num;
-         if (L <= 0) {
-                 return;
-         }
  	if(L&1)
  	{
  		temp1 = *x++;
  		*y++ = temp1;
  	}
  	num = (Word32)(L>>1);
! 	while (num > 0) {
! 		temp1 = *x++;
! 		temp2 = *x++;
  		*y++ = temp1;
  		*y++ = temp2;
!                 --num;
! 	}
  }
  
  
--- 54,73 ----
  	 )
  {
  	Word32	temp1,temp2,num;
  	if(L&1)
  	{
  		temp1 = *x++;
  		*y++ = temp1;
  	}
  	num = (Word32)(L>>1);
! 	temp1 = *x++;
! 	temp2 = *x++;
! 	do{
  		*y++ = temp1;
  		*y++ = temp2;
! 		temp1 = *x++;
! 		temp2 = *x++;
! 	}while(--num!=0);
  }
  
  
diff '--exclude=.git' -crB a/media/libstagefright/codecs/avc/enc/SoftAVCEncoder.cpp b/media/libstagefright/codecs/avc/enc/SoftAVCEncoder.cpp
*** a/media/libstagefright/codecs/avc/enc/SoftAVCEncoder.cpp	2018-09-22 10:19:51.721278146 +0200
--- b/media/libstagefright/codecs/avc/enc/SoftAVCEncoder.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 34,43 ****
  
  #include "SoftAVCEncoder.h"
  
- #ifndef INT32_MAX
- #define INT32_MAX   2147483647
- #endif
- 
  namespace android {
  
  template<class T>
--- 34,39 ----
***************
*** 261,270 ****
      if (mVideoColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {
          // Color conversion is needed.
          CHECK(mInputFrameData == NULL);
-         if (((uint64_t)mVideoWidth * mVideoHeight) > ((uint64_t)INT32_MAX / 3)) {
-             ALOGE("Buffer size is too big.");
-             return OMX_ErrorUndefined;
-         }
          mInputFrameData =
              (uint8_t *) malloc((mVideoWidth * mVideoHeight * 3 ) >> 1);
          CHECK(mInputFrameData != NULL);
--- 257,262 ----
***************
*** 286,295 ****
      int32_t nMacroBlocks = ((((mVideoWidth + 15) >> 4) << 4) *
              (((mVideoHeight + 15) >> 4) << 4)) >> 8;
      CHECK(mSliceGroup == NULL);
-     if ((size_t)nMacroBlocks > SIZE_MAX / sizeof(uint32_t)) {
-         ALOGE("requested memory size is too big.");
-         return OMX_ErrorUndefined;
-     }
      mSliceGroup = (uint32_t *) malloc(sizeof(uint32_t) * nMacroBlocks);
      CHECK(mSliceGroup != NULL);
      for (int ii = 0, idx = 0; ii < nMacroBlocks; ++ii) {
--- 278,283 ----
***************
*** 450,459 ****
              OMX_VIDEO_PARAM_BITRATETYPE *bitRate =
                  (OMX_VIDEO_PARAM_BITRATETYPE *) params;
  
-             if (!isValidOMXParam(bitRate)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (bitRate->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 438,443 ----
***************
*** 498,507 ****
              OMX_VIDEO_PARAM_AVCTYPE *avcParams =
                  (OMX_VIDEO_PARAM_AVCTYPE *)params;
  
-             if (!isValidOMXParam(avcParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (avcParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 482,487 ----
***************
*** 572,581 ****
              OMX_VIDEO_PARAM_BITRATETYPE *bitRate =
                  (OMX_VIDEO_PARAM_BITRATETYPE *) params;
  
-             if (!isValidOMXParam(bitRate)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (bitRate->nPortIndex != 1 ||
                  bitRate->eControlRate != OMX_Video_ControlRateVariable) {
                  return OMX_ErrorUndefined;
--- 552,557 ----
***************
*** 677,686 ****
              OMX_VIDEO_PARAM_AVCTYPE *avcType =
                  (OMX_VIDEO_PARAM_AVCTYPE *)params;
  
-             if (!isValidOMXParam(avcType)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (avcType->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 653,658 ----
***************
*** 726,735 ****
              if (mStoreMetaDataInBuffers) {
                  mVideoColorFormat == OMX_COLOR_FormatYUV420SemiPlanar;
                  if (mInputFrameData == NULL) {
-                     if (((uint64_t)mVideoWidth * mVideoHeight) > ((uint64_t)INT32_MAX / 3)) {
-                         ALOGE("Buffer size is too big.");
-                         return OMX_ErrorUndefined;
-                     }
                      mInputFrameData =
                              (uint8_t *) malloc((mVideoWidth * mVideoHeight * 3 ) >> 1);
                  }
--- 698,703 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/flac/enc/SoftFlacEncoder.cpp b/media/libstagefright/codecs/flac/enc/SoftFlacEncoder.cpp
*** a/media/libstagefright/codecs/flac/enc/SoftFlacEncoder.cpp	2018-09-22 10:19:51.725278154 +0200
--- b/media/libstagefright/codecs/flac/enc/SoftFlacEncoder.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 153,162 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
--- 153,158 ----
***************
*** 178,188 ****
          case OMX_IndexParamAudioFlac:
          {
              OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;
- 
-             if (!isValidOMXParam(flacParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              flacParams->nCompressionLevel = mCompressionLevel;
              flacParams->nChannels = mNumChannels;
              flacParams->nSampleRate = mSampleRate;
--- 174,179 ----
***************
*** 202,211 ****
              ALOGV("SoftFlacEncoder::internalSetParameter(OMX_IndexParamAudioPcm)");
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams = (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {
                  ALOGE("SoftFlacEncoder::internalSetParameter() Error #1");
                  return OMX_ErrorUndefined;
--- 193,198 ----
***************
*** 228,237 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (strncmp((const char *)roleParams->cRole,
                      "audio_encoder.flac",
                      OMX_MAX_STRINGNAME_SIZE - 1)) {
--- 215,220 ----
***************
*** 247,257 ****
          {
              // used only for setting the compression level
              OMX_AUDIO_PARAM_FLACTYPE *flacParams = (OMX_AUDIO_PARAM_FLACTYPE *)params;
- 
-             if (!isValidOMXParam(flacParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              mCompressionLevel = flacParams->nCompressionLevel; // range clamping done inside encoder
              return OMX_ErrorNone;
          }
--- 230,235 ----
***************
*** 261,270 ****
              OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                  (OMX_PARAM_PORTDEFINITIONTYPE *)params;
  
-             if (!isValidOMXParam(defParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (defParams->nPortIndex == 0) {
                  if (defParams->nBufferSize > kMaxInputBufferSize) {
                      ALOGE("Input buffer size must be at most %zu bytes",
--- 239,244 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/g711/dec/SoftG711.cpp b/media/libstagefright/codecs/g711/dec/SoftG711.cpp
*** a/media/libstagefright/codecs/g711/dec/SoftG711.cpp	2018-09-22 10:19:51.725278154 +0200
--- b/media/libstagefright/codecs/g711/dec/SoftG711.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 109,118 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
--- 109,114 ----
***************
*** 144,153 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 140,145 ----
***************
*** 168,177 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (mIsMLaw) {
                  if (strncmp((const char *)roleParams->cRole,
                              "audio_decoder.g711mlaw",
--- 160,165 ----
***************
*** 230,244 ****
              mSignalledError = true;
          }
  
-         if (inHeader->nFilledLen * sizeof(int16_t) > outHeader->nAllocLen) {
-             ALOGE("output buffer too small (%d).", outHeader->nAllocLen);
-             android_errorWriteLog(0x534e4554, "27793163");
- 
-             notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
-             mSignalledError = true;
-             return;
-         }
- 
          const uint8_t *inputptr = inHeader->pBuffer + inHeader->nOffset;
  
          if (mIsMLaw) {
--- 218,223 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/gsm/dec/SoftGSM.cpp b/media/libstagefright/codecs/gsm/dec/SoftGSM.cpp
*** a/media/libstagefright/codecs/gsm/dec/SoftGSM.cpp	2018-09-22 10:19:51.725278154 +0200
--- b/media/libstagefright/codecs/gsm/dec/SoftGSM.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 107,116 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
--- 107,112 ----
***************
*** 142,151 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 138,143 ----
***************
*** 166,175 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (strncmp((const char *)roleParams->cRole,
                          "audio_decoder.gsm",
                          OMX_MAX_STRINGNAME_SIZE - 1)) {
--- 158,163 ----
***************
*** 225,238 ****
              mSignalledError = true;
          }
  
-         if (outHeader->nAllocLen < (inHeader->nFilledLen / 65) * 320) {
-             ALOGE("output buffer is not large enough (%d).", outHeader->nAllocLen);
-             android_errorWriteLog(0x534e4554, "27793367");
-             notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
-             mSignalledError = true;
-             return;
-         }
- 
          uint8_t *inputptr = inHeader->pBuffer + inHeader->nOffset;
  
          int n = mSignalledError ? 0 : DecodeGSM(mGsm,
--- 213,218 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp b/media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp
*** a/media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp	2018-09-22 10:19:51.725278154 +0200
--- b/media/libstagefright/codecs/m4v_h263/dec/SoftMPEG4.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 27,36 ****
  
  #include "mp4dec_api.h"
  
- #ifndef UINT32_MAX
- #define UINT32_MAX (4294967295U)
- #endif
- 
  namespace android {
  
  static const CodecProfileLevel kM4VProfileLevels[] = {
--- 27,32 ----
***************
*** 194,210 ****
              PortInfo *port = editPortInfo(1);
              OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;
  
-             OMX_U32 yFrameSize = sizeof(uint8) * mHandle->size;
-             if ((outHeader->nAllocLen < yFrameSize) ||
-                     (outHeader->nAllocLen - yFrameSize < yFrameSize / 2)) {
-                 ALOGE("Too small output buffer for reference frame: %lu bytes",
-                         (unsigned long)outHeader->nAllocLen);
-                 android_errorWriteLog(0x534e4554, "30033990");
-                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
-                 mSignalledError = true;
-                 return;
-             }
              PVSetReferenceYUV(mHandle, outHeader->pBuffer);
              mFramesConfigured = true;
          }
  
--- 190,197 ----
              PortInfo *port = editPortInfo(1);
              OMX_BUFFERHEADERTYPE *outHeader = port->mBuffers.editItemAt(1).mHeader;
  
              PVSetReferenceYUV(mHandle, outHeader->pBuffer);
+ 
              mFramesConfigured = true;
          }
  
***************
*** 222,244 ****
          int32_t bufferSize = inHeader->nFilledLen;
          int32_t tmp = bufferSize;
  
-         OMX_U32 frameSize;
-         OMX_U64 yFrameSize = (OMX_U64)mWidth * (OMX_U64)mHeight;
-         if (yFrameSize > ((OMX_U64)UINT32_MAX / 3) * 2) {
-             ALOGE("Frame size too large");
-             notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
-             mSignalledError = true;
-             return;
-         }
-         frameSize = (OMX_U32)(yFrameSize + (yFrameSize / 2));
- 
-         if (outHeader->nAllocLen < frameSize) {
-             android_errorWriteLog(0x534e4554, "27833616");
-             ALOGE("Insufficient output buffer size");
-             notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
-             mSignalledError = true;
-             return;
-         }
          // The PV decoder is lying to us, sometimes it'll claim to only have
          // consumed a subset of the buffer when it clearly consumed all of it.
          // ignore whatever it says...
--- 209,214 ----
***************
*** 280,286 ****
          ++mInputBufferCount;
  
          outHeader->nOffset = 0;
!         outHeader->nFilledLen = frameSize;
  
          List<BufferInfo *>::iterator it = outQueue.begin();
          while ((*it)->mHeader != outHeader) {
--- 250,256 ----
          ++mInputBufferCount;
  
          outHeader->nOffset = 0;
!         outHeader->nFilledLen = (mWidth * mHeight * 3) / 2;
  
          List<BufferInfo *>::iterator it = outQueue.begin();
          while ((*it)->mHeader != outHeader) {
diff '--exclude=.git' -crB a/media/libstagefright/codecs/m4v_h263/dec/src/conceal.cpp b/media/libstagefright/codecs/m4v_h263/dec/src/conceal.cpp
*** a/media/libstagefright/codecs/m4v_h263/dec/src/conceal.cpp	2018-09-22 10:19:51.725278154 +0200
--- b/media/libstagefright/codecs/m4v_h263/dec/src/conceal.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 19,25 ****
  #include "vlc_decode.h"
  #include "bitstream.h"
  #include "scaling.h"
- #include "log/log.h"
  
  /* ====================================================================== /
  Function : ConcealTexture_I()
--- 19,24 ----
***************
*** 138,147 ****
  ****************************************************************************/
  void CopyVopMB(Vop *curr, uint8 *prevFrame, int mbnum, int width_Y, int height)
  {
-     if (curr == NULL || prevFrame == NULL) {
-         ALOGE("b/24630158");
-         return;
-     }
      int width_C = width_Y >> 1;
      int row = MB_SIZE;
      uint8              *y1, *y2, *u1, *u2, *v1, *v2;
--- 137,142 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/m4v_h263/dec/src/pvdec_api.cpp b/media/libstagefright/codecs/m4v_h263/dec/src/pvdec_api.cpp
*** a/media/libstagefright/codecs/m4v_h263/dec/src/pvdec_api.cpp	2018-09-22 10:19:51.729278161 +0200
--- b/media/libstagefright/codecs/m4v_h263/dec/src/pvdec_api.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 19,32 ****
  #include "vlc_decode.h"
  #include "bitstream.h"
  
- #ifndef INT32_MAX
- #define INT32_MAX 0x7fffffff
- #endif
- 
- #ifndef SIZE_MAX
- #define SIZE_MAX ((size_t) -1)
- #endif
- 
  #define OSCL_DISABLE_WARNING_CONDITIONAL_IS_CONSTANT
  
  #ifdef DEC_INTERNAL_MEMORY_OPT
--- 19,24 ----
***************
*** 103,113 ****
  #ifdef DEC_INTERNAL_MEMORY_OPT
          video->vol = (Vol **) IMEM_VOL;
  #else
-         if ((size_t)nLayers > SIZE_MAX / sizeof(Vol *)) {
-             status = PV_FALSE;
-             goto fail;
-         }
- 
          video->vol = (Vol **) oscl_malloc(nLayers * sizeof(Vol *));
  #endif
          if (video->vol == NULL) status = PV_FALSE;
--- 95,100 ----
***************
*** 141,151 ****
          else oscl_memset(video->prevVop, 0, sizeof(Vop));
          video->memoryUsage += (sizeof(Vop) * 2);
  
-         if ((size_t)nLayers > SIZE_MAX / sizeof(Vop *)) {
-             status = PV_FALSE;
-             goto fail;
-         }
- 
          video->vopHeader = (Vop **) oscl_malloc(sizeof(Vop *) * nLayers);
  #endif
          if (video->vopHeader == NULL) status = PV_FALSE;
--- 128,133 ----
***************
*** 292,298 ****
          status = PV_FALSE;
      }
  
- fail:
      if (status == PV_FALSE) PVCleanUpVideoDecoder(decCtrl);
  
      return status;
--- 274,279 ----
***************
*** 319,328 ****
              video->nMBPerRow * video->nMBPerCol;
      }
  
-     if (((uint64_t)video->width * video->height) > (uint64_t)INT32_MAX / sizeof(PIXEL)) {
-         return PV_FALSE;
-     }
- 
      size = (int32)sizeof(PIXEL) * video->width * video->height;
  #ifdef PV_MEMORY_POOL
      decCtrl->size = size;
--- 300,305 ----
***************
*** 338,346 ****
      video->prevVop->uChan = video->prevVop->yChan + size;
      video->prevVop->vChan = video->prevVop->uChan + (size >> 2);
  #else
-     if (size > INT32_MAX / 3) {
-         return PV_FALSE;
-     }
      video->currVop->yChan = (PIXEL *) oscl_malloc(size * 3 / 2); /* Allocate memory for all VOP OKA 3/2/1*/
      if (video->currVop->yChan == NULL) status = PV_FALSE;
  
--- 315,320 ----
***************
*** 368,377 ****
          {
              oscl_memset(video->prevEnhcVop, 0, sizeof(Vop));
  #ifndef PV_MEMORY_POOL
-             if (size > INT32_MAX / 3) {
-                 return PV_FALSE;
-             }
- 
              video->prevEnhcVop->yChan = (PIXEL *) oscl_malloc(size * 3 / 2); /* Allocate memory for all VOP OKA 3/2/1*/
              if (video->prevEnhcVop->yChan == NULL) status = PV_FALSE;
              video->prevEnhcVop->uChan = video->prevEnhcVop->yChan + size;
--- 342,347 ----
***************
*** 428,444 ****
      if (video->acPredFlag == NULL) status = PV_FALSE;
      video->memoryUsage += (nTotalMB);
  
-     if ((size_t)nTotalMB > SIZE_MAX / sizeof(typeDCStore)) {
-         return PV_FALSE;
-     }
      video->predDC = (typeDCStore *) oscl_malloc(nTotalMB * sizeof(typeDCStore));
      if (video->predDC == NULL) status = PV_FALSE;
      video->memoryUsage += (nTotalMB * sizeof(typeDCStore));
  
-     if (nMBPerRow > INT32_MAX - 1
-             || (size_t)(nMBPerRow + 1) > SIZE_MAX / sizeof(typeDCACStore)) {
-         return PV_FALSE;
-     }
      video->predDCAC_col = (typeDCACStore *) oscl_malloc((nMBPerRow + 1) * sizeof(typeDCACStore));
      if (video->predDCAC_col == NULL) status = PV_FALSE;
      video->memoryUsage += ((nMBPerRow + 1) * sizeof(typeDCACStore));
--- 398,407 ----
***************
*** 454,463 ****
      video->headerInfo.CBP = (uint8 *) oscl_malloc(nTotalMB);
      if (video->headerInfo.CBP == NULL) status = PV_FALSE;
      video->memoryUsage += nTotalMB;
- 
-     if ((size_t)nTotalMB > SIZE_MAX / sizeof(int16)) {
-         return PV_FALSE;
-     }
      video->QPMB = (int16 *) oscl_malloc(nTotalMB * sizeof(int16));
      if (video->QPMB == NULL) status = PV_FALSE;
      video->memoryUsage += (nTotalMB * sizeof(int));
--- 417,422 ----
***************
*** 475,483 ****
          video->memoryUsage += sizeof(MacroBlock);
      }
      /* Allocating motion vector space */
-     if ((size_t)nTotalMB > SIZE_MAX / (sizeof(MOT) * 4)) {
-         return PV_FALSE;
-     }
      video->motX = (MOT *) oscl_malloc(sizeof(MOT) * 4 * nTotalMB);
      if (video->motX == NULL) status = PV_FALSE;
      video->motY = (MOT *) oscl_malloc(sizeof(MOT) * 4 * nTotalMB);
--- 434,439 ----
***************
*** 511,519 ****
      }
  
  #else
-     if (nTotalMB > INT32_MAX / 6) {
-         return PV_FALSE;
-     }
      video->pstprcTypCur = (uint8 *) oscl_malloc(nTotalMB * 6);
      video->memoryUsage += (nTotalMB * 6);
      if (video->pstprcTypCur == NULL)
--- 467,472 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/m4v_h263/enc/SoftMPEG4Encoder.cpp b/media/libstagefright/codecs/m4v_h263/enc/SoftMPEG4Encoder.cpp
*** a/media/libstagefright/codecs/m4v_h263/enc/SoftMPEG4Encoder.cpp	2018-09-22 10:19:51.729278161 +0200
--- b/media/libstagefright/codecs/m4v_h263/enc/SoftMPEG4Encoder.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 33,42 ****
  
  #include "SoftMPEG4Encoder.h"
  
- #ifndef INT32_MAX
- #define INT32_MAX   2147483647
- #endif
- 
  namespace android {
  
  template<class T>
--- 33,38 ----
***************
*** 129,138 ****
          ALOGE("Failed to get default encoding parameters");
          return OMX_ErrorUndefined;
      }
-     if (mVideoFrameRate == 0) {
-         ALOGE("Framerate should not be 0");
-         return OMX_ErrorUndefined;
-     }
      mEncParams->encMode = mEncodeMode;
      mEncParams->encWidth[0] = mVideoWidth;
      mEncParams->encHeight[0] = mVideoHeight;
--- 125,130 ----
***************
*** 157,168 ****
  
      if (mVideoColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {
          // Color conversion is needed.
!         free(mInputFrameData);
!         mInputFrameData = NULL;
!         if (((uint64_t)mVideoWidth * mVideoHeight) > ((uint64_t)INT32_MAX / 3)) {
!             ALOGE("b/25812794, Buffer size is too big.");
!             return OMX_ErrorBadParameter;
!         }
          mInputFrameData =
              (uint8_t *) malloc((mVideoWidth * mVideoHeight * 3 ) >> 1);
          CHECK(mInputFrameData != NULL);
--- 149,155 ----
  
      if (mVideoColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {
          // Color conversion is needed.
!         CHECK(mInputFrameData == NULL);
          mInputFrameData =
              (uint8_t *) malloc((mVideoWidth * mVideoHeight * 3 ) >> 1);
          CHECK(mInputFrameData != NULL);
***************
*** 321,330 ****
              OMX_VIDEO_PARAM_BITRATETYPE *bitRate =
                  (OMX_VIDEO_PARAM_BITRATETYPE *) params;
  
-             if (!isValidOMXParam(bitRate)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (bitRate->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 308,313 ----
***************
*** 373,382 ****
              OMX_VIDEO_PARAM_H263TYPE *h263type =
                  (OMX_VIDEO_PARAM_H263TYPE *)params;
  
-             if (!isValidOMXParam(h263type)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (h263type->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 356,361 ----
***************
*** 398,407 ****
              OMX_VIDEO_PARAM_MPEG4TYPE *mpeg4type =
                  (OMX_VIDEO_PARAM_MPEG4TYPE *)params;
  
-             if (!isValidOMXParam(mpeg4type)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (mpeg4type->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 377,382 ----
***************
*** 465,474 ****
              OMX_VIDEO_PARAM_BITRATETYPE *bitRate =
                  (OMX_VIDEO_PARAM_BITRATETYPE *) params;
  
-             if (!isValidOMXParam(bitRate)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (bitRate->nPortIndex != 1 ||
                  bitRate->eControlRate != OMX_Video_ControlRateVariable) {
                  return OMX_ErrorUndefined;
--- 440,445 ----
***************
*** 577,586 ****
              OMX_VIDEO_PARAM_H263TYPE *h263type =
                  (OMX_VIDEO_PARAM_H263TYPE *)params;
  
-             if (!isValidOMXParam(h263type)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (h263type->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 548,553 ----
***************
*** 603,612 ****
              OMX_VIDEO_PARAM_MPEG4TYPE *mpeg4type =
                  (OMX_VIDEO_PARAM_MPEG4TYPE *)params;
  
-             if (!isValidOMXParam(mpeg4type)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (mpeg4type->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 570,575 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/m4v_h263/enc/src/mp4enc_api.cpp b/media/libstagefright/codecs/m4v_h263/enc/src/mp4enc_api.cpp
*** a/media/libstagefright/codecs/m4v_h263/enc/src/mp4enc_api.cpp	2018-09-22 10:19:51.733278169 +0200
--- b/media/libstagefright/codecs/m4v_h263/enc/src/mp4enc_api.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 21,33 ****
  #include "rate_control.h"
  #include "m4venc_oscl.h"
  
- #ifndef INT32_MAX
- #define INT32_MAX 0x7fffffff
- #endif
- 
- #ifndef SIZE_MAX
- #define SIZE_MAX ((size_t) -1)
- #endif
  
  /* Inverse normal zigzag */
  const static Int zigzag_i[NCOEFF_BLOCK] =
--- 21,26 ----
***************
*** 617,626 ****
              max = temp_w * temp_h;
              max_width = ((temp_w + 15) >> 4) << 4;
              max_height = ((temp_h + 15) >> 4) << 4;
-             if (((uint64_t)max_width * max_height) > (uint64_t)INT32_MAX
-                     || temp_w > INT32_MAX - 15 || temp_h > INT32_MAX - 15) {
-                 goto CLEAN_UP;
-             }
              nTotalMB = ((max_width * max_height) >> 8);
          }
  
--- 610,615 ----
***************
*** 665,673 ****
  
      /* Allocating motion vector space and interpolation memory*/
  
-     if ((size_t)nTotalMB > SIZE_MAX / sizeof(MOT *)) {
-         goto CLEAN_UP;
-     }
      video->mot = (MOT **)M4VENC_MALLOC(sizeof(MOT *) * nTotalMB);
      if (video->mot == NULL) goto CLEAN_UP;
  
--- 654,659 ----
***************
*** 690,706 ****
      /*    so that compilers can generate faster code to indexing the     */
      /*    data inside (by using << instead of *).         04/14/2000. */
      /* 5/29/01, use  decoder lib ACDC prediction memory scheme.  */
-     if ((size_t)nTotalMB > SIZE_MAX / sizeof(typeDCStore)) {
-         goto CLEAN_UP;
-     }
      video->predDC = (typeDCStore *) M4VENC_MALLOC(nTotalMB * sizeof(typeDCStore));
      if (video->predDC == NULL) goto CLEAN_UP;
  
      if (!video->encParams->H263_Enabled)
      {
-         if ((size_t)((max_width >> 4) + 1) > SIZE_MAX / sizeof(typeDCACStore)) {
-             goto CLEAN_UP;
-         }
          video->predDCAC_col = (typeDCACStore *) M4VENC_MALLOC(((max_width >> 4) + 1) * sizeof(typeDCACStore));
          if (video->predDCAC_col == NULL) goto CLEAN_UP;
  
--- 676,686 ----
***************
*** 708,716 ****
          /*  the rest will be used for storing horizontal (row) AC coefficients  */
          video->predDCAC_row = video->predDCAC_col + 1;        /*  ACDC */
  
-         if ((size_t)nTotalMB > SIZE_MAX / sizeof(Int)) {
-             goto CLEAN_UP;
-         }
          video->acPredFlag = (Int *) M4VENC_MALLOC(nTotalMB * sizeof(Int)); /* Memory for acPredFlag */
          if (video->acPredFlag == NULL) goto CLEAN_UP;
      }
--- 688,693 ----
***************
*** 764,778 ****
          offset = (pitch << 4) + 16;
          max_height += 32;
      }
-     if (((uint64_t)pitch * max_height) > (uint64_t)INT32_MAX) {
-         goto CLEAN_UP;
-     }
      size = pitch * max_height;
  
-     if (size > INT32_MAX - (size >> 1)
-             || (size_t)(size + (size >> 1)) > SIZE_MAX / sizeof(PIXEL)) {
-         goto CLEAN_UP;
-     }
      video->currVop->yChan = (PIXEL *)M4VENC_MALLOC(sizeof(PIXEL) * (size + (size >> 1))); /* Memory for currVop Y */
      if (video->currVop->yChan == NULL) goto CLEAN_UP;
      video->currVop->uChan = video->currVop->yChan + size;/* Memory for currVop U */
--- 741,748 ----
***************
*** 871,879 ****
      /* /// End /////////////////////////////////////// */
  
  
-     if ((size_t)nLayers > SIZE_MAX / sizeof(Vol *)) {
-         goto CLEAN_UP;
-     }
      video->vol = (Vol **)M4VENC_MALLOC(nLayers * sizeof(Vol *)); /* Memory for VOL pointers */
  
      /* Memory allocation and Initialization of Vols and writing of headers */
--- 841,846 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/mp3dec/SoftMP3.cpp b/media/libstagefright/codecs/mp3dec/SoftMP3.cpp
*** a/media/libstagefright/codecs/mp3dec/SoftMP3.cpp	2018-09-22 10:19:51.733278169 +0200
--- b/media/libstagefright/codecs/mp3dec/SoftMP3.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 118,134 ****
      mIsFirst = true;
  }
  
- void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
-     if (len > outHeader->nAllocLen) {
-         ALOGE("memset buffer too small: got %lu, expected %zu", outHeader->nAllocLen, len);
-         android_errorWriteLog(0x534e4554, "29422022");
-         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
-         mSignalledError = true;
-         return NULL;
-     }
-     return memset(outHeader->pBuffer, c, len);
- }
- 
  OMX_ERRORTYPE SoftMP3::internalGetParameter(
          OMX_INDEXTYPE index, OMX_PTR params) {
      switch (index) {
--- 118,123 ----
***************
*** 137,146 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex > 1) {
                  return OMX_ErrorUndefined;
              }
--- 126,131 ----
***************
*** 159,185 ****
              return OMX_ErrorNone;
          }
  
-         case OMX_IndexParamAudioMp3:
-         {
-             OMX_AUDIO_PARAM_MP3TYPE *mp3Params =
-                 (OMX_AUDIO_PARAM_MP3TYPE *)params;
- 
-             if (!isValidOMXParam(mp3Params)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
-             if (mp3Params->nPortIndex > 1) {
-                 return OMX_ErrorUndefined;
-             }
- 
-             mp3Params->nChannels = mNumChannels;
-             mp3Params->nBitRate = 0 /* unknown */;
-             mp3Params->nSampleRate = mSamplingRate;
-             // other fields are encoder-only
- 
-             return OMX_ErrorNone;
-         }
- 
          default:
              return SimpleSoftOMXComponent::internalGetParameter(index, params);
      }
--- 144,149 ----
***************
*** 193,202 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (strncmp((const char *)roleParams->cRole,
                          "audio_decoder.mp3",
                          OMX_MAX_STRINGNAME_SIZE - 1)) {
--- 157,162 ----
***************
*** 211,220 ****
              const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (const OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 171,176 ----
***************
*** 256,264 ****
                  outHeader->nFilledLen =
                      kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);
  
!                 if (!memsetSafe(outHeader, 0, outHeader->nFilledLen)) {
!                     return;
!                 }
              } else {
                  // Since we never discarded frames from the start, we won't have
                  // to add any padding at the end either.
--- 212,218 ----
                  outHeader->nFilledLen =
                      kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t);
  
!                 memset(outHeader->pBuffer, 0, outHeader->nFilledLen);
              } else {
                  // Since we never discarded frames from the start, we won't have
                  // to add any padding at the end either.
***************
*** 286,299 ****
          mConfig->inputBufferUsedLength = 0;
  
          mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t);
-         if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) {
-             ALOGE("input buffer too small: got %lu, expected %u",
-                 outHeader->nAllocLen, mConfig->outputFrameSize);
-             android_errorWriteLog(0x534e4554, "27793371");
-             notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
-             mSignalledError = true;
-             return;
-         }
  
          mConfig->pOutputBuffer =
              reinterpret_cast<int16_t *>(outHeader->pBuffer);
--- 240,245 ----
***************
*** 321,329 ****
  
              // This is recoverable, just ignore the current frame and
              // play silence instead.
!             if (!memsetSafe(outHeader, 0, mConfig->outputFrameSize * sizeof(int16_t))) {
!                 return;
!             }
  
              mConfig->inputBufferUsedLength = inHeader->nFilledLen;
          } else if (mConfig->samplingRate != mSamplingRate
--- 267,275 ----
  
              // This is recoverable, just ignore the current frame and
              // play silence instead.
!             memset(outHeader->pBuffer,
!                    0,
!                    mConfig->outputFrameSize * sizeof(int16_t));
  
              mConfig->inputBufferUsedLength = inHeader->nFilledLen;
          } else if (mConfig->samplingRate != mSamplingRate
diff '--exclude=.git' -crB a/media/libstagefright/codecs/mp3dec/SoftMP3.h b/media/libstagefright/codecs/mp3dec/SoftMP3.h
*** a/media/libstagefright/codecs/mp3dec/SoftMP3.h	2018-09-22 10:19:51.733278169 +0200
--- b/media/libstagefright/codecs/mp3dec/SoftMP3.h	2018-09-22 10:11:05.448312615 +0200
***************
*** 70,76 ****
  
      void initPorts();
      void initDecoder();
-     void *memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len);
  
      DISALLOW_EVIL_CONSTRUCTORS(SoftMP3);
  };
--- 70,75 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/dec/SoftVPX.cpp b/media/libstagefright/codecs/on2/dec/SoftVPX.cpp
*** a/media/libstagefright/codecs/on2/dec/SoftVPX.cpp	2018-09-22 10:19:51.737278176 +0200
--- b/media/libstagefright/codecs/on2/dec/SoftVPX.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 27,36 ****
  #include "vpx/vpx_codec.h"
  #include "vpx/vp8dx.h"
  
- #ifndef UINT32_MAX
- #define UINT32_MAX       (4294967295U)
- #endif
- 
  namespace android {
  
  SoftVPX::SoftVPX(
--- 27,32 ----
***************
*** 138,144 ****
          vpx_image_t *img = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter);
  
          if (img != NULL) {
!             CHECK_EQ(img->fmt, VPX_IMG_FMT_I420);
  
              uint32_t width = img->d_w;
              uint32_t height = img->d_h;
--- 134,140 ----
          vpx_image_t *img = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter);
  
          if (img != NULL) {
!             CHECK_EQ(img->fmt, IMG_FMT_I420);
  
              uint32_t width = img->d_w;
              uint32_t height = img->d_h;
***************
*** 155,192 ****
              }
  
              outHeader->nOffset = 0;
!             outHeader->nFilledLen = (mWidth * mHeight * 3) / 2;
              outHeader->nFlags = EOSseen ? OMX_BUFFERFLAG_EOS : 0;
              outHeader->nTimeStamp = inHeader->nTimeStamp;
  
!             if (outputBufferSafe(outHeader)) {
!                 const uint8_t *srcLine = (const uint8_t *)img->planes[VPX_PLANE_Y];
!                 uint8_t *dst = outHeader->pBuffer;
!                 for (size_t i = 0; i < img->d_h; ++i) {
!                     memcpy(dst, srcLine, img->d_w);
! 
!                     srcLine += img->stride[VPX_PLANE_Y];
!                     dst += img->d_w;
!                 }
! 
!                 srcLine = (const uint8_t *)img->planes[VPX_PLANE_U];
!                 for (size_t i = 0; i < img->d_h / 2; ++i) {
!                     memcpy(dst, srcLine, img->d_w / 2);
! 
!                     srcLine += img->stride[VPX_PLANE_U];
!                     dst += img->d_w / 2;
!                 }
! 
!                 srcLine = (const uint8_t *)img->planes[VPX_PLANE_V];
!                 for (size_t i = 0; i < img->d_h / 2; ++i) {
!                     memcpy(dst, srcLine, img->d_w / 2);
! 
!                     srcLine += img->stride[VPX_PLANE_V];
!                     dst += img->d_w / 2;
!                 }
!             } else {
!                 outHeader->nFilledLen = 0;
              }
              outInfo->mOwnedByUs = false;
              outQueue.erase(outQueue.begin());
              outInfo = NULL;
--- 151,185 ----
              }
  
              outHeader->nOffset = 0;
!             outHeader->nFilledLen = (width * height * 3) / 2;
              outHeader->nFlags = EOSseen ? OMX_BUFFERFLAG_EOS : 0;
              outHeader->nTimeStamp = inHeader->nTimeStamp;
  
!             const uint8_t *srcLine = (const uint8_t *)img->planes[PLANE_Y];
!             uint8_t *dst = outHeader->pBuffer;
!             for (size_t i = 0; i < img->d_h; ++i) {
!                 memcpy(dst, srcLine, img->d_w);
! 
!                 srcLine += img->stride[PLANE_Y];
!                 dst += img->d_w;
              }
+ 
+             srcLine = (const uint8_t *)img->planes[PLANE_U];
+             for (size_t i = 0; i < img->d_h / 2; ++i) {
+                 memcpy(dst, srcLine, img->d_w / 2);
+ 
+                 srcLine += img->stride[PLANE_U];
+                 dst += img->d_w / 2;
+             }
+ 
+             srcLine = (const uint8_t *)img->planes[PLANE_V];
+             for (size_t i = 0; i < img->d_h / 2; ++i) {
+                 memcpy(dst, srcLine, img->d_w / 2);
+ 
+                 srcLine += img->stride[PLANE_V];
+                 dst += img->d_w / 2;
+             }
+ 
              outInfo->mOwnedByUs = false;
              outQueue.erase(outQueue.begin());
              outInfo = NULL;
***************
*** 202,225 ****
      }
  }
  
- bool SoftVPX::outputBufferSafe(OMX_BUFFERHEADERTYPE *outHeader) {
-     uint32_t width = mWidth;
-     uint32_t height = mHeight;
-     uint64_t nFilledLen = width;
-     nFilledLen *= height;
-     if (nFilledLen > UINT32_MAX / 3) {
-         ALOGE("b/29421675, nFilledLen overflow %llu w %u h %u", nFilledLen, width, height);
-         android_errorWriteLog(0x534e4554, "29421675");
-         return false;
-     } else if (outHeader->nAllocLen < outHeader->nFilledLen) {
-         ALOGE("b/27597103, buffer too small");
-         android_errorWriteLog(0x534e4554, "27597103");
-         return false;
-     }
- 
-     return true;
- }
- 
  }  // namespace android
  
  android::SoftOMXComponent *createSoftOMXComponent(
--- 195,200 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/dec/SoftVPX.h b/media/libstagefright/codecs/on2/dec/SoftVPX.h
*** a/media/libstagefright/codecs/on2/dec/SoftVPX.h	2018-09-22 10:19:51.737278176 +0200
--- b/media/libstagefright/codecs/on2/dec/SoftVPX.h	2018-09-22 10:11:05.452312621 +0200
***************
*** 48,54 ****
      void *mCtx;
  
      status_t initDecoder();
-     bool outputBufferSafe(OMX_BUFFERHEADERTYPE *outHeader);
  
      DISALLOW_EVIL_CONSTRUCTORS(SoftVPX);
  };
--- 48,53 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp
*** a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp	2018-09-22 10:19:51.737278176 +0200
--- b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 25,34 ****
  #include <media/stagefright/foundation/ADebug.h>
  #include <media/stagefright/MediaDefs.h>
  
- #ifndef INT32_MAX
- #define INT32_MAX   2147483647
- #endif
- 
  namespace android {
  
  
--- 25,30 ----
***************
*** 304,313 ****
  
      if (mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar || mInputDataIsMeta) {
          if (mConversionBuffer == NULL) {
-             if (((uint64_t)mWidth * mHeight) > ((uint64_t)INT32_MAX / 3)) {
-                 ALOGE("b/25812794, Buffer size is too big.");
-                 return UNKNOWN_ERROR;
-             }
              mConversionBuffer = (uint8_t *)malloc(mWidth * mHeight * 3 / 2);
              if (mConversionBuffer == NULL) {
                  ALOGE("Allocating conversion buffer failed.");
--- 300,305 ----
***************
*** 387,410 ****
              OMX_VIDEO_PARAM_BITRATETYPE *bitrate =
                  (OMX_VIDEO_PARAM_BITRATETYPE *)param;
  
!             if (!isValidOMXParam(bitrate)) {
!                 return OMX_ErrorBadParameter;
!             }
! 
!             if (bitrate->nPortIndex != kOutputPortIndex) {
!                 return OMX_ErrorUnsupportedIndex;
!             }
  
!             bitrate->nTargetBitrate = mBitrate;
  
!             if (mBitrateControlMode == VPX_VBR) {
!                 bitrate->eControlRate = OMX_Video_ControlRateVariable;
!             } else if (mBitrateControlMode == VPX_CBR) {
!                 bitrate->eControlRate = OMX_Video_ControlRateConstant;
!             } else {
!                 return OMX_ErrorUnsupportedSetting;
!             }
!             return OMX_ErrorNone;
          }
  
          // VP8 specific parameters that use extension headers
--- 379,398 ----
              OMX_VIDEO_PARAM_BITRATETYPE *bitrate =
                  (OMX_VIDEO_PARAM_BITRATETYPE *)param;
  
!                 if (bitrate->nPortIndex != kOutputPortIndex) {
!                     return OMX_ErrorUnsupportedIndex;
!                 }
  
!                 bitrate->nTargetBitrate = mBitrate;
  
!                 if (mBitrateControlMode == VPX_VBR) {
!                     bitrate->eControlRate = OMX_Video_ControlRateVariable;
!                 } else if (mBitrateControlMode == VPX_CBR) {
!                     bitrate->eControlRate = OMX_Video_ControlRateConstant;
!                 } else {
!                     return OMX_ErrorUnsupportedSetting;
!                 }
!                 return OMX_ErrorNone;
          }
  
          // VP8 specific parameters that use extension headers
***************
*** 412,440 ****
              OMX_VIDEO_PARAM_VP8TYPE *vp8Params =
                  (OMX_VIDEO_PARAM_VP8TYPE *)param;
  
!             if (!isValidOMXParam(vp8Params)) {
!                 return OMX_ErrorBadParameter;
!             }
! 
!             if (vp8Params->nPortIndex != kOutputPortIndex) {
!                 return OMX_ErrorUnsupportedIndex;
!             }
  
!             vp8Params->eProfile = OMX_VIDEO_VP8ProfileMain;
!             vp8Params->eLevel = mLevel;
!             vp8Params->nDCTPartitions = mDCTPartitions;
!             vp8Params->bErrorResilientMode = mErrorResilience;
!             return OMX_ErrorNone;
          }
  
          case OMX_IndexParamVideoProfileLevelQuerySupported: {
              OMX_VIDEO_PARAM_PROFILELEVELTYPE *profileAndLevel =
                  (OMX_VIDEO_PARAM_PROFILELEVELTYPE *)param;
  
-             if (!isValidOMXParam(profileAndLevel)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (profileAndLevel->nPortIndex != kOutputPortIndex) {
                  return OMX_ErrorUnsupportedIndex;
              }
--- 400,420 ----
              OMX_VIDEO_PARAM_VP8TYPE *vp8Params =
                  (OMX_VIDEO_PARAM_VP8TYPE *)param;
  
!                 if (vp8Params->nPortIndex != kOutputPortIndex) {
!                     return OMX_ErrorUnsupportedIndex;
!                 }
  
!                 vp8Params->eProfile = OMX_VIDEO_VP8ProfileMain;
!                 vp8Params->eLevel = mLevel;
!                 vp8Params->nDCTPartitions = mDCTPartitions;
!                 vp8Params->bErrorResilientMode = mErrorResilience;
!                 return OMX_ErrorNone;
          }
  
          case OMX_IndexParamVideoProfileLevelQuerySupported: {
              OMX_VIDEO_PARAM_PROFILELEVELTYPE *profileAndLevel =
                  (OMX_VIDEO_PARAM_PROFILELEVELTYPE *)param;
  
              if (profileAndLevel->nPortIndex != kOutputPortIndex) {
                  return OMX_ErrorUnsupportedIndex;
              }
***************
*** 468,477 ****
              OMX_VIDEO_PARAM_PROFILELEVELTYPE *profileAndLevel =
                  (OMX_VIDEO_PARAM_PROFILELEVELTYPE *)param;
  
-             if (!isValidOMXParam(profileAndLevel)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (profileAndLevel->nPortIndex != kOutputPortIndex) {
                  return OMX_ErrorUnsupportedIndex;
              }
--- 448,453 ----
***************
*** 493,529 ****
      const int32_t indexFull = index;
  
      switch (indexFull) {
!         case OMX_IndexParamStandardComponentRole: {
!             const OMX_PARAM_COMPONENTROLETYPE *role =
!                 (const OMX_PARAM_COMPONENTROLETYPE*) param;
! 
!             if (!isValidOMXParam(role)) {
!                 return OMX_ErrorBadParameter;
!             }
!             return internalSetRoleParams(role);
!         }
! 
!         case OMX_IndexParamVideoBitrate: {
!             const OMX_VIDEO_PARAM_BITRATETYPE *bitRate =
!                 (const OMX_VIDEO_PARAM_BITRATETYPE*) param;
! 
!             if (!isValidOMXParam(bitRate)) {
!                 return OMX_ErrorBadParameter;
!             }
! 
!             return internalSetBitrateParams(bitRate);
!         }
  
          case OMX_IndexParamPortDefinition:
          {
!             const OMX_PARAM_PORTDEFINITIONTYPE *portDefinition =
!                 (const OMX_PARAM_PORTDEFINITIONTYPE*) param;
! 
!             if (!isValidOMXParam(portDefinition)) {
!                 return OMX_ErrorBadParameter;
!             }
! 
!             OMX_ERRORTYPE err = internalSetPortParams(portDefinition);
  
              if (err != OMX_ErrorNone) {
                  return err;
--- 469,486 ----
      const int32_t indexFull = index;
  
      switch (indexFull) {
!         case OMX_IndexParamStandardComponentRole:
!             return internalSetRoleParams(
!                 (const OMX_PARAM_COMPONENTROLETYPE *)param);
! 
!         case OMX_IndexParamVideoBitrate:
!             return internalSetBitrateParams(
!                 (const OMX_VIDEO_PARAM_BITRATETYPE *)param);
  
          case OMX_IndexParamPortDefinition:
          {
!             OMX_ERRORTYPE err = internalSetPortParams(
!                 (const OMX_PARAM_PORTDEFINITIONTYPE *)param);
  
              if (err != OMX_ErrorNone) {
                  return err;
***************
*** 532,568 ****
              return SimpleSoftOMXComponent::internalSetParameter(index, param);
          }
  
!         case OMX_IndexParamVideoPortFormat: {
!             const OMX_VIDEO_PARAM_PORTFORMATTYPE *portFormatType =
!                 (const OMX_VIDEO_PARAM_PORTFORMATTYPE*) param;
! 
!             if (!isValidOMXParam(portFormatType)) {
!                 return OMX_ErrorBadParameter;
!             }
!             return internalSetFormatParams(portFormatType);
!         }
! 
!         case OMX_IndexParamVideoVp8: {
!             const OMX_VIDEO_PARAM_VP8TYPE *vp8Params =
!                 (const OMX_VIDEO_PARAM_VP8TYPE*) param;
! 
!             if (!isValidOMXParam(vp8Params)) {
!                 return OMX_ErrorBadParameter;
!             }
! 
!             return internalSetVp8Params(vp8Params);
!         }
! 
!         case OMX_IndexParamVideoProfileLevelCurrent: {
!             const OMX_VIDEO_PARAM_PROFILELEVELTYPE *vp8Params =
!                 (const OMX_VIDEO_PARAM_PROFILELEVELTYPE*) param;
! 
!             if (!isValidOMXParam(vp8Params)) {
!                 return OMX_ErrorBadParameter;
!             }
! 
!             return internalSetProfileLevel(vp8Params);
!         }
  
          case OMX_IndexVendorStartUnused:
          {
--- 489,505 ----
              return SimpleSoftOMXComponent::internalSetParameter(index, param);
          }
  
!         case OMX_IndexParamVideoPortFormat:
!             return internalSetFormatParams(
!                 (const OMX_VIDEO_PARAM_PORTFORMATTYPE *)param);
! 
!         case OMX_IndexParamVideoVp8:
!             return internalSetVp8Params(
!                 (const OMX_VIDEO_PARAM_VP8TYPE *)param);
! 
!         case OMX_IndexParamVideoProfileLevelCurrent:
!             return internalSetProfileLevel(
!                 (const OMX_VIDEO_PARAM_PROFILELEVELTYPE *)param);
  
          case OMX_IndexVendorStartUnused:
          {
***************
*** 570,579 ****
              const StoreMetaDataInBuffersParams *storeParam =
                  (const StoreMetaDataInBuffersParams *)param;
  
-             if (!isValidOMXParam(storeParam)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (storeParam->nPortIndex != kInputPortIndex) {
                  return OMX_ErrorBadPortIndex;
              }
--- 507,512 ----
***************
*** 596,605 ****
              OMX_CONFIG_INTRAREFRESHVOPTYPE *params =
                  (OMX_CONFIG_INTRAREFRESHVOPTYPE *)_params;
  
-             if (!isValidOMXParam(params)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (params->nPortIndex != kOutputPortIndex) {
                  return OMX_ErrorBadPortIndex;
              }
--- 529,534 ----
***************
*** 613,622 ****
              OMX_VIDEO_CONFIG_BITRATETYPE *params =
                  (OMX_VIDEO_CONFIG_BITRATETYPE *)_params;
  
-             if (!isValidOMXParam(params)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (params->nPortIndex != kOutputPortIndex) {
                  return OMX_ErrorBadPortIndex;
              }
--- 542,547 ----
***************
*** 824,830 ****
          uint8_t *source =
              inputBufferHeader->pBuffer + inputBufferHeader->nOffset;
  
-         size_t frameSize = mWidth * mHeight * 3 / 2;
          if (mInputDataIsMeta) {
              CHECK_GE(inputBufferHeader->nFilledLen,
                       4 + sizeof(buffer_handle_t));
--- 749,754 ----
***************
*** 856,876 ****
              source = mConversionBuffer;
  
              CHECK_EQ(0, grmodule->unlock(grmodule, handle));
!         } else {
!             if (inputBufferHeader->nFilledLen < frameSize) {
!                 android_errorWriteLog(0x534e4554, "27569635");
!                 notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);
!                 return;
!             } else if (inputBufferHeader->nFilledLen > frameSize) {
!                 ALOGW("Input buffer contains too many pixels");
!             }
  
!             if (mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {
!                 ConvertSemiPlanarToPlanar(
!                         source, mConversionBuffer, mWidth, mHeight);
! 
!                 source = mConversionBuffer;
!             }
          }
          vpx_image_t raw_frame;
          vpx_img_wrap(&raw_frame, VPX_IMG_FMT_I420, mWidth, mHeight,
--- 780,790 ----
              source = mConversionBuffer;
  
              CHECK_EQ(0, grmodule->unlock(grmodule, handle));
!         } else if (mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {
!             ConvertSemiPlanarToPlanar(
!                     source, mConversionBuffer, mWidth, mHeight);
  
!             source = mConversionBuffer;
          }
          vpx_image_t raw_frame;
          vpx_img_wrap(&raw_frame, VPX_IMG_FMT_I420, mWidth, mHeight,
***************
*** 922,935 ****
                  outputBufferHeader->nTimeStamp = encoded_packet->data.frame.pts;
                  outputBufferHeader->nFlags = 0;
                  if (encoded_packet->data.frame.flags & VPX_FRAME_IS_KEY)
!                     outputBufferHeader->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;
                  outputBufferHeader->nOffset = 0;
                  outputBufferHeader->nFilledLen = encoded_packet->data.frame.sz;
-                 if (outputBufferHeader->nFilledLen > outputBufferHeader->nAllocLen) {
-                     android_errorWriteLog(0x534e4554, "27569635");
-                     notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);
-                     return;
-                 }
                  memcpy(outputBufferHeader->pBuffer,
                         encoded_packet->data.frame.buf,
                         encoded_packet->data.frame.sz);
--- 836,844 ----
                  outputBufferHeader->nTimeStamp = encoded_packet->data.frame.pts;
                  outputBufferHeader->nFlags = 0;
                  if (encoded_packet->data.frame.flags & VPX_FRAME_IS_KEY)
!                   outputBufferHeader->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;
                  outputBufferHeader->nOffset = 0;
                  outputBufferHeader->nFilledLen = encoded_packet->data.frame.sz;
                  memcpy(outputBufferHeader->pBuffer,
                         encoded_packet->data.frame.buf,
                         encoded_packet->data.frame.sz);
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/h264dec/inc/H264SwDecApi.h b/media/libstagefright/codecs/on2/h264dec/inc/H264SwDecApi.h
*** a/media/libstagefright/codecs/on2/h264dec/inc/H264SwDecApi.h	2018-09-22 10:19:51.737278176 +0200
--- b/media/libstagefright/codecs/on2/h264dec/inc/H264SwDecApi.h	2018-09-22 10:11:05.452312621 +0200
***************
*** 161,167 ****
      void H264SwDecTrace(char *);
  
      /* function prototype for memory allocation */
!     void* H264SwDecMalloc(u32 size, u32 num);
  
      /* function prototype for memory free */
      void H264SwDecFree(void *ptr);
--- 161,167 ----
      void H264SwDecTrace(char *);
  
      /* function prototype for memory allocation */
!     void* H264SwDecMalloc(u32 size);
  
      /* function prototype for memory free */
      void H264SwDecFree(void *ptr);
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/h264dec/SoftAVC.cpp b/media/libstagefright/codecs/on2/h264dec/SoftAVC.cpp
*** a/media/libstagefright/codecs/on2/h264dec/SoftAVC.cpp	2018-09-22 10:19:51.737278176 +0200
--- b/media/libstagefright/codecs/on2/h264dec/SoftAVC.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 205,216 ****
          }
  
          if (mFirstPicture && !outQueue.empty()) {
!             if (!drainOneOutputBuffer(mFirstPictureId, mFirstPicture)) {
!                 ALOGE("Drain failed");
!                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
!                 mSignalledError = true;
!                 return;
!             }
              delete[] mFirstPicture;
              mFirstPicture = NULL;
              mFirstPictureId = -1;
--- 205,211 ----
          }
  
          if (mFirstPicture && !outQueue.empty()) {
!             drainOneOutputBuffer(mFirstPictureId, mFirstPicture);
              delete[] mFirstPicture;
              mFirstPicture = NULL;
              mFirstPictureId = -1;
***************
*** 260,274 ****
      memcpy(mFirstPicture, data, mPictureSize);
  }
  
! bool SoftAVC::drainOneOutputBuffer(int32_t picId, uint8_t* data) {
      List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);
      BufferInfo *outInfo = *outQueue.begin();
-     OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
-     if (outHeader->nAllocLen - outHeader->nOffset < mPictureSize) {
-         android_errorWriteLog(0x534e4554, "27833616");
-         return false;
-     }
      outQueue.erase(outQueue.begin());
      OMX_BUFFERHEADERTYPE *header = mPicToHeaderMap.valueFor(picId);
      outHeader->nTimeStamp = header->nTimeStamp;
      outHeader->nFlags = header->nFlags;
--- 255,265 ----
      memcpy(mFirstPicture, data, mPictureSize);
  }
  
! void SoftAVC::drainOneOutputBuffer(int32_t picId, uint8_t* data) {
      List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);
      BufferInfo *outInfo = *outQueue.begin();
      outQueue.erase(outQueue.begin());
+     OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
      OMX_BUFFERHEADERTYPE *header = mPicToHeaderMap.valueFor(picId);
      outHeader->nTimeStamp = header->nTimeStamp;
      outHeader->nFlags = header->nFlags;
***************
*** 279,285 ****
      delete header;
      outInfo->mOwnedByUs = false;
      notifyFillBufferDone(outHeader);
-     return true;
  }
  
  void SoftAVC::drainAllOutputBuffers(bool eos) {
--- 270,275 ----
***************
*** 292,303 ****
                      mHandle, &decodedPicture, eos /* flush */)) {
              int32_t picId = decodedPicture.picId;
              uint8_t *data = (uint8_t *) decodedPicture.pOutputPicture;
!             if (!drainOneOutputBuffer(picId, data)) {
!                 ALOGE("Drain failed");
!                 notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
!                 mSignalledError = true;
!                 return;
!             }
          }
      }
  
--- 282,288 ----
                      mHandle, &decodedPicture, eos /* flush */)) {
              int32_t picId = decodedPicture.picId;
              uint8_t *data = (uint8_t *) decodedPicture.pOutputPicture;
!             drainOneOutputBuffer(picId, data);
          }
      }
  
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/h264dec/SoftAVC.h b/media/libstagefright/codecs/on2/h264dec/SoftAVC.h
*** a/media/libstagefright/codecs/on2/h264dec/SoftAVC.h	2018-09-22 10:19:51.737278176 +0200
--- b/media/libstagefright/codecs/on2/h264dec/SoftAVC.h	2018-09-22 10:11:05.452312621 +0200
***************
*** 73,79 ****
  
      status_t initDecoder();
      void drainAllOutputBuffers(bool eos);
!     bool drainOneOutputBuffer(int32_t picId, uint8_t *data);
      void saveFirstOutputBuffer(int32_t pidId, uint8_t *data);
      bool handleCropRectEvent(const CropParams* crop);
      bool handlePortSettingChangeEvent(const H264SwDecInfo *info);
--- 73,79 ----
  
      status_t initDecoder();
      void drainAllOutputBuffers(bool eos);
!     void drainOneOutputBuffer(int32_t picId, uint8_t *data);
      void saveFirstOutputBuffer(int32_t pidId, uint8_t *data);
      bool handleCropRectEvent(const CropParams* crop);
      bool handlePortSettingChangeEvent(const H264SwDecInfo *info);
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/h264dec/source/DecTestBench.c b/media/libstagefright/codecs/on2/h264dec/source/DecTestBench.c
*** a/media/libstagefright/codecs/on2/h264dec/source/DecTestBench.c	2018-09-22 10:19:51.757278212 +0200
--- b/media/libstagefright/codecs/on2/h264dec/source/DecTestBench.c	2018-09-22 10:11:05.452312621 +0200
***************
*** 700,720 ****
          library function malloc for allocation of memory.
  
  ------------------------------------------------------------------------------*/
! void* H264SwDecMalloc(u32 size, u32 num)
  {
-     if (size > UINT32_MAX / num) {
-         return NULL;
-     }
  
  #if defined(CHECK_MEMORY_USAGE)
      /* Note that if the decoder has to free and reallocate some of the buffers
       * the total value will be invalid */
      static u32 numBytes = 0;
!     numBytes += size * num;
      DEBUG(("Allocated %d bytes, total %d\n", size, numBytes));
  #endif
  
!     return malloc(size * num);
  }
  
  /*------------------------------------------------------------------------------
--- 700,717 ----
          library function malloc for allocation of memory.
  
  ------------------------------------------------------------------------------*/
! void* H264SwDecMalloc(u32 size)
  {
  
  #if defined(CHECK_MEMORY_USAGE)
      /* Note that if the decoder has to free and reallocate some of the buffers
       * the total value will be invalid */
      static u32 numBytes = 0;
!     numBytes += size;
      DEBUG(("Allocated %d bytes, total %d\n", size, numBytes));
  #endif
  
!     return malloc(size);
  }
  
  /*------------------------------------------------------------------------------
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/h264dec/source/EvaluationTestBench.c b/media/libstagefright/codecs/on2/h264dec/source/EvaluationTestBench.c
*** a/media/libstagefright/codecs/on2/h264dec/source/EvaluationTestBench.c	2018-09-22 10:19:51.757278212 +0200
--- b/media/libstagefright/codecs/on2/h264dec/source/EvaluationTestBench.c	2018-09-22 10:11:05.452312621 +0200
***************
*** 85,91 ****
      rewind(finput);
  
      /* allocate memory for stream buffer, exit if unsuccessful */
!     byteStrm = byteStrmStart = (u8 *)H264SwDecMalloc(sizeof(u8), strmLen);
      if (byteStrm == NULL)
      {
          printf("UNABLE TO ALLOCATE MEMORY\n");
--- 85,91 ----
      rewind(finput);
  
      /* allocate memory for stream buffer, exit if unsuccessful */
!     byteStrm = byteStrmStart = (u8 *)H264SwDecMalloc(sizeof(u8)*strmLen);
      if (byteStrm == NULL)
      {
          printf("UNABLE TO ALLOCATE MEMORY\n");
***************
*** 298,309 ****
          library function malloc for allocation of memory.
  
  ------------------------------------------------------------------------------*/
! void* H264SwDecMalloc(u32 size, u32 num)
  {
!     if (size > UINT32_MAX / num) {
!         return NULL;
!     }
!     return malloc(size * num);
  }
  
  /*------------------------------------------------------------------------------
--- 298,306 ----
          library function malloc for allocation of memory.
  
  ------------------------------------------------------------------------------*/
! void* H264SwDecMalloc(u32 size)
  {
!     return malloc(size);
  }
  
  /*------------------------------------------------------------------------------
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/h264dec/source/h264bsd_decoder.c b/media/libstagefright/codecs/on2/h264dec/source/h264bsd_decoder.c
*** a/media/libstagefright/codecs/on2/h264dec/source/h264bsd_decoder.c	2018-09-22 10:19:51.757278212 +0200
--- b/media/libstagefright/codecs/on2/h264dec/source/h264bsd_decoder.c	2018-09-22 10:11:05.452312621 +0200
***************
*** 101,107 ****
       * specific NEON optimized "memset" for clearing the structure */
      size = (sizeof(macroblockLayer_t) + 63) & ~0x3F;
  
!     pStorage->mbLayer = (macroblockLayer_t*)H264SwDecMalloc(size, 1);
      if (!pStorage->mbLayer)
          return HANTRO_NOK;
  
--- 101,107 ----
       * specific NEON optimized "memset" for clearing the structure */
      size = (sizeof(macroblockLayer_t) + 63) & ~0x3F;
  
!     pStorage->mbLayer = (macroblockLayer_t*)H264SwDecMalloc(size);
      if (!pStorage->mbLayer)
          return HANTRO_NOK;
  
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/h264dec/source/h264bsd_dpb.c b/media/libstagefright/codecs/on2/h264dec/source/h264bsd_dpb.c
*** a/media/libstagefright/codecs/on2/h264dec/source/h264bsd_dpb.c	2018-09-22 10:19:51.757278212 +0200
--- b/media/libstagefright/codecs/on2/h264dec/source/h264bsd_dpb.c	2018-09-22 10:11:05.452312621 +0200
***************
*** 60,66 ****
  #include "h264bsd_util.h"
  #include "basetype.h"
  
- #include <log/log.h>
  /*------------------------------------------------------------------------------
      2. External compiler flags
  --------------------------------------------------------------------------------
--- 60,65 ----
***************
*** 999,1011 ****
      ASSERT(maxFrameNum);
      ASSERT(dpbSize);
  
-     // see comment in loop below about size calculation
-     if (picSizeInMbs > (UINT32_MAX - 32 - 15) / 384) {
-         ALOGE("b/28533562");
-         android_errorWriteLog(0x534e4554, "28533562");
-         return(MEMORY_ALLOCATION_ERROR);
-     }
- 
      dpb->maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES;
      dpb->maxRefFrames        = MAX(maxRefFrames, 1);
      if (noReordering)
--- 998,1003 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/h264dec/source/h264bsd_storage.c b/media/libstagefright/codecs/on2/h264dec/source/h264bsd_storage.c
*** a/media/libstagefright/codecs/on2/h264dec/source/h264bsd_storage.c	2018-09-22 10:19:51.761278219 +0200
--- b/media/libstagefright/codecs/on2/h264dec/source/h264bsd_storage.c	2018-09-22 10:11:05.452312621 +0200
***************
*** 58,67 ****
      3. Module defines
  ------------------------------------------------------------------------------*/
  
- #ifndef UINT32_MAX
- #define UINT32_MAX       (4294967295U)
- #endif
- 
  /*------------------------------------------------------------------------------
      4. Local function prototypes
  ------------------------------------------------------------------------------*/
--- 58,63 ----
***************
*** 330,352 ****
          pStorage->activePps = pStorage->pps[ppsId];
          pStorage->activeSpsId = pStorage->activePps->seqParameterSetId;
          pStorage->activeSps = pStorage->sps[pStorage->activeSpsId];
! 
!         /* report error before multiplication to prevent integer overflow */
!         if (pStorage->activeSps->picWidthInMbs == 0)
!         {
!             pStorage->picSizeInMbs = 0;
!         }
!         else if (pStorage->activeSps->picHeightInMbs >
!                  UINT32_MAX / pStorage->activeSps->picWidthInMbs)
!         {
!             return(MEMORY_ALLOCATION_ERROR);
!         }
!         else
!         {
!             pStorage->picSizeInMbs =
!                 pStorage->activeSps->picWidthInMbs *
!                 pStorage->activeSps->picHeightInMbs;
!         }
  
          pStorage->currImage->width = pStorage->activeSps->picWidthInMbs;
          pStorage->currImage->height = pStorage->activeSps->picHeightInMbs;
--- 326,334 ----
          pStorage->activePps = pStorage->pps[ppsId];
          pStorage->activeSpsId = pStorage->activePps->seqParameterSetId;
          pStorage->activeSps = pStorage->sps[pStorage->activeSpsId];
!         pStorage->picSizeInMbs =
!             pStorage->activeSps->picWidthInMbs *
!             pStorage->activeSps->picHeightInMbs;
  
          pStorage->currImage->width = pStorage->activeSps->picWidthInMbs;
          pStorage->currImage->height = pStorage->activeSps->picHeightInMbs;
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/h264dec/source/h264bsd_util.h b/media/libstagefright/codecs/on2/h264dec/source/h264bsd_util.h
*** a/media/libstagefright/codecs/on2/h264dec/source/h264bsd_util.h	2018-09-22 10:19:51.761278219 +0200
--- b/media/libstagefright/codecs/on2/h264dec/source/h264bsd_util.h	2018-09-22 10:11:05.452312621 +0200
***************
*** 140,146 ****
  /* macro to allocate memory */
  #define ALLOCATE(ptr, count, type) \
  { \
!     (ptr) = H264SwDecMalloc(sizeof(type), (count)); \
  }
  
  /* macro to free allocated memory */
--- 140,146 ----
  /* macro to allocate memory */
  #define ALLOCATE(ptr, count, type) \
  { \
!     (ptr) = H264SwDecMalloc((count) * sizeof(type)); \
  }
  
  /* macro to free allocated memory */
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/h264dec/source/H264SwDecApi.c b/media/libstagefright/codecs/on2/h264dec/source/H264SwDecApi.c
*** a/media/libstagefright/codecs/on2/h264dec/source/H264SwDecApi.c	2018-09-22 10:19:51.757278212 +0200
--- b/media/libstagefright/codecs/on2/h264dec/source/H264SwDecApi.c	2018-09-22 10:11:05.452312621 +0200
***************
*** 35,42 ****
  /*------------------------------------------------------------------------------
      1. Include headers
  ------------------------------------------------------------------------------*/
- #include <log/log.h>
- 
  #include <stdlib.h>
  #include "basetype.h"
  #include "h264bsd_container.h"
--- 35,40 ----
***************
*** 77,89 ****
  void H264SwDecTrace(char *string) {
  }
  
! void* H264SwDecMalloc(u32 size, u32 num) {
!     if (size > UINT32_MAX / num) {
!         ALOGE("can't allocate %u * %u bytes", size, num);
!         android_errorWriteLog(0x534e4554, "27855419");
!         return NULL;
!     }
!     return malloc(size * num);
  }
  
  void H264SwDecFree(void *ptr) {
--- 75,82 ----
  void H264SwDecTrace(char *string) {
  }
  
! void* H264SwDecMalloc(u32 size) {
!     return malloc(size);
  }
  
  void H264SwDecFree(void *ptr) {
***************
*** 147,153 ****
          return(H264SWDEC_PARAM_ERR);
      }
  
!     pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t), 1);
  
      if (pDecCont == NULL)
      {
--- 140,146 ----
          return(H264SWDEC_PARAM_ERR);
      }
  
!     pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t));
  
      if (pDecCont == NULL)
      {
diff '--exclude=.git' -crB a/media/libstagefright/codecs/on2/h264dec/source/TestBenchMultipleInstance.c b/media/libstagefright/codecs/on2/h264dec/source/TestBenchMultipleInstance.c
*** a/media/libstagefright/codecs/on2/h264dec/source/TestBenchMultipleInstance.c	2018-09-22 10:19:51.757278212 +0200
--- b/media/libstagefright/codecs/on2/h264dec/source/TestBenchMultipleInstance.c	2018-09-22 10:11:05.452312621 +0200
***************
*** 413,424 ****
      Function name:  H264SwDecmalloc
  
  ------------------------------------------------------------------------------*/
! void* H264SwDecMalloc(u32 size, u32 num)
  {
!     if (size > UINT32_MAX / num) {
!         return NULL;
!     }
!     return malloc(size * num);
  }
  
  /*------------------------------------------------------------------------------
--- 413,421 ----
      Function name:  H264SwDecmalloc
  
  ------------------------------------------------------------------------------*/
! void* H264SwDecMalloc(u32 size)
  {
!     return malloc(size);
  }
  
  /*------------------------------------------------------------------------------
diff '--exclude=.git' -crB a/media/libstagefright/codecs/raw/SoftRaw.cpp b/media/libstagefright/codecs/raw/SoftRaw.cpp
*** a/media/libstagefright/codecs/raw/SoftRaw.cpp	2018-09-22 10:19:51.761278219 +0200
--- b/media/libstagefright/codecs/raw/SoftRaw.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 103,112 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 103,108 ----
***************
*** 138,147 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (strncmp((const char *)roleParams->cRole,
                          "audio_decoder.raw",
                          OMX_MAX_STRINGNAME_SIZE - 1)) {
--- 134,139 ----
***************
*** 156,165 ****
              const OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 148,153 ----
diff '--exclude=.git' -crB a/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp b/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp
*** a/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp	2018-09-22 10:19:51.761278219 +0200
--- b/media/libstagefright/codecs/vorbis/dec/SoftVorbis.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 128,137 ****
              OMX_AUDIO_PARAM_VORBISTYPE *vorbisParams =
                  (OMX_AUDIO_PARAM_VORBISTYPE *)params;
  
-             if (!isValidOMXParam(vorbisParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (vorbisParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 128,133 ----
***************
*** 163,172 ****
              OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                  (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
  
-             if (!isValidOMXParam(pcmParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (pcmParams->nPortIndex != 1) {
                  return OMX_ErrorUndefined;
              }
--- 159,164 ----
***************
*** 203,212 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (strncmp((const char *)roleParams->cRole,
                          "audio_decoder.vorbis",
                          OMX_MAX_STRINGNAME_SIZE - 1)) {
--- 195,200 ----
***************
*** 221,230 ****
              const OMX_AUDIO_PARAM_VORBISTYPE *vorbisParams =
                  (const OMX_AUDIO_PARAM_VORBISTYPE *)params;
  
-             if (!isValidOMXParam(vorbisParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (vorbisParams->nPortIndex != 0) {
                  return OMX_ErrorUndefined;
              }
--- 209,214 ----
***************
*** 271,282 ****
  
          const uint8_t *data = header->pBuffer + header->nOffset;
          size_t size = header->nFilledLen;
-         if (size < 7) {
-             ALOGE("Too small input buffer: %zu bytes", size);
-             android_errorWriteLog(0x534e4554, "27833616");
-             notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
-             return;
-         }
  
          ogg_buffer buf;
          ogg_reference ref;
--- 255,260 ----
***************
*** 377,390 ****
          if (err != 0) {
              ALOGW("vorbis_dsp_synthesis returned %d", err);
          } else {
-             size_t numSamplesPerBuffer = kMaxNumSamplesPerBuffer;
-             if (numSamplesPerBuffer > outHeader->nAllocLen / sizeof(int16_t)) {
-                 numSamplesPerBuffer = outHeader->nAllocLen / sizeof(int16_t);
-                 android_errorWriteLog(0x534e4554, "27833616");
-             }
              numFrames = vorbis_dsp_pcmout(
                      mState, (int16_t *)outHeader->pBuffer,
!                     (numSamplesPerBuffer / mVi->channels));
  
              if (numFrames < 0) {
                  ALOGE("vorbis_dsp_pcmout returned %d", numFrames);
--- 355,363 ----
          if (err != 0) {
              ALOGW("vorbis_dsp_synthesis returned %d", err);
          } else {
              numFrames = vorbis_dsp_pcmout(
                      mState, (int16_t *)outHeader->pBuffer,
!                     kMaxNumSamplesPerBuffer);
  
              if (numFrames < 0) {
                  ALOGE("vorbis_dsp_pcmout returned %d", numFrames);
diff '--exclude=.git' -crB a/media/libstagefright/colorconversion/SoftwareRenderer.cpp b/media/libstagefright/colorconversion/SoftwareRenderer.cpp
*** a/media/libstagefright/colorconversion/SoftwareRenderer.cpp	2018-09-22 10:19:51.761278219 +0200
--- b/media/libstagefright/colorconversion/SoftwareRenderer.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 173,181 ****
                  buf->stride, buf->height,
                  0, 0, mCropWidth - 1, mCropHeight - 1);
      } else if (mColorFormat == OMX_COLOR_FormatYUV420Planar) {
-         if ((size_t)mWidth * mHeight * 3 / 2 > size) {
-             goto skip_copying;
-         }
          const uint8_t *src_y = (const uint8_t *)data;
          const uint8_t *src_u = (const uint8_t *)data + mWidth * mHeight;
          const uint8_t *src_v = src_u + (mWidth / 2 * mHeight / 2);
--- 173,178 ----
***************
*** 218,226 ****
          }
      } else {
          CHECK_EQ(mColorFormat, OMX_TI_COLOR_FormatYUV420PackedSemiPlanar);
-         if ((size_t)mWidth * mHeight * 3 / 2 > size) {
-             goto skip_copying;
-         }
  
          const uint8_t *src_y =
              (const uint8_t *)data;
--- 215,220 ----
***************
*** 255,261 ****
          }
      }
  
- skip_copying:
      CHECK_EQ(0, mapper.unlock(buf->handle));
  
      if ((err = mNativeWindow->queueBuffer(mNativeWindow.get(), buf,
--- 249,254 ----
diff '--exclude=.git' -crB a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
*** a/media/libstagefright/DataSource.cpp	2018-09-22 10:19:51.673278059 +0200
--- b/media/libstagefright/DataSource.cpp	2018-09-22 10:11:05.444312607 +0200
***************
*** 288,294 ****
                          &copy, &cacheConfig, &disconnectAtHighwatermark);
              }
  
!             source = NuCachedSource2::Create(
                      httpSource,
                      cacheConfig.isEmpty() ? NULL : cacheConfig.string());
          } else {
--- 288,294 ----
                          &copy, &cacheConfig, &disconnectAtHighwatermark);
              }
  
!             source = new NuCachedSource2(
                      httpSource,
                      cacheConfig.isEmpty() ? NULL : cacheConfig.string());
          } else {
diff '--exclude=.git' -crB a/media/libstagefright/DRMExtractor.cpp b/media/libstagefright/DRMExtractor.cpp
*** a/media/libstagefright/DRMExtractor.cpp	2018-09-22 10:19:51.673278059 +0200
--- b/media/libstagefright/DRMExtractor.cpp	2018-09-22 10:11:05.444312607 +0200
***************
*** 186,193 ****
  
              srcOffset += mNALLengthSize;
  
!             size_t end = srcOffset + nalLength;
!             if (end > len || end < srcOffset) {
                  if (decryptedDrmBuffer.data) {
                      delete [] decryptedDrmBuffer.data;
                      decryptedDrmBuffer.data = NULL;
--- 186,192 ----
  
              srcOffset += mNALLengthSize;
  
!             if (srcOffset + nalLength > len) {
                  if (decryptedDrmBuffer.data) {
                      delete [] decryptedDrmBuffer.data;
                      decryptedDrmBuffer.data = NULL;
***************
*** 200,216 ****
                  continue;
              }
  
!             if (dstOffset > SIZE_MAX - 4 ||
!                 dstOffset + 4 > SIZE_MAX - nalLength ||
!                 dstOffset + 4 + nalLength > (*buffer)->size()) {
!                 (*buffer)->release();
!                 (*buffer) = NULL;
!                 if (decryptedDrmBuffer.data) {
!                     delete [] decryptedDrmBuffer.data;
!                     decryptedDrmBuffer.data = NULL;
!                 }
!                 return ERROR_MALFORMED;
!             }
  
              dstData[dstOffset++] = 0;
              dstData[dstOffset++] = 0;
--- 199,205 ----
                  continue;
              }
  
!             CHECK(dstOffset + 4 <= (*buffer)->size());
  
              dstData[dstOffset++] = 0;
              dstData[dstOffset++] = 0;
diff '--exclude=.git' -crB a/media/libstagefright/ESDS.cpp b/media/libstagefright/ESDS.cpp
*** a/media/libstagefright/ESDS.cpp	2018-09-22 10:19:51.673278059 +0200
--- b/media/libstagefright/ESDS.cpp	2018-09-22 10:11:05.444312607 +0200
***************
*** 136,143 ****
      --size;
  
      if (streamDependenceFlag) {
-         if (size < 2)
-             return ERROR_MALFORMED;
          offset += 2;
          size -= 2;
      }
--- 136,141 ----
***************
*** 147,161 ****
              return ERROR_MALFORMED;
          }
          unsigned URLlength = mData[offset];
-         if (URLlength >= size)
-             return ERROR_MALFORMED;
          offset += URLlength + 1;
          size -= URLlength + 1;
      }
  
      if (OCRstreamFlag) {
-         if (size < 2)
-             return ERROR_MALFORMED;
          offset += 2;
          size -= 2;
  
--- 145,155 ----
diff '--exclude=.git' -crB a/media/libstagefright/foundation/ABuffer.cpp b/media/libstagefright/foundation/ABuffer.cpp
*** a/media/libstagefright/foundation/ABuffer.cpp	2018-09-22 10:19:51.761278219 +0200
--- b/media/libstagefright/foundation/ABuffer.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 23,39 ****
  namespace android {
  
  ABuffer::ABuffer(size_t capacity)
!     : mRangeOffset(0),
        mInt32Data(0),
        mOwnsData(true) {
-     mData = malloc(capacity);
-     if (mData == NULL) {
-         mCapacity = 0;
-         mRangeLength = 0;
-     } else {
-         mCapacity = capacity;
-         mRangeLength = capacity;
-     }
  }
  
  ABuffer::ABuffer(void *data, size_t capacity)
--- 23,34 ----
  namespace android {
  
  ABuffer::ABuffer(size_t capacity)
!     : mData(malloc(capacity)),
!       mCapacity(capacity),
!       mRangeOffset(0),
!       mRangeLength(capacity),
        mInt32Data(0),
        mOwnsData(true) {
  }
  
  ABuffer::ABuffer(void *data, size_t capacity)
diff '--exclude=.git' -crB a/media/libstagefright/foundation/AMessage.cpp b/media/libstagefright/foundation/AMessage.cpp
*** a/media/libstagefright/foundation/AMessage.cpp	2018-09-22 10:19:51.765278227 +0200
--- b/media/libstagefright/foundation/AMessage.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 453,475 ****
      sp<AMessage> msg = new AMessage(what);
  
      msg->mNumItems = static_cast<size_t>(parcel.readInt32());
-     if (msg->mNumItems > kMaxNumItems) {
-         ALOGE("Too large number of items clipped.");
-         msg->mNumItems = kMaxNumItems;
-     }
  
      for (size_t i = 0; i < msg->mNumItems; ++i) {
          Item *item = &msg->mItems[i];
  
!         const char *name = parcel.readCString();
!         if (name == NULL) {
!             ALOGE("Failed reading name for an item. Parsing aborted.");
!             msg->mNumItems = i;
!             break;
!         }
! 
!         item->mName = AAtomizer::Atomize(name);
          item->mType = static_cast<Type>(parcel.readInt32());
          switch (item->mType) {
              case kTypeInt32:
              {
--- 453,465 ----
      sp<AMessage> msg = new AMessage(what);
  
      msg->mNumItems = static_cast<size_t>(parcel.readInt32());
  
      for (size_t i = 0; i < msg->mNumItems; ++i) {
          Item *item = &msg->mItems[i];
  
!         item->mName = AAtomizer::Atomize(parcel.readCString());
          item->mType = static_cast<Type>(parcel.readInt32());
+ 
          switch (item->mType) {
              case kTypeInt32:
              {
***************
*** 503,518 ****
  
              case kTypeString:
              {
!                 const char *stringValue = parcel.readCString();
!                 if (stringValue == NULL) {
!                     ALOGE("Failed reading string value from a parcel. "
!                         "Parsing aborted.");
!                     msg->mNumItems = i;
!                     continue;
!                     // The loop will terminate subsequently.
!                 } else {
!                     item->u.stringValue = new AString(stringValue);
!                 }
                  break;
              }
  
--- 493,499 ----
  
              case kTypeString:
              {
!                 item->u.stringValue = new AString(parcel.readCString());
                  break;
              }
  
diff '--exclude=.git' -crB a/media/libstagefright/foundation/base64.cpp b/media/libstagefright/foundation/base64.cpp
*** a/media/libstagefright/foundation/base64.cpp	2018-09-22 10:19:51.765278227 +0200
--- b/media/libstagefright/foundation/base64.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 22,32 ****
  namespace android {
  
  sp<ABuffer> decodeBase64(const AString &s) {
!     size_t n = s.size();
!     if ((n % 4) != 0) {
          return NULL;
      }
  
      size_t padding = 0;
      if (n >= 1 && s.c_str()[n - 1] == '=') {
          padding = 1;
--- 22,32 ----
  namespace android {
  
  sp<ABuffer> decodeBase64(const AString &s) {
!     if ((s.size() % 4) != 0) {
          return NULL;
      }
  
+     size_t n = s.size();
      size_t padding = 0;
      if (n >= 1 && s.c_str()[n - 1] == '=') {
          padding = 1;
***************
*** 36,51 ****
          }
      }
  
!     // We divide first to avoid overflow. It's OK to do this because we
!     // already made sure that n % 4 == 0.
!     size_t outLen = (n / 4) * 3 - padding;
  
      sp<ABuffer> buffer = new ABuffer(outLen);
  
      uint8_t *out = buffer->data();
-     if (out == NULL || buffer->size() < outLen) {
-         return NULL;
-     }
      size_t j = 0;
      uint32_t accum = 0;
      for (size_t i = 0; i < n; ++i) {
--- 36,46 ----
          }
      }
  
!     size_t outLen = 3 * s.size() / 4 - padding;
  
      sp<ABuffer> buffer = new ABuffer(outLen);
  
      uint8_t *out = buffer->data();
      size_t j = 0;
      uint32_t accum = 0;
      for (size_t i = 0; i < n; ++i) {
diff '--exclude=.git' -crB a/media/libstagefright/id3/ID3.cpp b/media/libstagefright/id3/ID3.cpp
*** a/media/libstagefright/id3/ID3.cpp	2018-09-22 10:19:51.765278227 +0200
--- b/media/libstagefright/id3/ID3.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 194,206 ****
  
      if (header.version_major == 4) {
          void *copy = malloc(size);
-         if (copy == NULL) {
-             free(mData);
-             mData = NULL;
-             ALOGE("b/24623447, no more memory");
-             return false;
-         }
- 
          memcpy(copy, mData, size);
  
          bool success = removeUnsynchronizationV2_4(false /* iTunesHack */);
--- 194,199 ----
***************
*** 241,254 ****
              return false;
          }
  
!         size_t extendedHeaderSize = U32_AT(&mData[0]);
!         if (extendedHeaderSize > SIZE_MAX - 4) {
!             free(mData);
!             mData = NULL;
!             ALOGE("b/24623447, extendedHeaderSize is too large");
!             return false;
!         }
!         extendedHeaderSize += 4;
  
          if (extendedHeaderSize > mSize) {
              free(mData);
--- 234,240 ----
              return false;
          }
  
!         size_t extendedHeaderSize = U32_AT(&mData[0]) + 4;
  
          if (extendedHeaderSize > mSize) {
              free(mData);
***************
*** 266,275 ****
              if (extendedHeaderSize >= 10) {
                  size_t paddingSize = U32_AT(&mData[6]);
  
!                 if (paddingSize > SIZE_MAX - mFirstFrameOffset) {
!                     ALOGE("b/24623447, paddingSize is too large");
!                 }
!                 if (paddingSize > mSize - mFirstFrameOffset) {
                      free(mData);
                      mData = NULL;
  
--- 252,258 ----
              if (extendedHeaderSize >= 10) {
                  size_t paddingSize = U32_AT(&mData[6]);
  
!                 if (mFirstFrameOffset + paddingSize > mSize) {
                      free(mData);
                      mData = NULL;
  
***************
*** 344,350 ****
      size_t oldSize = mSize;
  
      size_t offset = 0;
!     while (mSize >= 10 && offset <= mSize - 10) {
          if (!memcmp(&mData[offset], "\0\0\0\0", 4)) {
              break;
          }
--- 327,333 ----
      size_t oldSize = mSize;
  
      size_t offset = 0;
!     while (offset + 10 <= mSize) {
          if (!memcmp(&mData[offset], "\0\0\0\0", 4)) {
              break;
          }
***************
*** 356,362 ****
              return false;
          }
  
!         if (dataSize > mSize - 10 - offset) {
              return false;
          }
  
--- 339,345 ----
              return false;
          }
  
!         if (offset + dataSize + 10 > mSize) {
              return false;
          }
  
***************
*** 366,374 ****
          if (flags & 1) {
              // Strip data length indicator
  
-             if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {
-                 return false;
-             }
              memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);
              mSize -= 4;
              dataSize -= 4;
--- 349,354 ----
***************
*** 567,575 ****
          return;
      }
  
-     if (mFrameSize < getHeaderLength() + 1) {
-         return;
-     }
      size_t n = mFrameSize - getHeaderLength() - 1;
      if (otherdata) {
          // skip past the encoding, language, and the 0 separator
--- 547,552 ----
***************
*** 676,686 ****
  
              mFrameSize += 6;
  
-             // Prevent integer overflow in validation
-             if (SIZE_MAX - mOffset <= mFrameSize) {
-                 return;
-             }
- 
              if (mOffset + mFrameSize > mParent.mSize) {
                  ALOGV("partial frame at offset %d (size = %d, bytes-remaining = %d)",
                       mOffset, mFrameSize, mParent.mSize - mOffset - 6);
--- 653,658 ----
***************
*** 710,716 ****
                  return;
              }
  
!             size_t baseSize = 0;
              if (mParent.mVersion == ID3_V2_4) {
                  if (!ParseSyncsafeInteger(
                              &mParent.mData[mOffset + 4], &baseSize)) {
--- 682,688 ----
                  return;
              }
  
!             size_t baseSize;
              if (mParent.mVersion == ID3_V2_4) {
                  if (!ParseSyncsafeInteger(
                              &mParent.mData[mOffset + 4], &baseSize)) {
***************
*** 720,740 ****
                  baseSize = U32_AT(&mParent.mData[mOffset + 4]);
              }
  
!             if (baseSize == 0) {
!                 return;
!             }
! 
!             // Prevent integer overflow when adding
!             if (SIZE_MAX - 10 <= baseSize) {
!                 return;
!             }
! 
!             mFrameSize = 10 + baseSize; // add tag id, size field and flags
! 
!             // Prevent integer overflow in validation
!             if (SIZE_MAX - mOffset <= mFrameSize) {
!                 return;
!             }
  
              if (mOffset + mFrameSize > mParent.mSize) {
                  ALOGV("partial frame at offset %d (size = %d, bytes-remaining = %d)",
--- 692,698 ----
                  baseSize = U32_AT(&mParent.mData[mOffset + 4]);
              }
  
!             mFrameSize = 10 + baseSize;
  
              if (mOffset + mFrameSize > mParent.mSize) {
                  ALOGV("partial frame at offset %d (size = %d, bytes-remaining = %d)",
***************
*** 867,878 ****
  
              size_t descLen = StringSize(&data[2 + mimeLen], encoding);
  
-             if (size < 2 ||
-                     size - 2 < mimeLen ||
-                     size - 2 - mimeLen < descLen) {
-                 ALOGW("bogus album art sizes");
-                 return NULL;
-             }
              *length = size - 2 - mimeLen - descLen;
  
              return &data[2 + mimeLen + descLen];
--- 825,830 ----
diff '--exclude=.git' -crB a/media/libstagefright/include/NuCachedSource2.h b/media/libstagefright/include/NuCachedSource2.h
*** a/media/libstagefright/include/NuCachedSource2.h	2018-09-22 10:19:51.765278227 +0200
--- b/media/libstagefright/include/NuCachedSource2.h	2018-09-22 10:11:05.452312621 +0200
***************
*** 28,34 ****
  struct PageCache;
  
  struct NuCachedSource2 : public DataSource {
!     static sp<NuCachedSource2> Create(
              const sp<DataSource> &source,
              const char *cacheConfig = NULL,
              bool disconnectAtHighwatermark = false);
--- 28,34 ----
  struct PageCache;
  
  struct NuCachedSource2 : public DataSource {
!     NuCachedSource2(
              const sp<DataSource> &source,
              const char *cacheConfig = NULL,
              bool disconnectAtHighwatermark = false);
***************
*** 76,86 ****
  private:
      friend struct AHandlerReflector<NuCachedSource2>;
  
-     NuCachedSource2(
-             const sp<DataSource> &source,
-             const char *cacheConfig,
-             bool disconnectAtHighwatermark);
- 
      enum {
          kPageSize                       = 65536,
          kDefaultHighWaterThreshold      = 20 * 1024 * 1024,
--- 76,81 ----
diff '--exclude=.git' -crB a/media/libstagefright/include/OMX.h b/media/libstagefright/include/OMX.h
*** a/media/libstagefright/include/OMX.h	2018-09-22 10:19:51.765278227 +0200
--- b/media/libstagefright/include/OMX.h	2018-09-22 10:11:05.452312621 +0200
***************
*** 77,83 ****
  
      virtual status_t useBuffer(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer, OMX_BOOL crossProcess);
  
  #ifdef MTK_HARDWARE
      virtual status_t useBuffer(
--- 77,83 ----
  
      virtual status_t useBuffer(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer);
  
  #ifdef MTK_HARDWARE
      virtual status_t useBuffer(
***************
*** 119,125 ****
  
      virtual status_t allocateBufferWithBackup(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer, OMX_BOOL crossProcess);
  
      virtual status_t freeBuffer(
              node_id node, OMX_U32 port_index, buffer_id buffer);
--- 119,125 ----
  
      virtual status_t allocateBufferWithBackup(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer);
  
      virtual status_t freeBuffer(
              node_id node, OMX_U32 port_index, buffer_id buffer);
***************
*** 146,153 ****
  
      virtual void binderDied(const wp<IBinder> &the_late_who);
  
-     virtual bool isSecure(IOMX::node_id node);
- 
      OMX_ERRORTYPE OnEvent(
              node_id node,
              OMX_IN OMX_EVENTTYPE eEvent,
--- 146,151 ----
diff '--exclude=.git' -crB a/media/libstagefright/include/OMXNodeInstance.h b/media/libstagefright/include/OMXNodeInstance.h
*** a/media/libstagefright/include/OMXNodeInstance.h	2018-09-22 10:19:51.765278227 +0200
--- b/media/libstagefright/include/OMXNodeInstance.h	2018-09-22 10:11:05.452312621 +0200
***************
*** 21,27 ****
  #include "OMX.h"
  
  #include <utils/RefBase.h>
- #include <utils/SortedVector.h>
  #include <utils/threads.h>
  
  namespace android {
--- 21,26 ----
***************
*** 40,46 ****
  #endif
  
      OMXNodeInstance(
!             OMX *owner, const sp<IOMXObserver> &observer, const char *name);
  
      void setHandle(OMX::node_id node_id, OMX_HANDLETYPE handle);
  
--- 39,45 ----
  #endif
  
      OMXNodeInstance(
!             OMX *owner, const sp<IOMXObserver> &observer);
  
      void setHandle(OMX::node_id node_id, OMX_HANDLETYPE handle);
  
***************
*** 73,79 ****
  
      status_t useBuffer(
              OMX_U32 portIndex, const sp<IMemory> &params,
!             OMX::buffer_id *buffer, OMX_BOOL crossProcess);
  
      status_t useGraphicBuffer(
              OMX_U32 portIndex, const sp<GraphicBuffer> &graphicBuffer,
--- 72,78 ----
  
      status_t useBuffer(
              OMX_U32 portIndex, const sp<IMemory> &params,
!             OMX::buffer_id *buffer);
  
      status_t useGraphicBuffer(
              OMX_U32 portIndex, const sp<GraphicBuffer> &graphicBuffer,
***************
*** 113,119 ****
  
      status_t allocateBufferWithBackup(
              OMX_U32 portIndex, const sp<IMemory> &params,
!             OMX::buffer_id *buffer, OMX_BOOL crossProcess);
  
      status_t freeBuffer(OMX_U32 portIndex, OMX::buffer_id buffer);
  
--- 112,118 ----
  
      status_t allocateBufferWithBackup(
              OMX_U32 portIndex, const sp<IMemory> &params,
!             OMX::buffer_id *buffer);
  
      status_t freeBuffer(OMX_U32 portIndex, OMX::buffer_id buffer);
  
***************
*** 138,147 ****
              const void *data,
              size_t size);
  
-     bool isSecure() const {
-         return mIsSecure;
-     }
- 
      void onMessage(const omx_message &msg);
      void onObserverDied(OMXMaster *master);
      void onGetHandleFailed();
--- 137,142 ----
***************
*** 160,169 ****
      OMXNodeInstanceBufferHandler *mMtkBufferHandler;
  #endif
      bool mDying;
-     bool mSailed;  // configuration is set (no more meta-mode changes)
-     bool mQueriedProhibitedExtensions;
-     SortedVector<OMX_INDEXTYPE> mProhibitedExtensions;
-     bool mIsSecure;
  
      // Lock only covers mGraphicBufferSource.  We can't always use mLock
      // because of rare instances where we'd end up locking it recursively.
--- 155,160 ----
***************
*** 178,194 ****
      };
      Vector<ActiveBuffer> mActiveBuffers;
  
-     // metadata mode tracking
-     bool mUsingMetadata[2];
- 
      ~OMXNodeInstance();
  
      void addActiveBuffer(OMX_U32 portIndex, OMX::buffer_id id);
      void removeActiveBuffer(OMX_U32 portIndex, OMX::buffer_id id);
      void freeActiveBuffers();
- 
-     bool isProhibitedIndex_l(OMX_INDEXTYPE index);
- 
      status_t useGraphicBuffer2_l(
              OMX_U32 portIndex, const sp<GraphicBuffer> &graphicBuffer,
              OMX::buffer_id *buffer);
--- 169,179 ----
diff '--exclude=.git' -crB a/media/libstagefright/include/SampleTable.h b/media/libstagefright/include/SampleTable.h
*** a/media/libstagefright/include/SampleTable.h	2018-09-22 10:19:51.765278227 +0200
--- b/media/libstagefright/include/SampleTable.h	2018-09-22 10:11:05.452312621 +0200
***************
*** 24,30 ****
  #include <media/stagefright/MediaErrors.h>
  #include <utils/RefBase.h>
  #include <utils/threads.h>
- #include <utils/Vector.h>
  
  namespace android {
  
--- 24,29 ----
***************
*** 95,103 ****
      static const uint32_t kSampleSizeType32;
      static const uint32_t kSampleSizeTypeCompact;
  
-     // Limit the total size of all internal tables to 200MiB.
-     static const size_t kMaxTotalSize = 200 * (1 << 20);
- 
      sp<DataSource> mDataSource;
      Mutex mLock;
  
--- 94,99 ----
***************
*** 113,121 ****
      uint32_t mDefaultSampleSize;
      uint32_t mNumSampleSizes;
  
-     bool mHasTimeToSample;
      uint32_t mTimeToSampleCount;
!     uint32_t* mTimeToSample;
  
      struct SampleTimeEntry {
          uint32_t mSampleIndex;
--- 109,116 ----
      uint32_t mDefaultSampleSize;
      uint32_t mNumSampleSizes;
  
      uint32_t mTimeToSampleCount;
!     uint32_t *mTimeToSample;
  
      struct SampleTimeEntry {
          uint32_t mSampleIndex;
***************
*** 141,149 ****
      };
      SampleToChunkEntry *mSampleToChunkEntries;
  
-     // Approximate size of all tables combined.
-     uint64_t mTotalSize;
- 
      friend struct SampleIterator;
  
      // normally we don't round
--- 136,141 ----
diff '--exclude=.git' -crB a/media/libstagefright/include/SoftOMXComponent.h b/media/libstagefright/include/SoftOMXComponent.h
*** a/media/libstagefright/include/SoftOMXComponent.h	2018-09-22 10:19:51.765278227 +0200
--- b/media/libstagefright/include/SoftOMXComponent.h	2018-09-22 10:11:05.452312621 +0200
***************
*** 18,25 ****
  
  #define SOFT_OMX_COMPONENT_H_
  
- #include <log/log.h>
- 
  #include <media/stagefright/foundation/ABase.h>
  #include <media/stagefright/foundation/AString.h>
  #include <utils/RefBase.h>
--- 18,23 ----
***************
*** 170,223 ****
      DISALLOW_EVIL_CONSTRUCTORS(SoftOMXComponent);
  };
  
- // minimal implementations of is_same and static_assert that work on K,
- // though error messages are minimal
- 
- // a type that has a member constant of a specified type and value
- template<typename T, T somevalue>
- struct compat_integral_constant
- {
-     static const T value = somevalue;
- };
- 
- // types to hold true and false
- typedef compat_integral_constant<bool, true> compat_true_type;
- typedef compat_integral_constant<bool, false> compat_false_type;
- 
- // a type that indicates two other types are different
- template<typename, typename> struct compat_is_same : public compat_false_type { };
- 
- // a type that indicates two other types are the same
- template<typename sametype> struct compat_is_same<sametype, sametype> : public compat_true_type { };
- // for the specific use below, we want to consider "const type" and "type" to be the same
- template<typename sametype> struct compat_is_same<const sametype, sametype> : public compat_true_type { };
- 
- 
- // Compile time assert. Note that the message is ignored. Instead, the
- // compiler will report a division by zero and/or a non-constant expression
- // when the assertion triggers.
- #define STATIC_ASSERT(e, m) \
-     do { \
-         enum { STATIC_ASSERT__ = 1/(e) }; \
-     } while (0)
- 
- template<typename T>
- bool isValidOMXParam(T *a) {
-   STATIC_ASSERT(offsetof(typeof(*a), nSize) == 0, "nSize not at offset 0");
-   const bool isSame1 = compat_is_same<typeof(a->nSize), OMX_U32>::value;
-   STATIC_ASSERT(isSame1, "nSize has wrong type");
-   STATIC_ASSERT(offsetof(typeof(*a), nVersion) == 4, "nVersion not at offset 4");
-   const bool isSame2 = compat_is_same<typeof(a->nVersion), OMX_VERSIONTYPE>::value;
-   STATIC_ASSERT(isSame2, "nVersion has wrong type");
- 
-   if (a->nSize < sizeof(*a)) {
-       ALOGE("b/27207275: need %zu, got %lu", sizeof(*a), a->nSize);
-       android_errorWriteLog(0x534e4554, "27207275");
-       return false;
-   }
-   return true;
- }
- 
  }  // namespace android
  
  #endif  // SOFT_OMX_COMPONENT_H_
--- 168,173 ----
diff '--exclude=.git' -crB a/media/libstagefright/matroska/MatroskaExtractor.cpp b/media/libstagefright/matroska/MatroskaExtractor.cpp
*** a/media/libstagefright/matroska/MatroskaExtractor.cpp	2018-09-22 10:19:51.769278234 +0200
--- b/media/libstagefright/matroska/MatroskaExtractor.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 26,32 ****
  #include "mkvparser.hpp"
  
  #include <media/stagefright/foundation/ADebug.h>
- #include <media/stagefright/foundation/AUtils.h>
  #include <media/stagefright/foundation/hexdump.h>
  #include <media/stagefright/DataSource.h>
  #include <media/stagefright/MediaBuffer.h>
--- 26,31 ----
***************
*** 624,635 ****
                      TRESPASS();
              }
  
!             if (srcOffset + mNALSizeLen + NALsize <= srcOffset + mNALSizeLen) {
!                 frame->release();
!                 frame = NULL;
! 
!                 return ERROR_MALFORMED;
!             } else if (srcOffset + mNALSizeLen + NALsize > srcSize) {
                  break;
              }
  
--- 623,629 ----
                      TRESPASS();
              }
  
!             if (srcOffset + mNALSizeLen + NALsize > srcSize) {
                  break;
              }
  
***************
*** 899,936 ****
      size_t offset = 1;
      size_t len1 = 0;
      while (offset < codecPrivateSize && codecPrivate[offset] == 0xff) {
-         if (len1 > (SIZE_MAX - 0xff)) {
-             return ERROR_MALFORMED; // would overflow
-         }
          len1 += 0xff;
          ++offset;
      }
      if (offset >= codecPrivateSize) {
          return ERROR_MALFORMED;
      }
-     if (len1 > (SIZE_MAX - codecPrivate[offset])) {
-         return ERROR_MALFORMED; // would overflow
-     }
      len1 += codecPrivate[offset++];
  
      size_t len2 = 0;
      while (offset < codecPrivateSize && codecPrivate[offset] == 0xff) {
-         if (len2 > (SIZE_MAX - 0xff)) {
-             return ERROR_MALFORMED; // would overflow
-         }
          len2 += 0xff;
          ++offset;
      }
      if (offset >= codecPrivateSize) {
          return ERROR_MALFORMED;
      }
-     if (len2 > (SIZE_MAX - codecPrivate[offset])) {
-         return ERROR_MALFORMED; // would overflow
-     }
      len2 += codecPrivate[offset++];
  
!     if (len1 > SIZE_MAX - len2 || offset > SIZE_MAX - (len1 + len2) ||
!             codecPrivateSize < offset + len1 + len2) {
          return ERROR_MALFORMED;
      }
  
--- 893,917 ----
      size_t offset = 1;
      size_t len1 = 0;
      while (offset < codecPrivateSize && codecPrivate[offset] == 0xff) {
          len1 += 0xff;
          ++offset;
      }
      if (offset >= codecPrivateSize) {
          return ERROR_MALFORMED;
      }
      len1 += codecPrivate[offset++];
  
      size_t len2 = 0;
      while (offset < codecPrivateSize && codecPrivate[offset] == 0xff) {
          len2 += 0xff;
          ++offset;
      }
      if (offset >= codecPrivateSize) {
          return ERROR_MALFORMED;
      }
      len2 += codecPrivate[offset++];
  
!     if (codecPrivateSize < offset + len1 + len2) {
          return ERROR_MALFORMED;
      }
  
diff '--exclude=.git' -crB a/media/libstagefright/MetaData.cpp b/media/libstagefright/MetaData.cpp
*** a/media/libstagefright/MetaData.cpp	2018-09-22 10:19:51.673278059 +0200
--- b/media/libstagefright/MetaData.cpp	2018-09-22 10:11:05.444312607 +0200
***************
*** 233,243 ****
  MetaData::typed_data::typed_data(const typed_data &from)
      : mType(from.mType),
        mSize(0) {
! 
!     void *dst = allocateStorage(from.mSize);
!     if (dst) {
!         memcpy(dst, from.storage(), mSize);
!     }
  }
  
  MetaData::typed_data &MetaData::typed_data::operator=(
--- 233,240 ----
  MetaData::typed_data::typed_data(const typed_data &from)
      : mType(from.mType),
        mSize(0) {
!     allocateStorage(from.mSize);
!     memcpy(storage(), from.storage(), mSize);
  }
  
  MetaData::typed_data &MetaData::typed_data::operator=(
***************
*** 245,254 ****
      if (this != &from) {
          clear();
          mType = from.mType;
!         void *dst = allocateStorage(from.mSize);
!         if (dst) {
!             memcpy(dst, from.storage(), mSize);
!         }
      }
  
      return *this;
--- 242,249 ----
      if (this != &from) {
          clear();
          mType = from.mType;
!         allocateStorage(from.mSize);
!         memcpy(storage(), from.storage(), mSize);
      }
  
      return *this;
***************
*** 265,275 ****
      clear();
  
      mType = type;
! 
!     void *dst = allocateStorage(size);
!     if (dst) {
!         memcpy(dst, data, size);
!     }
  }
  
  void MetaData::typed_data::getData(
--- 260,267 ----
      clear();
  
      mType = type;
!     allocateStorage(size);
!     memcpy(storage(), data, size);
  }
  
  void MetaData::typed_data::getData(
***************
*** 279,297 ****
      *data = storage();
  }
  
! void *MetaData::typed_data::allocateStorage(size_t size) {
      mSize = size;
  
      if (usesReservoir()) {
!         return &u.reservoir;
      }
  
      u.ext_data = malloc(mSize);
-     if (u.ext_data == NULL) {
-         ALOGE("Couldn't allocate %zu bytes for item", size);
-         mSize = 0;
-     }
-     return u.ext_data;
  }
  
  void MetaData::typed_data::freeStorage() {
--- 271,284 ----
      *data = storage();
  }
  
! void MetaData::typed_data::allocateStorage(size_t size) {
      mSize = size;
  
      if (usesReservoir()) {
!         return;
      }
  
      u.ext_data = malloc(mSize);
  }
  
  void MetaData::typed_data::freeStorage() {
diff '--exclude=.git' -crB a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
*** a/media/libstagefright/MPEG4Extractor.cpp	2018-09-22 10:19:51.673278059 +0200
--- b/media/libstagefright/MPEG4Extractor.cpp	2018-09-22 10:11:05.444312607 +0200
***************
*** 26,33 ****
  #include "include/ESDS.h"
  
  #include <ctype.h>
- #define __STDC_FORMAT_MACROS 1
- #include <inttypes.h>
  #include <stdint.h>
  #include <stdlib.h>
  #include <string.h>
--- 26,31 ----
***************
*** 36,42 ****
  #include <media/stagefright/foundation/ABuffer.h>
  #include <media/stagefright/foundation/ADebug.h>
  #include <media/stagefright/foundation/AMessage.h>
- #include <media/stagefright/foundation/AUtils.h>
  #include <media/stagefright/MediaBuffer.h>
  #include <media/stagefright/MediaBufferGroup.h>
  #include <media/stagefright/MediaDefs.h>
--- 34,39 ----
***************
*** 48,65 ****
  #include "include/ExtendedUtils.h"
  #endif
  
- #ifndef UINT32_MAX
- #define UINT32_MAX       (4294967295U)
- #endif
- 
  namespace android {
  
- enum {
-     // maximum size of an atom. Some atoms can be bigger according to the spec,
-     // but we only allow up to this size.
-     kMaxAtomSize = 64 * 1024 * 1024,
- };
- 
  class MPEG4Source : public MediaSource {
  public:
      // Caller retains ownership of both "dataSource" and "sampleTable".
--- 45,52 ----
***************
*** 234,240 ****
  ssize_t MPEG4DataSource::readAt(off64_t offset, void *data, size_t size) {
      Mutex::Autolock autoLock(mLock);
  
!     if (isInRange(mCachedOffset, mCachedSize, offset, size)) {
          memcpy(data, &mCache[offset - mCachedOffset], size);
          return size;
      }
--- 221,228 ----
  ssize_t MPEG4DataSource::readAt(off64_t offset, void *data, size_t size) {
      Mutex::Autolock autoLock(mLock);
  
!     if (offset >= mCachedOffset
!             && offset + size <= mCachedOffset + mCachedSize) {
          memcpy(data, &mCache[offset - mCachedOffset], size);
          return size;
      }
***************
*** 430,436 ****
      SINF *sinf = mFirstSINF;
      while (sinf) {
          SINF *next = sinf->next;
!         delete[] sinf->IPMPData;
          delete sinf;
          sinf = next;
      }
--- 418,424 ----
      SINF *sinf = mFirstSINF;
      while (sinf) {
          SINF *next = sinf->next;
!         delete sinf->IPMPData;
          delete sinf;
          sinf = next;
      }
***************
*** 585,594 ****
      }
      if (psshsize) {
          char *buf = (char*)malloc(psshsize);
-         if (!buf) {
-             ALOGE("b/28471206");
-             return NO_MEMORY;
-         }
          char *ptr = buf;
          for (size_t i = 0; i < mPssh.size(); i++) {
              memcpy(ptr, mPssh[i].uuid, 20); // uuid + length
--- 573,578 ----
***************
*** 751,761 ****
                  return ERROR_MALFORMED;
              }
              sinf->len = dataLen - 3;
!             sinf->IPMPData = new (std::nothrow) char[sinf->len];
!             if (sinf->IPMPData == NULL) {
!                 return ERROR_MALFORMED;
!             }
!             data_offset += 2;
  
              if (mDataSource->readAt(data_offset + 2, sinf->IPMPData, sinf->len) < sinf->len) {
                  return ERROR_IO;
--- 735,741 ----
                  return ERROR_MALFORMED;
              }
              sinf->len = dataLen - 3;
!             sinf->IPMPData = new char[sinf->len];
  
              if (mDataSource->readAt(data_offset + 2, sinf->IPMPData, sinf->len) < sinf->len) {
                  return ERROR_IO;
***************
*** 859,871 ****
      PathAdder autoAdder(&mPath, chunk_type);
  
      off64_t chunk_data_size = *offset + chunk_size - data_offset;
-     if (chunk_type != FOURCC('m', 'd', 'a', 't') && chunk_data_size > kMaxAtomSize) {
-         char errMsg[100];
-         sprintf(errMsg, "%s atom has size %" PRId64, chunk, chunk_data_size);
-         ALOGE("%s (b/28615448)", errMsg);
-         android_errorWriteWithInfoLog(0x534e4554, "28615448", -1, errMsg, strlen(errMsg));
-         return ERROR_MALFORMED;
-     }
  
      if (chunk_type != FOURCC('c', 'p', 'r', 't')
              && chunk_type != FOURCC('c', 'o', 'v', 'r')
--- 839,844 ----
***************
*** 954,964 ****
              }
  
              if (isTrack) {
-                 int32_t trackId;
-                 // There must be exact one track header per track.
-                 if (!mLastTrack->meta->findInt32(kKeyTrackID, &trackId)) {
-                     mLastTrack->skipTrack = true;
-                 }
                  if (mLastTrack->skipTrack) {
                      Track *cur = mFirstTrack;
  
--- 927,932 ----
***************
*** 1161,1170 ****
                  return ERROR_MALFORMED;
              }
  
!             pssh.data = new (std::nothrow) uint8_t[pssh.datalen];
!             if (pssh.data == NULL) {
!                 return ERROR_MALFORMED;
!             }
              ALOGV("allocated pssh @ %p", pssh.data);
              ssize_t requested = (ssize_t) pssh.datalen;
              if (mDataSource->readAt(data_offset + 24, pssh.data, requested) < requested) {
--- 1129,1135 ----
                  return ERROR_MALFORMED;
              }
  
!             pssh.data = new uint8_t[pssh.datalen];
              ALOGV("allocated pssh @ %p", pssh.data);
              ssize_t requested = (ssize_t) pssh.datalen;
              if (mDataSource->readAt(data_offset + 24, pssh.data, requested) < requested) {
***************
*** 1497,1523 ****
                  // each chunk originally prefixed with a 2 byte length will
                  // have a 4 byte header (0x00 0x00 0x00 0x01) after conversion,
                  // and thus will grow by 2 bytes per chunk.
-                 if (max_size > SIZE_MAX - 10 * 2) {
-                     ALOGE("max sample size too big: %zu", max_size);
-                     return ERROR_MALFORMED;
-                 }
                  mLastTrack->meta->setInt32(kKeyMaxInputSize, max_size + 10 * 2);
              } else {
                  // No size was specified. Pick a conservatively large size.
!                 uint32_t width, height;
!                 if (!mLastTrack->meta->findInt32(kKeyWidth, (int32_t*)&width) ||
!                     !mLastTrack->meta->findInt32(kKeyHeight,(int32_t*) &height)) {
                      ALOGE("No width or height, assuming worst case 1080p");
                      width = 1920;
                      height = 1080;
-                 } else {
-                     // A resolution was specified, check that it's not too big. The values below
-                     // were chosen so that the calculations below don't cause overflows, they're
-                     // not indicating that resolutions up to 32kx32k are actually supported.
-                     if (width > 32768 || height > 32768) {
-                         ALOGE("can't support %u x %u video", width, height);
-                         return ERROR_MALFORMED;
-                     }
                  }
  
                  const char *mime;
--- 1462,1476 ----
                  // each chunk originally prefixed with a 2 byte length will
                  // have a 4 byte header (0x00 0x00 0x00 0x01) after conversion,
                  // and thus will grow by 2 bytes per chunk.
                  mLastTrack->meta->setInt32(kKeyMaxInputSize, max_size + 10 * 2);
              } else {
                  // No size was specified. Pick a conservatively large size.
!                 int32_t width, height;
!                 if (!mLastTrack->meta->findInt32(kKeyWidth, &width) ||
!                     !mLastTrack->meta->findInt32(kKeyHeight, &height)) {
                      ALOGE("No width or height, assuming worst case 1080p");
                      width = 1920;
                      height = 1080;
                  }
  
                  const char *mime;
***************
*** 1697,1707 ****
          {
              sp<ABuffer> buffer = new ABuffer(chunk_data_size);
  
-             if (buffer->data() == NULL) {
-                 ALOGE("b/28471206");
-                 return NO_MEMORY;
-             }
- 
              if (mDataSource->readAt(
                          data_offset, buffer->data(), chunk_data_size) < chunk_data_size) {
                  return ERROR_IO;
--- 1650,1655 ----
***************
*** 1877,1889 ****
                  size = 0;
              }
  
!             if ((chunk_size > SIZE_MAX) || (SIZE_MAX - chunk_size <= size)) {
!                 return ERROR_MALFORMED;
!             }
!             uint8_t *buffer = new (std::nothrow) uint8_t[size + chunk_size];
!             if (buffer == NULL) {
!                 return ERROR_MALFORMED;
!             }
  
              if (size > 0) {
                  memcpy(buffer, data, size);
--- 1825,1831 ----
                  size = 0;
              }
  
!             uint8_t *buffer = new uint8_t[size + chunk_size];
  
              if (size > 0) {
                  memcpy(buffer, data, size);
***************
*** 1911,1934 ****
              if (mFileMetaData != NULL) {
                  ALOGV("chunk_data_size = %lld and data_offset = %lld",
                          chunk_data_size, data_offset);
- 
-                 if (chunk_data_size < 0 || static_cast<uint64_t>(chunk_data_size) >= SIZE_MAX - 1) {
-                     return ERROR_MALFORMED;
-                 }
                  sp<ABuffer> buffer = new ABuffer(chunk_data_size + 1);
-                 if (buffer->data() == NULL) {
-                     ALOGE("b/28471206");
-                     return NO_MEMORY;
-                 }
                  if (mDataSource->readAt(
                      data_offset, buffer->data(), chunk_data_size) != (ssize_t)chunk_data_size) {
                      return ERROR_IO;
                  }
                  const int kSkipBytesOfDataBox = 16;
-                 if (chunk_data_size <= kSkipBytesOfDataBox) {
-                     return ERROR_MALFORMED;
-                 }
- 
                  mFileMetaData->setData(
                      kKeyAlbumArt, MetaData::TYPE_NONE,
                      buffer->data() + kSkipBytesOfDataBox, chunk_data_size - kSkipBytesOfDataBox);
--- 1853,1864 ----
***************
*** 2173,2186 ****
  }
  
  status_t MPEG4Extractor::parseMetaData(off64_t offset, size_t size) {
!     if (size < 4 || size == SIZE_MAX) {
          return ERROR_MALFORMED;
      }
  
!     uint8_t *buffer = new (std::nothrow) uint8_t[size + 1];
!     if (buffer == NULL) {
!         return ERROR_MALFORMED;
!     }
      if (mDataSource->readAt(
                  offset, buffer, size) != (ssize_t)size) {
          delete[] buffer;
--- 2103,2113 ----
  }
  
  status_t MPEG4Extractor::parseMetaData(off64_t offset, size_t size) {
!     if (size < 4) {
          return ERROR_MALFORMED;
      }
  
!     uint8_t *buffer = new uint8_t[size + 1];
      if (mDataSource->readAt(
                  offset, buffer, size) != (ssize_t)size) {
          delete[] buffer;
***************
*** 2287,2298 ****
                      mLastCommentName.setTo((const char *)buffer + 4);
                      break;
                  case FOURCC('d', 'a', 't', 'a'):
-                     if (size < 8) {
-                         delete[] buffer;
-                         buffer = NULL;
-                         ALOGE("b/24346430");
-                         return ERROR_MALFORMED;
-                     }
                      mLastCommentData.setTo((const char *)buffer + 8);
                      break;
              }
--- 2214,2219 ----
***************
*** 2676,2701 ****
          mWantsNALFragments = false;
      }
  
-     int32_t tmp;
-     CHECK(mFormat->findInt32(kKeyMaxInputSize, &tmp));
-     size_t max_size = tmp;
- 
-     // A somewhat arbitrary limit that should be sufficient for 8k video frames
-     // If you see the message below for a valid input stream: increase the limit
-     if (max_size > 64 * 1024 * 1024) {
-         ALOGE("bogus max input size: %zu", max_size);
-         return ERROR_MALFORMED;
-     }
      mGroup = new MediaBufferGroup;
      mGroup->add_buffer(new MediaBuffer(max_size));
  
!     mSrcBuffer = new (std::nothrow) uint8_t[max_size];
!     if (mSrcBuffer == NULL) {
!         // file probably specified a bad max size
!         delete mGroup;
!         mGroup = NULL;
!         return ERROR_MALFORMED;
!     }
  
      mStarted = true;
  
--- 2597,2610 ----
          mWantsNALFragments = false;
      }
  
      mGroup = new MediaBufferGroup;
+ 
+     int32_t max_size;
+     CHECK(mFormat->findInt32(kKeyMaxInputSize, &max_size));
+ 
      mGroup->add_buffer(new MediaBuffer(max_size));
  
!     mSrcBuffer = new uint8_t[max_size];
  
      mStarted = true;
  
***************
*** 2911,2937 ****
          return ERROR_IO;
      }
      offset += 4;
-     if (entrycount == 0) {
-         return OK;
-     }
-     if (entrycount > UINT32_MAX / 8) {
-         return ERROR_MALFORMED;
-     }
  
      if (entrycount > mCurrentSampleInfoOffsetsAllocSize) {
!         uint64_t *newPtr = (uint64_t *)realloc(mCurrentSampleInfoOffsets, entrycount * 8);
!         if (newPtr == NULL) {
!             return NO_MEMORY;
!         }
!         mCurrentSampleInfoOffsets = newPtr;
          mCurrentSampleInfoOffsetsAllocSize = entrycount;
      }
      mCurrentSampleInfoOffsetCount = entrycount;
  
-     if (mCurrentSampleInfoOffsets == NULL) {
-         return OK;
-     }
- 
      for (size_t i = 0; i < entrycount; i++) {
          if (version == 0) {
              uint32_t tmp;
--- 2820,2832 ----
          return ERROR_IO;
      }
      offset += 4;
  
      if (entrycount > mCurrentSampleInfoOffsetsAllocSize) {
!         mCurrentSampleInfoOffsets = (uint64_t*) realloc(mCurrentSampleInfoOffsets, entrycount * 8);
          mCurrentSampleInfoOffsetsAllocSize = entrycount;
      }
      mCurrentSampleInfoOffsetCount = entrycount;
  
      for (size_t i = 0; i < entrycount; i++) {
          if (version == 0) {
              uint32_t tmp;
***************
*** 2958,2974 ****
      int ivlength;
      CHECK(mFormat->findInt32(kKeyCryptoDefaultIVSize, &ivlength));
  
-     // only 0, 8 and 16 byte initialization vectors are supported
-     if (ivlength != 0 && ivlength != 8 && ivlength != 16) {
-         ALOGW("unsupported IV length: %d", ivlength);
-         return ERROR_MALFORMED;
-     }
      // read CencSampleAuxiliaryDataFormats
      for (size_t i = 0; i < mCurrentSampleInfoCount; i++) {
-         if (i >= mCurrentSamples.size()) {
-             ALOGW("too few samples");
-             break;
-         }
          Sample *smpl = &mCurrentSamples.editItemAt(i);
  
          memset(smpl->iv, 0, 16);
--- 2853,2860 ----
***************
*** 3413,3434 ****
              CHECK(mBuffer == NULL);
              return err;
          }
-         if (size > mBuffer->size()) {
-             ALOGE("buffer too small: %zu > %zu", size, mBuffer->size());
-             return ERROR_BUFFER_TOO_SMALL;
-         }
      }
  
      if (!mIsAVC || mWantsNALFragments) {
          if (newBuffer) {
-             if (!isInRange((size_t)0u, mBuffer->size(), size)) {
-                 mBuffer->release();
-                 mBuffer = NULL;
- 
-                 ALOGE("fragmentedRead ERROR_MALFORMED size %zu", size);
-                 return ERROR_MALFORMED;
-             }
- 
              ssize_t num_bytes_read =
                  mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size);
  
--- 3299,3308 ----
***************
*** 3476,3485 ****
              (const uint8_t *)mBuffer->data() + mBuffer->range_offset();
  
          size_t nal_size = parseNALSize(src);
!         if (mNALLengthSize > SIZE_MAX - nal_size) {
!             ALOGE("b/24441553, b/24445122");
!         }
!         if (mBuffer->range_length() - mNALLengthSize < nal_size) {
              ALOGE("incomplete NAL unit.");
  
              mBuffer->release();
--- 3350,3356 ----
              (const uint8_t *)mBuffer->data() + mBuffer->range_offset();
  
          size_t nal_size = parseNALSize(src);
!         if (mBuffer->range_length() < mNALLengthSize + nal_size) {
              ALOGE("incomplete NAL unit.");
  
              mBuffer->release();
***************
*** 3535,3546 ****
              size_t dstOffset = 0;
  
              while (srcOffset < size) {
!                 bool isMalFormed = !isInRange(0u, size, srcOffset, mNALLengthSize);
                  size_t nalLength = 0;
                  if (!isMalFormed) {
                      nalLength = parseNALSize(&mSrcBuffer[srcOffset]);
                      srcOffset += mNALLengthSize;
!                     isMalFormed = !isInRange(0u, size, srcOffset, nalLength);
                  }
  
                  if (isMalFormed) {
--- 3406,3417 ----
              size_t dstOffset = 0;
  
              while (srcOffset < size) {
!                 bool isMalFormed = (srcOffset + mNALLengthSize > size);
                  size_t nalLength = 0;
                  if (!isMalFormed) {
                      nalLength = parseNALSize(&mSrcBuffer[srcOffset]);
                      srcOffset += mNALLengthSize;
!                     isMalFormed = srcOffset + nalLength > size;
                  }
  
                  if (isMalFormed) {
***************
*** 3554,3568 ****
                      continue;
                  }
  
!                 if (dstOffset > SIZE_MAX - 4 ||
!                         dstOffset + 4 > SIZE_MAX - nalLength ||
!                         dstOffset + 4 + nalLength > mBuffer->size()) {
!                     ALOGE("b/27208621 : %zu %zu", dstOffset, mBuffer->size());
!                     android_errorWriteLog(0x534e4554, "27208621");
!                     mBuffer->release();
!                     mBuffer = NULL;
!                     return ERROR_MALFORMED;
!                 }
  
                  dstData[dstOffset++] = 0;
                  dstData[dstOffset++] = 0;
--- 3425,3431 ----
                      continue;
                  }
  
!                 CHECK(dstOffset + 4 <= mBuffer->size());
  
                  dstData[dstOffset++] = 0;
                  dstData[dstOffset++] = 0;
***************
*** 3685,3694 ****
              ALOGV("acquire_buffer returned %d", err);
              return err;
          }
-         if (size > mBuffer->size()) {
-             ALOGE("buffer too small: %zu > %zu", size, mBuffer->size());
-             return ERROR_BUFFER_TOO_SMALL;
-         }
      }
  
      const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex];
--- 3548,3553 ----
***************
*** 3715,3721 ****
                  mBuffer->release();
                  mBuffer = NULL;
  
!                 ALOGE("i/o error");
                  return ERROR_IO;
              }
  
--- 3574,3580 ----
                  mBuffer->release();
                  mBuffer = NULL;
  
!                 ALOGV("i/o error");
                  return ERROR_IO;
              }
  
***************
*** 3752,3762 ****
              (const uint8_t *)mBuffer->data() + mBuffer->range_offset();
  
          size_t nal_size = parseNALSize(src);
!         if (mNALLengthSize > SIZE_MAX - nal_size) {
!             ALOGE("b/24441553, b/24445122");
!         }
! 
!         if (mBuffer->range_length() - mNALLengthSize < nal_size) {
              ALOGE("incomplete NAL unit.");
  
              mBuffer->release();
--- 3611,3617 ----
              (const uint8_t *)mBuffer->data() + mBuffer->range_offset();
  
          size_t nal_size = parseNALSize(src);
!         if (mBuffer->range_length() < mNALLengthSize + nal_size) {
              ALOGE("incomplete NAL unit.");
  
              mBuffer->release();
***************
*** 3789,3828 ****
          ssize_t num_bytes_read = 0;
          int32_t drm = 0;
          bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);
-         void *data = NULL;
-         bool isMalFormed = false;
          if (usesDRM) {
!             if (mBuffer == NULL || !isInRange((size_t)0u, mBuffer->size(), size)) {
!                 isMalFormed = true;
!             } else {
!                 data = mBuffer->data();
!             }
          } else {
!             int32_t max_size;
!             if (mFormat == NULL
!                     || !mFormat->findInt32(kKeyMaxInputSize, &max_size)
!                     || !isInRange((size_t)0u, (size_t)max_size, size)) {
!                 isMalFormed = true;
!             } else {
!                 data = mSrcBuffer;
!             }
!         }
! 
!         if (isMalFormed || data == NULL) {
!             ALOGE("isMalFormed size %zu", size);
!             if (mBuffer != NULL) {
!                 mBuffer->release();
!                 mBuffer = NULL;
!             }
!             return ERROR_MALFORMED;
          }
-         num_bytes_read = mDataSource->readAt(offset, data, size);
  
          if (num_bytes_read < (ssize_t)size) {
              mBuffer->release();
              mBuffer = NULL;
  
!             ALOGE("i/o error");
              return ERROR_IO;
          }
  
--- 3644,3661 ----
          ssize_t num_bytes_read = 0;
          int32_t drm = 0;
          bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0);
          if (usesDRM) {
!             num_bytes_read =
!                 mDataSource->readAt(offset, (uint8_t*)mBuffer->data(), size);
          } else {
!             num_bytes_read = mDataSource->readAt(offset, mSrcBuffer, size);
          }
  
          if (num_bytes_read < (ssize_t)size) {
              mBuffer->release();
              mBuffer = NULL;
  
!             ALOGV("i/o error");
              return ERROR_IO;
          }
  
***************
*** 3836,3853 ****
              size_t dstOffset = 0;
  
              while (srcOffset < size) {
!                 isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize);
                  size_t nalLength = 0;
                  if (!isMalFormed) {
                      nalLength = parseNALSize(&mSrcBuffer[srcOffset]);
                      srcOffset += mNALLengthSize;
!                     isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength)
!                             || !isInRange((size_t)0u, mBuffer->size(), dstOffset, (size_t)4u)
!                             || !isInRange((size_t)0u, mBuffer->size(), dstOffset + 4, nalLength);
                  }
  
                  if (isMalFormed) {
!                     ALOGE("Video is malformed; nalLength %zu", nalLength);
                      mBuffer->release();
                      mBuffer = NULL;
                      return ERROR_MALFORMED;
--- 3669,3684 ----
              size_t dstOffset = 0;
  
              while (srcOffset < size) {
!                 bool isMalFormed = (srcOffset + mNALLengthSize > size);
                  size_t nalLength = 0;
                  if (!isMalFormed) {
                      nalLength = parseNALSize(&mSrcBuffer[srcOffset]);
                      srcOffset += mNALLengthSize;
!                     isMalFormed = srcOffset + nalLength > size;
                  }
  
                  if (isMalFormed) {
!                     ALOGE("Video is malformed");
                      mBuffer->release();
                      mBuffer = NULL;
                      return ERROR_MALFORMED;
***************
*** 3857,3871 ****
                      continue;
                  }
  
!                 if (dstOffset > SIZE_MAX - 4 ||
!                         dstOffset + 4 > SIZE_MAX - nalLength ||
!                         dstOffset + 4 + nalLength > mBuffer->size()) {
!                     ALOGE("b/26365349 : %zu %zu", dstOffset, mBuffer->size());
!                     android_errorWriteLog(0x534e4554, "26365349");
!                     mBuffer->release();
!                     mBuffer = NULL;
!                     return ERROR_MALFORMED;
!                 }
  
                  dstData[dstOffset++] = 0;
                  dstData[dstOffset++] = 0;
--- 3688,3694 ----
                      continue;
                  }
  
!                 CHECK(dstOffset + 4 <= mBuffer->size());
  
                  dstData[dstOffset++] = 0;
                  dstData[dstOffset++] = 0;
diff '--exclude=.git' -crB a/media/libstagefright/NuCachedSource2.cpp b/media/libstagefright/NuCachedSource2.cpp
*** a/media/libstagefright/NuCachedSource2.cpp	2018-09-22 10:19:51.673278059 +0200
--- b/media/libstagefright/NuCachedSource2.cpp	2018-09-22 10:11:05.444312607 +0200
***************
*** 217,222 ****
--- 217,225 ----
      mLooper->setName("NuCachedSource2");
      mLooper->registerHandler(mReflector);
      mLooper->start();
+ 
+     Mutex::Autolock autoLock(mLock);
+     (new AMessage(kWhatFetchMore, mReflector->id()))->post();
  }
  
  NuCachedSource2::~NuCachedSource2() {
***************
*** 227,244 ****
      mCache = NULL;
  }
  
- // static
- sp<NuCachedSource2> NuCachedSource2::Create(
-         const sp<DataSource> &source,
-         const char *cacheConfig,
-         bool disconnectAtHighwatermark) {
-     sp<NuCachedSource2> instance = new NuCachedSource2(
-             source, cacheConfig, disconnectAtHighwatermark);
-     Mutex::Autolock autoLock(instance->mLock);
-     (new AMessage(kWhatFetchMore, instance->mReflector->id()))->post();
-     return instance;
- }
- 
  void NuCachedSource2::enableNonBlockingRead(bool flag) {
      mIsNonBlockingMode = flag;
  }
--- 230,235 ----
diff '--exclude=.git' -crB a/media/libstagefright/OggExtractor.cpp b/media/libstagefright/OggExtractor.cpp
*** a/media/libstagefright/OggExtractor.cpp	2018-09-22 10:19:51.677278066 +0200
--- b/media/libstagefright/OggExtractor.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 21,29 ****
  #include "include/OggExtractor.h"
  
  #include <cutils/properties.h>
- #include <media/stagefright/foundation/ABuffer.h>
  #include <media/stagefright/foundation/ADebug.h>
- #include <media/stagefright/foundation/base64.h>
  #include <media/stagefright/DataSource.h>
  #include <media/stagefright/MediaBuffer.h>
  #include <media/stagefright/MediaBufferGroup.h>
--- 21,27 ----
***************
*** 832,850 ****
  
  }
  
  static void extractAlbumArt(
          const sp<MetaData> &fileMeta, const void *data, size_t size) {
      ALOGV("extractAlbumArt from '%s'", (const char *)data);
  
!     sp<ABuffer> flacBuffer = decodeBase64(AString((const char *)data, size));
!     if (flacBuffer == NULL) {
          ALOGE("malformed base64 encoded data.");
          return;
      }
  
!     size_t flacSize = flacBuffer->size();
!     uint8_t *flac = flacBuffer->data();
!     ALOGV("got flac of size %zu", flacSize);
  
      uint32_t picType;
      uint32_t typeLen;
--- 830,913 ----
  
  }
  
+ // The returned buffer should be free()d.
+ static uint8_t *DecodeBase64(const char *s, size_t size, size_t *outSize) {
+     *outSize = 0;
+ 
+     if ((size % 4) != 0) {
+         return NULL;
+     }
+ 
+     size_t n = size;
+     size_t padding = 0;
+     if (n >= 1 && s[n - 1] == '=') {
+         padding = 1;
+ 
+         if (n >= 2 && s[n - 2] == '=') {
+             padding = 2;
+         }
+     }
+ 
+     size_t outLen = 3 * size / 4 - padding;
+ 
+     *outSize = outLen;
+ 
+     void *buffer = malloc(outLen);
+ 
+     uint8_t *out = (uint8_t *)buffer;
+     size_t j = 0;
+     uint32_t accum = 0;
+     for (size_t i = 0; i < n; ++i) {
+         char c = s[i];
+         unsigned value;
+         if (c >= 'A' && c <= 'Z') {
+             value = c - 'A';
+         } else if (c >= 'a' && c <= 'z') {
+             value = 26 + c - 'a';
+         } else if (c >= '0' && c <= '9') {
+             value = 52 + c - '0';
+         } else if (c == '+') {
+             value = 62;
+         } else if (c == '/') {
+             value = 63;
+         } else if (c != '=') {
+             return NULL;
+         } else {
+             if (i < n - padding) {
+                 return NULL;
+             }
+ 
+             value = 0;
+         }
+ 
+         accum = (accum << 6) | value;
+ 
+         if (((i + 1) % 4) == 0) {
+             out[j++] = (accum >> 16);
+ 
+             if (j < outLen) { out[j++] = (accum >> 8) & 0xff; }
+             if (j < outLen) { out[j++] = accum & 0xff; }
+ 
+             accum = 0;
+         }
+     }
+ 
+     return (uint8_t *)buffer;
+ }
+ 
  static void extractAlbumArt(
          const sp<MetaData> &fileMeta, const void *data, size_t size) {
      ALOGV("extractAlbumArt from '%s'", (const char *)data);
  
!     size_t flacSize;
!     uint8_t *flac = DecodeBase64((const char *)data, size, &flacSize);
! 
!     if (flac == NULL) {
          ALOGE("malformed base64 encoded data.");
          return;
      }
  
!     ALOGV("got flac of size %d", flacSize);
  
      uint32_t picType;
      uint32_t typeLen;
***************
*** 853,876 ****
      char type[128];
  
      if (flacSize < 8) {
!         return;
      }
  
      picType = U32_AT(flac);
  
      if (picType != 3) {
          // This is not a front cover.
!         return;
      }
  
      typeLen = U32_AT(&flac[4]);
!     if (typeLen > sizeof(type) - 1) {
!         return;
      }
  
!     // we've already checked above that flacSize >= 8
!     if (flacSize - 8 < typeLen) {
!         return;
      }
  
      memcpy(type, &flac[8], typeLen);
--- 916,938 ----
      char type[128];
  
      if (flacSize < 8) {
!         goto exit;
      }
  
      picType = U32_AT(flac);
  
      if (picType != 3) {
          // This is not a front cover.
!         goto exit;
      }
  
      typeLen = U32_AT(&flac[4]);
!     if (typeLen + 1 > sizeof(type)) {
!         goto exit;
      }
  
!     if (flacSize < 8 + typeLen) {
!         goto exit;
      }
  
      memcpy(type, &flac[8], typeLen);
***************
*** 880,902 ****
  
      if (!strcmp(type, "-->")) {
          // This is not inline cover art, but an external url instead.
!         return;
      }
  
      descLen = U32_AT(&flac[8 + typeLen]);
  
!     if (flacSize < 32 ||
!         flacSize - 32 < typeLen ||
!         flacSize - 32 - typeLen < descLen) {
!         return;
      }
  
      dataLen = U32_AT(&flac[8 + typeLen + 4 + descLen + 16]);
  
! 
!     // we've already checked above that (flacSize - 32 - typeLen - descLen) >= 0
!     if (flacSize - 32 - typeLen - descLen < dataLen) {
!         return;
      }
  
      ALOGV("got image data, %d trailing bytes",
--- 942,960 ----
  
      if (!strcmp(type, "-->")) {
          // This is not inline cover art, but an external url instead.
!         goto exit;
      }
  
      descLen = U32_AT(&flac[8 + typeLen]);
  
!     if (flacSize < 32 + typeLen + descLen) {
!         goto exit;
      }
  
      dataLen = U32_AT(&flac[8 + typeLen + 4 + descLen + 16]);
  
!     if (flacSize < 32 + typeLen + descLen + dataLen) {
!         goto exit;
      }
  
      ALOGV("got image data, %d trailing bytes",
***************
*** 906,911 ****
--- 964,973 ----
              kKeyAlbumArt, 0, &flac[8 + typeLen + 4 + descLen + 20], dataLen);
  
      fileMeta->setCString(kKeyAlbumArtMIME, type);
+ 
+ exit:
+     free(flac);
+     flac = NULL;
  }
  
  ////////////////////////////////////////////////////////////////////////////////
diff '--exclude=.git' -crB a/media/libstagefright/omx/OMX.cpp b/media/libstagefright/omx/OMX.cpp
*** a/media/libstagefright/omx/OMX.cpp	2018-09-22 10:19:51.769278234 +0200
--- b/media/libstagefright/omx/OMX.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 170,181 ****
          Mutex::Autolock autoLock(mLock);
  
          ssize_t index = mLiveNodes.indexOfKey(the_late_who);
! 
!         if (index < 0) {
!             ALOGE("b/27597103, nonexistent observer on binderDied");
!             android_errorWriteLog(0x534e4554, "27597103");
!             return;
!         }
  
          instance = mLiveNodes.editValueAt(index);
          mLiveNodes.removeItemsAt(index);
--- 170,176 ----
          Mutex::Autolock autoLock(mLock);
  
          ssize_t index = mLiveNodes.indexOfKey(the_late_who);
!         CHECK(index >= 0);
  
          instance = mLiveNodes.editValueAt(index);
          mLiveNodes.removeItemsAt(index);
***************
*** 190,200 ****
      instance->onObserverDied(mMaster);
  }
  
- bool OMX::isSecure(node_id node) {
-     OMXNodeInstance *instance = findInstance(node);
-     return (instance == NULL ? false : instance->isSecure());
- }
- 
  bool OMX::livesLocally(node_id node, pid_t pid) {
      return pid == getpid();
  }
--- 185,190 ----
***************
*** 233,239 ****
  
      *node = 0;
  
!     OMXNodeInstance *instance = new OMXNodeInstance(this, observer, name);
  
      OMX_COMPONENTTYPE *handle;
      OMX_ERRORTYPE err = mMaster->makeComponentInstance(
--- 223,229 ----
  
      *node = 0;
  
!     OMXNodeInstance *instance = new OMXNodeInstance(this, observer);
  
      OMX_COMPONENTTYPE *handle;
      OMX_ERRORTYPE err = mMaster->makeComponentInstance(
***************
*** 350,358 ****
  
  status_t OMX::useBuffer(
          node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!         buffer_id *buffer, OMX_BOOL crossProcess) {
      return findInstance(node)->useBuffer(
!             port_index, params, buffer, crossProcess);
  }
  
  status_t OMX::useGraphicBuffer(
--- 340,348 ----
  
  status_t OMX::useBuffer(
          node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!         buffer_id *buffer) {
      return findInstance(node)->useBuffer(
!             port_index, params, buffer);
  }
  
  status_t OMX::useGraphicBuffer(
***************
*** 423,431 ****
  
  status_t OMX::allocateBufferWithBackup(
          node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!         buffer_id *buffer, OMX_BOOL crossProcess) {
      return findInstance(node)->allocateBufferWithBackup(
!             port_index, params, buffer, crossProcess);
  }
  
  status_t OMX::freeBuffer(node_id node, OMX_U32 port_index, buffer_id buffer) {
--- 413,421 ----
  
  status_t OMX::allocateBufferWithBackup(
          node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!         buffer_id *buffer) {
      return findInstance(node)->allocateBufferWithBackup(
!             port_index, params, buffer);
  }
  
  status_t OMX::freeBuffer(node_id node, OMX_U32 port_index, buffer_id buffer) {
diff '--exclude=.git' -crB a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
*** a/media/libstagefright/omx/OMXNodeInstance.cpp	2018-09-22 10:19:51.769278234 +0200
--- b/media/libstagefright/omx/OMXNodeInstance.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 23,33 ****
  #include "GraphicBufferSource.h"
  
  #include <OMX_Component.h>
- #include <OMX_IndexExt.h>
  
  #include <binder/IMemory.h>
  #include <gui/BufferQueue.h>
- #include <utils/misc.h>
  #include <HardwareAPI.h>
  #include <media/stagefright/foundation/ADebug.h>
  #include <media/stagefright/MediaErrors.h>
--- 23,31 ----
***************
*** 38,76 ****
  
  
  static const OMX_U32 kPortIndexInput = 0;
- static const OMX_U32 kPortIndexOutput = 1;
  
  namespace android {
  
  struct BufferMeta {
!     BufferMeta(
!             const sp<IMemory> &mem, OMX_U32 portIndex, bool copyToOmx,
!             bool copyFromOmx, OMX_U8 *backup)
          : mMem(mem),
!           mCopyFromOmx(copyFromOmx),
!           mCopyToOmx(copyToOmx),
!           mPortIndex(portIndex),
!           mBackup(backup) {
      }
  
!     BufferMeta(size_t size, OMX_U32 portIndex)
          : mSize(size),
!           mCopyFromOmx(false),
!           mCopyToOmx(false),
!           mPortIndex(portIndex),
!           mBackup(NULL) {
      }
  
!     BufferMeta(const sp<GraphicBuffer> &graphicBuffer, OMX_U32 portIndex)
          : mGraphicBuffer(graphicBuffer),
!           mCopyFromOmx(false),
!           mCopyToOmx(false),
!           mPortIndex(portIndex),
!           mBackup(NULL) {
      }
  
      void CopyFromOMX(const OMX_BUFFERHEADERTYPE *header) {
!         if (!mCopyFromOmx) {
              return;
          }
  
--- 36,62 ----
  
  
  static const OMX_U32 kPortIndexInput = 0;
  
  namespace android {
  
  struct BufferMeta {
!     BufferMeta(const sp<IMemory> &mem, bool is_backup = false)
          : mMem(mem),
!           mIsBackup(is_backup) {
      }
  
!     BufferMeta(size_t size)
          : mSize(size),
!           mIsBackup(false) {
      }
  
!     BufferMeta(const sp<GraphicBuffer> &graphicBuffer)
          : mGraphicBuffer(graphicBuffer),
!           mIsBackup(false) {
      }
  
      void CopyFromOMX(const OMX_BUFFERHEADERTYPE *header) {
!         if (!mIsBackup) {
              return;
          }
  
***************
*** 81,87 ****
      }
  
      void CopyToOMX(const OMX_BUFFERHEADERTYPE *header) {
!         if (!mCopyToOmx) {
              return;
          }
  
--- 67,73 ----
      }
  
      void CopyToOMX(const OMX_BUFFERHEADERTYPE *header) {
!         if (!mIsBackup) {
              return;
          }
  
***************
*** 95,116 ****
          mGraphicBuffer = graphicBuffer;
      }
  
-     OMX_U32 getPortIndex() {
-         return mPortIndex;
-     }
- 
-     ~BufferMeta() {
-         delete[] mBackup;
-     }
- 
  private:
      sp<GraphicBuffer> mGraphicBuffer;
      sp<IMemory> mMem;
      size_t mSize;
!     bool mCopyFromOmx;
!     bool mCopyToOmx;
!     OMX_U32 mPortIndex;
!     OMX_U8 *mBackup;
  
      BufferMeta(const BufferMeta &);
      BufferMeta &operator=(const BufferMeta &);
--- 81,91 ----
          mGraphicBuffer = graphicBuffer;
      }
  
  private:
      sp<GraphicBuffer> mGraphicBuffer;
      sp<IMemory> mMem;
      size_t mSize;
!     bool mIsBackup;
  
      BufferMeta(const BufferMeta &);
      BufferMeta &operator=(const BufferMeta &);
***************
*** 122,138 ****
  };
  
  OMXNodeInstance::OMXNodeInstance(
!         OMX *owner, const sp<IOMXObserver> &observer, const char *name)
      : mOwner(owner),
        mNodeID(NULL),
        mHandle(NULL),
        mObserver(observer),
!       mDying(false),
!       mSailed(false),
!       mQueriedProhibitedExtensions(false) {
!     mUsingMetadata[0] = false;
!     mUsingMetadata[1] = false;
!     mIsSecure = AString(name).endsWith(".secure");
  #ifdef MTK_HARDWARE
      mMtkBufferHandler = new OMXNodeInstanceBufferHandler(this);
  #endif
--- 97,108 ----
  };
  
  OMXNodeInstance::OMXNodeInstance(
!         OMX *owner, const sp<IOMXObserver> &observer)
      : mOwner(owner),
        mNodeID(NULL),
        mHandle(NULL),
        mObserver(observer),
!       mDying(false) {
  #ifdef MTK_HARDWARE
      mMtkBufferHandler = new OMXNodeInstanceBufferHandler(this);
  #endif
***************
*** 288,299 ****
  
  status_t OMXNodeInstance::sendCommand(
          OMX_COMMANDTYPE cmd, OMX_S32 param) {
!     if (cmd == OMX_CommandStateSet && param != OMX_StateIdle) {
!         // Normally there are no configurations past first StateSet; however, OMXCodec supports
!         // meta configuration past Stateset:Idle.
!         mSailed = true;
!     }
!     const sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
      if (bufferSource != NULL && cmd == OMX_CommandStateSet) {
          if (param == OMX_StateIdle) {
              // Initiating transition from Executing -> Idle
--- 258,264 ----
  
  status_t OMXNodeInstance::sendCommand(
          OMX_COMMANDTYPE cmd, OMX_S32 param) {
!     const sp<GraphicBufferSource>& bufferSource(getGraphicBufferSource());
      if (bufferSource != NULL && cmd == OMX_CommandStateSet) {
          if (param == OMX_StateIdle) {
              // Initiating transition from Executing -> Idle
***************
*** 316,365 ****
      return StatusFromOMXError(err);
  }
  
- bool OMXNodeInstance::isProhibitedIndex_l(OMX_INDEXTYPE index) {
-     // these extensions can only be used from OMXNodeInstance, not by clients directly.
-     static const char *restricted_extensions[] = {
-         "OMX.google.android.index.storeMetaDataInBuffers",
-         "OMX.google.android.index.prepareForAdaptivePlayback",
-         "OMX.google.android.index.useAndroidNativeBuffer2",
-         "OMX.google.android.index.useAndroidNativeBuffer",
-         "OMX.google.android.index.enableAndroidNativeBuffers",
-         "OMX.google.android.index.getAndroidNativeBufferUsage",
-     };
- 
-     if ((index > OMX_IndexComponentStartUnused && index <= OMX_IndexParamStandardComponentRole)
-             || (index > OMX_IndexPortStartUnused && index <= OMX_IndexParamCompBufferSupplier)
-             || (index > OMX_IndexAudioStartUnused && index <= OMX_IndexConfigAudioChannelVolume)
-             || (index > OMX_IndexVideoStartUnused && index <= OMX_IndexConfigVideoNalSize)
-             || (index > OMX_IndexCommonStartUnused
-                     && index <= OMX_IndexConfigCommonTransitionEffect)
-             || (index > (OMX_INDEXTYPE)OMX_IndexExtVideoStartUnused
-                     && index <= (OMX_INDEXTYPE)OMX_IndexConfigVideoVp8ReferenceFrameType)) {
-         return false;
-     }
- 
-     if (!mQueriedProhibitedExtensions) {
-         for (size_t i = 0; i < NELEM(restricted_extensions); ++i) {
-             OMX_INDEXTYPE ext;
-             if (OMX_GetExtensionIndex(mHandle, (OMX_STRING)restricted_extensions[i], &ext) == OMX_ErrorNone) {
-                 mProhibitedExtensions.add(ext);
-             }
-         }
-         mQueriedProhibitedExtensions = true;
-     }
- 
-     return mProhibitedExtensions.indexOf(index) >= 0;
- }
- 
  status_t OMXNodeInstance::getParameter(
          OMX_INDEXTYPE index, void *params, size_t size) {
      Mutex::Autolock autoLock(mLock);
  
-     if (isProhibitedIndex_l(index)) {
-         android_errorWriteLog(0x534e4554, "29422020");
-         return BAD_INDEX;
-     }
- 
      OMX_ERRORTYPE err = OMX_GetParameter(mHandle, index, params);
  
      return StatusFromOMXError(err);
--- 281,290 ----
***************
*** 369,379 ****
          OMX_INDEXTYPE index, const void *params, size_t size) {
      Mutex::Autolock autoLock(mLock);
  
-     if (isProhibitedIndex_l(index)) {
-         android_errorWriteLog(0x534e4554, "29422020");
-         return BAD_INDEX;
-     }
- 
      OMX_ERRORTYPE err = OMX_SetParameter(
              mHandle, index, const_cast<void *>(params));
  
--- 294,299 ----
***************
*** 384,394 ****
          OMX_INDEXTYPE index, void *params, size_t size) {
      Mutex::Autolock autoLock(mLock);
  
-     if (isProhibitedIndex_l(index)) {
-         android_errorWriteLog(0x534e4554, "29422020");
-         return BAD_INDEX;
-     }
- 
      OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);
      return StatusFromOMXError(err);
  }
--- 304,309 ----
***************
*** 397,407 ****
          OMX_INDEXTYPE index, const void *params, size_t size) {
      Mutex::Autolock autoLock(mLock);
  
-     if (isProhibitedIndex_l(index)) {
-         android_errorWriteLog(0x534e4554, "29422020");
-         return BAD_INDEX;
-     }
- 
      OMX_ERRORTYPE err = OMX_SetConfig(
              mHandle, index, const_cast<void *>(params));
  
--- 312,317 ----
***************
*** 501,515 ****
  status_t OMXNodeInstance::storeMetaDataInBuffers_l(
          OMX_U32 portIndex,
          OMX_BOOL enable) {
-     if (mSailed) {
-         android_errorWriteLog(0x534e4554, "29422020");
-         return INVALID_OPERATION;
-     }
-     if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {
-         android_errorWriteLog(0x534e4554, "26324358");
-         return BAD_VALUE;
-     }
- 
      OMX_INDEXTYPE index;
      OMX_STRING name = const_cast<OMX_STRING>(
              "OMX.google.android.index.storeMetaDataInBuffers");
--- 411,416 ----
***************
*** 532,543 ****
      params.bStoreMetaData = enable;
      if ((err = OMX_SetParameter(mHandle, index, &params)) != OMX_ErrorNone) {
          ALOGE("OMX_SetParameter() failed for StoreMetaDataInBuffers: 0x%08x", err);
-         if (enable) {
-             mUsingMetadata[portIndex] = false;
-         }
          return UNKNOWN_ERROR;
-     } else {
-         mUsingMetadata[portIndex] = enable;
      }
      return err;
  }
--- 433,439 ----
***************
*** 546,555 ****
          OMX_U32 portIndex, OMX_BOOL enable, OMX_U32 maxFrameWidth,
          OMX_U32 maxFrameHeight) {
      Mutex::Autolock autolock(mLock);
-     if (mSailed) {
-         android_errorWriteLog(0x534e4554, "29422020");
-         return INVALID_OPERATION;
-     }
  
      OMX_INDEXTYPE index;
      OMX_STRING name = const_cast<OMX_STRING>(
--- 442,447 ----
***************
*** 582,620 ****
  
  status_t OMXNodeInstance::useBuffer(
          OMX_U32 portIndex, const sp<IMemory> &params,
!         OMX::buffer_id *buffer, OMX_BOOL crossProcess) {
      Mutex::Autolock autoLock(mLock);
-     if (portIndex >= NELEM(mUsingMetadata)) {
-         return BAD_VALUE;
-     }
-     // We do not support metadata mode changes past buffer allocation
-     mSailed = true;
- 
-     // metadata buffers are not connected cross process
-     BufferMeta *buffer_meta;
-     bool isMeta = mUsingMetadata[portIndex];
-     bool useBackup = crossProcess && isMeta; // use a backup buffer instead of the actual buffer
-     OMX_U8 *data = static_cast<OMX_U8 *>(params->pointer());
-     // allocate backup buffer
-     if (useBackup) {
-         data = new (std::nothrow) OMX_U8[params->size()];
-         if (data == NULL) {
-             return NO_MEMORY;
-         }
-         memset(data, 0, params->size());
  
!         buffer_meta = new BufferMeta(
!                 params, portIndex, false /* copyToOmx */, false /* copyFromOmx */, data);
!     } else {
!         buffer_meta = new BufferMeta(
!                 params, portIndex, false /* copyToOmx */, false /* copyFromOmx */, NULL);
!     }
  
      OMX_BUFFERHEADERTYPE *header;
  
      OMX_ERRORTYPE err = OMX_UseBuffer(
              mHandle, &header, portIndex, buffer_meta,
!             params->size(), data);
  
      if (err != OMX_ErrorNone) {
          ALOGE("OMX_UseBuffer failed with error %d (0x%08x)", err, err);
--- 474,489 ----
  
  status_t OMXNodeInstance::useBuffer(
          OMX_U32 portIndex, const sp<IMemory> &params,
!         OMX::buffer_id *buffer) {
      Mutex::Autolock autoLock(mLock);
  
!     BufferMeta *buffer_meta = new BufferMeta(params);
  
      OMX_BUFFERHEADERTYPE *header;
  
      OMX_ERRORTYPE err = OMX_UseBuffer(
              mHandle, &header, portIndex, buffer_meta,
!             params->size(), static_cast<OMX_U8 *>(params->pointer()));
  
      if (err != OMX_ErrorNone) {
          ALOGE("OMX_UseBuffer failed with error %d (0x%08x)", err, err);
***************
*** 689,695 ****
          return err;
      }
  
!     BufferMeta *bufferMeta = new BufferMeta(graphicBuffer, portIndex);
  
      OMX_BUFFERHEADERTYPE *header = NULL;
      OMX_U8* bufferHandle = const_cast<OMX_U8*>(
--- 558,564 ----
          return err;
      }
  
!     BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);
  
      OMX_BUFFERHEADERTYPE *header = NULL;
      OMX_U8* bufferHandle = const_cast<OMX_U8*>(
***************
*** 751,757 ****
          return StatusFromOMXError(err);
      }
  
!     BufferMeta *bufferMeta = new BufferMeta(graphicBuffer, portIndex);
  
      OMX_BUFFERHEADERTYPE *header;
  
--- 620,626 ----
          return StatusFromOMXError(err);
      }
  
!     BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);
  
      OMX_BUFFERHEADERTYPE *header;
  
***************
*** 797,807 ****
      VideoDecoderOutputMetaData *metadata =
          (VideoDecoderOutputMetaData *)(header->pBuffer);
      BufferMeta *bufferMeta = (BufferMeta *)(header->pAppPrivate);
-     if (bufferMeta->getPortIndex() != portIndex) {
-         ALOGW("buffer %u has an incorrect port index.", buffer);
-         android_errorWriteLog(0x534e4554, "28816827");
-         return UNKNOWN_ERROR;
-     }
      bufferMeta->setGraphicBuffer(graphicBuffer);
      metadata->eType = kMetadataBufferTypeGrallocSource;
      metadata->pHandle = graphicBuffer->handle;
--- 666,671 ----
***************
*** 814,829 ****
      Mutex::Autolock autolock(mLock);
      status_t err;
  
!     // only allow graphic source on input port, when there are no allocated buffers yet
!     if (portIndex != kPortIndexInput) {
!         android_errorWriteLog(0x534e4554, "29422020");
!         return BAD_VALUE;
!     } else if (mActiveBuffers.size() > 0) {
!         android_errorWriteLog(0x534e4554, "29422020");
!         return INVALID_OPERATION;
!     }
! 
!     const sp<GraphicBufferSource> surfaceCheck = getGraphicBufferSource();
      if (surfaceCheck != NULL) {
          return ALREADY_EXISTS;
      }
--- 678,684 ----
      Mutex::Autolock autolock(mLock);
      status_t err;
  
!     const sp<GraphicBufferSource>& surfaceCheck = getGraphicBufferSource();
      if (surfaceCheck != NULL) {
          return ALREADY_EXISTS;
      }
***************
*** 882,891 ****
          OMX_U32 portIndex, size_t size, OMX::buffer_id *buffer,
          void **buffer_data) {
      Mutex::Autolock autoLock(mLock);
-     // We do not support metadata mode changes past buffer allocation
-     mSailed = true;
  
!     BufferMeta *buffer_meta = new BufferMeta(size, portIndex);
  
      OMX_BUFFERHEADERTYPE *header;
  
--- 737,744 ----
          OMX_U32 portIndex, size_t size, OMX::buffer_id *buffer,
          void **buffer_data) {
      Mutex::Autolock autoLock(mLock);
  
!     BufferMeta *buffer_meta = new BufferMeta(size);
  
      OMX_BUFFERHEADERTYPE *header;
  
***************
*** 920,942 ****
  
  status_t OMXNodeInstance::allocateBufferWithBackup(
          OMX_U32 portIndex, const sp<IMemory> &params,
!         OMX::buffer_id *buffer, OMX_BOOL crossProcess) {
      Mutex::Autolock autoLock(mLock);
-     if (portIndex >= NELEM(mUsingMetadata)) {
-         return BAD_VALUE;
-     }
-     // We do not support metadata mode changes past buffer allocation
-     mSailed = true;
  
!     // metadata buffers are not connected cross process
!     bool isMeta = mUsingMetadata[portIndex];
!     bool copy = !(crossProcess && isMeta);
! 
!     BufferMeta *buffer_meta = new BufferMeta(
!             params, portIndex,
!             (portIndex == kPortIndexInput) && copy /* copyToOmx */,
!             (portIndex == kPortIndexOutput) && copy /* copyFromOmx */,
!             NULL /* data */);
  
      OMX_BUFFERHEADERTYPE *header;
  
--- 773,782 ----
  
  status_t OMXNodeInstance::allocateBufferWithBackup(
          OMX_U32 portIndex, const sp<IMemory> &params,
!         OMX::buffer_id *buffer) {
      Mutex::Autolock autoLock(mLock);
  
!     BufferMeta *buffer_meta = new BufferMeta(params, true);
  
      OMX_BUFFERHEADERTYPE *header;
  
***************
*** 974,984 ****
  
      OMX_BUFFERHEADERTYPE *header = (OMX_BUFFERHEADERTYPE *)buffer;
      BufferMeta *buffer_meta = static_cast<BufferMeta *>(header->pAppPrivate);
-     if (buffer_meta->getPortIndex() != portIndex) {
-         ALOGW("buffer %u has an incorrect port index.", buffer);
-         android_errorWriteLog(0x534e4554, "28816827");
-         // continue freeing
-     }
  
      OMX_ERRORTYPE err = OMX_FreeBuffer(mHandle, portIndex, header);
  
--- 814,819 ----
***************
*** 1003,1015 ****
      header->nOffset = 0;
      header->nFlags = 0;
  
-     BufferMeta *buffer_meta = static_cast<BufferMeta *>(header->pAppPrivate);
-     if (buffer_meta->getPortIndex() != kPortIndexOutput) {
-         ALOGW("buffer %u has an incorrect port index.", buffer);
-         android_errorWriteLog(0x534e4554, "28816827");
-         return UNKNOWN_ERROR;
-     }
- 
      OMX_ERRORTYPE err = OMX_FillThisBuffer(mHandle, header);
  
      return StatusFromOMXError(err);
--- 838,843 ----
***************
*** 1022,1041 ****
      Mutex::Autolock autoLock(mLock);
  
      OMX_BUFFERHEADERTYPE *header = (OMX_BUFFERHEADERTYPE *)buffer;
- 
-     // no emptybuffer if using input surface
-     if (getGraphicBufferSource() != NULL) {
-         android_errorWriteLog(0x534e4554, "29422020");
-         return INVALID_OPERATION;
-     }
- 
-     // rangeLength and rangeOffset must be a subset of the allocated data in the buffer.
-     // corner case: we permit rangeOffset == end-of-buffer with rangeLength == 0.
-     if (header == NULL
-             || rangeOffset > header->nAllocLen
-             || rangeLength > header->nAllocLen - rangeOffset) {
-         return BAD_VALUE;
-     }
      header->nFilledLen = rangeLength;
      header->nOffset = rangeOffset;
      header->nFlags = flags;
--- 850,855 ----
***************
*** 1043,1053 ****
  
      BufferMeta *buffer_meta =
          static_cast<BufferMeta *>(header->pAppPrivate);
-     if (buffer_meta->getPortIndex() != kPortIndexInput) {
-         ALOGW("buffer %u has an incorrect port index.", buffer);
-         android_errorWriteLog(0x534e4554, "28816827");
-         return UNKNOWN_ERROR;
-     }
      buffer_meta->CopyToOMX(header);
  
      OMX_ERRORTYPE err = OMX_EmptyThisBuffer(mHandle, header);
--- 857,862 ----
***************
*** 1146,1157 ****
  
          BufferMeta *buffer_meta =
              static_cast<BufferMeta *>(buffer->pAppPrivate);
!         if (buffer_meta->getPortIndex() != kPortIndexOutput) {
!             ALOGW("buffer %u has an incorrect port index.", buffer);
!             android_errorWriteLog(0x534e4554, "28816827");
!         } else {
!             buffer_meta->CopyFromOMX(buffer);
!         }
  
          if (bufferSource != NULL) {
              // fix up the buffer info (especially timestamp) if needed
--- 955,962 ----
  
          BufferMeta *buffer_meta =
              static_cast<BufferMeta *>(buffer->pAppPrivate);
! 
!         buffer_meta->CopyFromOMX(buffer);
  
          if (bufferSource != NULL) {
              // fix up the buffer info (especially timestamp) if needed
***************
*** 1205,1217 ****
              && arg2 == OMX_StateExecuting) {
          bufferSource->omxExecuting();
      }
- 
-     // allow configuration if we return to the loaded state
-     if (event == OMX_EventCmdComplete
-             && arg1 == OMX_CommandStateSet
-             && arg2 == OMX_StateLoaded) {
-         mSailed = false;
-     }
  }
  
  // static
--- 1010,1015 ----
diff '--exclude=.git' -crB a/media/libstagefright/omx/SimpleSoftOMXComponent.cpp b/media/libstagefright/omx/SimpleSoftOMXComponent.cpp
*** a/media/libstagefright/omx/SimpleSoftOMXComponent.cpp	2018-09-22 10:19:51.769278234 +0200
--- b/media/libstagefright/omx/SimpleSoftOMXComponent.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 125,134 ****
              OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                  (OMX_PARAM_PORTDEFINITIONTYPE *)params;
  
-             if (!isValidOMXParam(defParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (defParams->nPortIndex >= mPorts.size()
                      || defParams->nSize
                              != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
--- 125,130 ----
***************
*** 156,165 ****
              OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                  (OMX_PARAM_PORTDEFINITIONTYPE *)params;
  
-             if (!isValidOMXParam(defParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (defParams->nPortIndex >= mPorts.size()
                      || defParams->nSize
                              != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
--- 152,157 ----
***************
*** 469,481 ****
      CHECK_EQ((int)port->mTransition, (int)PortInfo::NONE);
      CHECK(port->mDef.bEnabled == !enable);
  
-     if (port->mDef.eDir != OMX_DirOutput) {
-         ALOGE("Port enable/disable allowed only on output ports.");
-         notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
-         android_errorWriteLog(0x534e4554, "29421804");
-         return;
-     }
- 
      if (!enable) {
          port->mDef.bEnabled = OMX_FALSE;
          port->mTransition = PortInfo::DISABLING;
--- 461,466 ----
diff '--exclude=.git' -crB a/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp b/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp
*** a/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp	2018-09-22 10:19:51.769278234 +0200
--- b/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 148,157 ****
              OMX_VIDEO_PARAM_PORTFORMATTYPE *formatParams =
                  (OMX_VIDEO_PARAM_PORTFORMATTYPE *)params;
  
-             if (!isValidOMXParam(formatParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (formatParams->nPortIndex > kMaxPortIndex) {
                  return OMX_ErrorUndefined;
              }
--- 148,153 ----
***************
*** 181,190 ****
                    (OMX_VIDEO_PARAM_PROFILELEVELTYPE *) params;
              OMX_U32 profileIndex = profileLevel->nProfileIndex;
  
-             if (!isValidOMXParam(profileLevel)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (profileLevel->nPortIndex != kInputPortIndex) {
                  ALOGE("Invalid port index: %ld", profileLevel->nPortIndex);
                  return OMX_ErrorUnsupportedIndex;
--- 177,182 ----
***************
*** 212,221 ****
              const OMX_PARAM_COMPONENTROLETYPE *roleParams =
                  (const OMX_PARAM_COMPONENTROLETYPE *)params;
  
-             if (!isValidOMXParam(roleParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (strncmp((const char *)roleParams->cRole,
                          mComponentRole,
                          OMX_MAX_STRINGNAME_SIZE - 1)) {
--- 204,209 ----
***************
*** 230,239 ****
              OMX_VIDEO_PARAM_PORTFORMATTYPE *formatParams =
                  (OMX_VIDEO_PARAM_PORTFORMATTYPE *)params;
  
-             if (!isValidOMXParam(formatParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (formatParams->nPortIndex > kMaxPortIndex) {
                  return OMX_ErrorUndefined;
              }
--- 218,223 ----
***************
*** 257,266 ****
          {
              OMX_CONFIG_RECTTYPE *rectParams = (OMX_CONFIG_RECTTYPE *)params;
  
-             if (!isValidOMXParam(rectParams)) {
-                 return OMX_ErrorBadParameter;
-             }
- 
              if (rectParams->nPortIndex != kOutputPortIndex) {
                  return OMX_ErrorUndefined;
              }
--- 241,246 ----
diff '--exclude=.git' -crB a/media/libstagefright/OMXClient.cpp b/media/libstagefright/OMXClient.cpp
*** a/media/libstagefright/OMXClient.cpp	2018-09-22 10:19:51.673278059 +0200
--- b/media/libstagefright/OMXClient.cpp	2018-09-22 10:11:05.444312607 +0200
***************
*** 82,88 ****
  
      virtual status_t useBuffer(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer, OMX_BOOL crossProcess);
  
  #ifdef MTK_HARDWARE
      virtual status_t useBuffer(
--- 82,88 ----
  
      virtual status_t useBuffer(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer);
  
  #ifdef MTK_HARDWARE
      virtual status_t useBuffer(
***************
*** 124,130 ****
  
      virtual status_t allocateBufferWithBackup(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer, OMX_BOOL crossProcess);
  
      virtual status_t freeBuffer(
              node_id node, OMX_U32 port_index, buffer_id buffer);
--- 124,130 ----
  
      virtual status_t allocateBufferWithBackup(
              node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!             buffer_id *buffer);
  
      virtual status_t freeBuffer(
              node_id node, OMX_U32 port_index, buffer_id buffer);
***************
*** 312,320 ****
  
  status_t MuxOMX::useBuffer(
          node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!         buffer_id *buffer, OMX_BOOL /* crossProcess */) {
!     return getOMX(node)->useBuffer(
!             node, port_index, params, buffer, OMX_FALSE /* crossProcess */);
  }
  
  #ifdef MTK_HARDWARE
--- 312,319 ----
  
  status_t MuxOMX::useBuffer(
          node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!         buffer_id *buffer) {
!     return getOMX(node)->useBuffer(node, port_index, params, buffer);
  }
  
  #ifdef MTK_HARDWARE
***************
*** 381,389 ****
  
  status_t MuxOMX::allocateBufferWithBackup(
          node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!         buffer_id *buffer, OMX_BOOL /* crossProcess */) {
      return getOMX(node)->allocateBufferWithBackup(
!             node, port_index, params, buffer, OMX_FALSE /* crossProcess */);
  }
  
  status_t MuxOMX::freeBuffer(
--- 380,388 ----
  
  status_t MuxOMX::allocateBufferWithBackup(
          node_id node, OMX_U32 port_index, const sp<IMemory> &params,
!         buffer_id *buffer) {
      return getOMX(node)->allocateBufferWithBackup(
!             node, port_index, params, buffer);
  }
  
  status_t MuxOMX::freeBuffer(
diff '--exclude=.git' -crB a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
*** a/media/libstagefright/OMXCodec.cpp	2018-09-22 10:19:51.677278066 +0200
--- b/media/libstagefright/OMXCodec.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 2221,2237 ****
              def.nBufferCountActual, def.nBufferSize,
              portIndex == kPortIndexInput ? "input" : "output");
  
-     if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {
-         return BAD_VALUE;
-     }
      size_t totalSize = def.nBufferCountActual * def.nBufferSize;
      mDealer[portIndex] = new MemoryDealer(totalSize, "OMXCodec");
  
      for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
          sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
!         if (mem == NULL || mem->pointer() == NULL) {
!             return NO_MEMORY;
!         }
  
          BufferInfo info;
          info.mData = NULL;
--- 2221,2232 ----
              def.nBufferCountActual, def.nBufferSize,
              portIndex == kPortIndexInput ? "input" : "output");
  
      size_t totalSize = def.nBufferCountActual * def.nBufferSize;
      mDealer[portIndex] = new MemoryDealer(totalSize, "OMXCodec");
  
      for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
          sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);
!         CHECK(mem.get() != NULL);
  
          BufferInfo info;
          info.mData = NULL;
diff '--exclude=.git' -crB a/media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp b/media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp
*** a/media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp	2018-09-22 10:19:51.769278234 +0200
--- b/media/libstagefright/rtsp/AMPEG4AudioAssembler.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 404,412 ****
                  break;
              }
          }
!         
!         CHECK_LT(offset, buffer->size());
!         CHECK_LE(payloadLength, buffer->size() - offset);
  
          memcpy(out->data() + out->size(), &ptr[offset], payloadLength);
          out->setRange(0, out->size() + payloadLength);
--- 404,411 ----
                  break;
              }
          }
! 
!         CHECK_LE(offset + payloadLength, buffer->size());
  
          memcpy(out->data() + out->size(), &ptr[offset], payloadLength);
          out->setRange(0, out->size() + payloadLength);
diff '--exclude=.git' -crB a/media/libstagefright/rtsp/ASessionDescription.cpp b/media/libstagefright/rtsp/ASessionDescription.cpp
*** a/media/libstagefright/rtsp/ASessionDescription.cpp	2018-09-22 10:19:51.773278241 +0200
--- b/media/libstagefright/rtsp/ASessionDescription.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 17,23 ****
  //#define LOG_NDEBUG 0
  #define LOG_TAG "ASessionDescription"
  #include <utils/Log.h>
- #include <cutils/log.h>
  
  #include "ASessionDescription.h"
  
--- 17,22 ----
***************
*** 212,223 ****
  
      *PT = x;
  
!     char key[32];
!     snprintf(key, sizeof(key), "a=rtpmap:%lu", x);
  
      CHECK(findAttribute(index, key, desc));
  
!     snprintf(key, sizeof(key), "a=fmtp:%lu", x);
      if (!findAttribute(index, key, params)) {
          params->clear();
      }
--- 211,222 ----
  
      *PT = x;
  
!     char key[20];
!     sprintf(key, "a=rtpmap:%lu", x);
  
      CHECK(findAttribute(index, key, desc));
  
!     sprintf(key, "a=fmtp:%lu", x);
      if (!findAttribute(index, key, params)) {
          params->clear();
      }
***************
*** 229,239 ****
      *width = 0;
      *height = 0;
  
!     char key[33];
!     snprintf(key, sizeof(key), "a=framesize:%lu", PT);
!     if (PT > 9999999) {
!         android_errorWriteLog(0x534e4554, "25747670");
!     }
      AString value;
      if (!findAttribute(index, key, &value)) {
          return false;
--- 228,235 ----
      *width = 0;
      *height = 0;
  
!     char key[20];
!     sprintf(key, "a=framesize:%lu", PT);
      AString value;
      if (!findAttribute(index, key, &value)) {
          return false;
diff '--exclude=.git' -crB a/media/libstagefright/SampleIterator.cpp b/media/libstagefright/SampleIterator.cpp
*** a/media/libstagefright/SampleIterator.cpp	2018-09-22 10:19:51.677278066 +0200
--- b/media/libstagefright/SampleIterator.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 84,99 ****
  
      CHECK(sampleIndex < mStopChunkSampleIndex);
  
-     if (mSamplesPerChunk == 0) {
-         ALOGE("b/22802344");
-         return ERROR_MALFORMED;
-     }
- 
      uint32_t chunk =
          (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk
          + mFirstChunk;
  
      if (!mInitialized || chunk != mCurrentChunkIndex) {
          status_t err;
          if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
              ALOGE("getChunkOffset return error");
--- 84,96 ----
  
      CHECK(sampleIndex < mStopChunkSampleIndex);
  
      uint32_t chunk =
          (sampleIndex - mFirstChunkSampleIndex) / mSamplesPerChunk
          + mFirstChunk;
  
      if (!mInitialized || chunk != mCurrentChunkIndex) {
+         mCurrentChunkIndex = chunk;
+ 
          status_t err;
          if ((err = getChunkOffset(chunk, &mCurrentChunkOffset)) != OK) {
              ALOGE("getChunkOffset return error");
***************
*** 104,124 ****
  
          uint32_t firstChunkSampleIndex =
              mFirstChunkSampleIndex
!                 + mSamplesPerChunk * (chunk - mFirstChunk);
  
          for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
              size_t sampleSize;
              if ((err = getSampleSizeDirect(
                              firstChunkSampleIndex + i, &sampleSize)) != OK) {
                  ALOGE("getSampleSizeDirect return error");
-                 mCurrentChunkSampleSizes.clear();
                  return err;
              }
  
              mCurrentChunkSampleSizes.push(sampleSize);
          }
- 
-         mCurrentChunkIndex = chunk;
      }
  
      uint32_t chunkRelativeSampleIndex =
--- 101,118 ----
  
          uint32_t firstChunkSampleIndex =
              mFirstChunkSampleIndex
!                 + mSamplesPerChunk * (mCurrentChunkIndex - mFirstChunk);
  
          for (uint32_t i = 0; i < mSamplesPerChunk; ++i) {
              size_t sampleSize;
              if ((err = getSampleSizeDirect(
                              firstChunkSampleIndex + i, &sampleSize)) != OK) {
                  ALOGE("getSampleSizeDirect return error");
                  return err;
              }
  
              mCurrentChunkSampleSizes.push(sampleSize);
          }
      }
  
      uint32_t chunkRelativeSampleIndex =
diff '--exclude=.git' -crB a/media/libstagefright/SampleTable.cpp b/media/libstagefright/SampleTable.cpp
*** a/media/libstagefright/SampleTable.cpp	2018-09-22 10:19:51.677278066 +0200
--- b/media/libstagefright/SampleTable.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 14,22 ****
   * limitations under the License.
   */
  
- #define __STDINT_MACROS
- #define __STDINT_LIMITS
- 
  #define LOG_TAG "SampleTable"
  //#define LOG_NDEBUG 0
  #include <utils/Log.h>
--- 14,19 ----
***************
*** 43,50 ****
  
  ////////////////////////////////////////////////////////////////////////////////
  
- const off64_t kMaxOffset = INT64_MAX;
- 
  struct SampleTable::CompositionDeltaLookup {
      CompositionDeltaLookup();
  
--- 40,45 ----
***************
*** 121,127 ****
        mSampleSizeFieldSize(0),
        mDefaultSampleSize(0),
        mNumSampleSizes(0),
-       mHasTimeToSample(false),
        mTimeToSampleCount(0),
        mTimeToSample(NULL),
        mSampleTimeEntries(NULL),
--- 116,121 ----
***************
*** 132,139 ****
        mNumSyncSamples(0),
        mSyncSamples(NULL),
        mLastSyncSampleIndex(0),
!       mSampleToChunkEntries(NULL),
!       mTotalSize(0) {
      mSampleIterator = new SampleIterator(this);
  }
  
--- 126,132 ----
        mNumSyncSamples(0),
        mSyncSamples(NULL),
        mLastSyncSampleIndex(0),
!       mSampleToChunkEntries(NULL) {
      mSampleIterator = new SampleIterator(this);
  }
  
***************
*** 144,152 ****
      delete[] mSyncSamples;
      mSyncSamples = NULL;
  
-     delete[] mTimeToSample;
-     mTimeToSample = NULL;
- 
      delete mCompositionDeltaLookup;
      mCompositionDeltaLookup = NULL;
  
--- 137,142 ----
***************
*** 156,161 ****
--- 146,154 ----
      delete[] mSampleTimeEntries;
      mSampleTimeEntries = NULL;
  
+     delete[] mTimeToSample;
+     mTimeToSample = NULL;
+ 
      delete mSampleIterator;
      mSampleIterator = NULL;
  }
***************
*** 164,170 ****
      return mChunkOffsetOffset >= 0
          && mSampleToChunkOffset >= 0
          && mSampleSizeOffset >= 0
!         && mHasTimeToSample;
  }
  
  status_t SampleTable::setChunkOffsetParams(
--- 157,163 ----
      return mChunkOffsetOffset >= 0
          && mSampleToChunkOffset >= 0
          && mSampleSizeOffset >= 0
!         && mTimeToSample != NULL;
  }
  
  status_t SampleTable::setChunkOffsetParams(
***************
*** 233,295 ****
  
      mNumSampleToChunkOffsets = U32_AT(&header[4]);
  
!     if ((data_size - 8) / sizeof(SampleToChunkEntry) < mNumSampleToChunkOffsets) {
          return ERROR_MALFORMED;
      }
  
-     if ((uint64_t)kMaxTotalSize / sizeof(SampleToChunkEntry) <=
-             (uint64_t)mNumSampleToChunkOffsets) {
-         ALOGE("Sample-to-chunk table size too large.");
-         return ERROR_OUT_OF_RANGE;
-     }
-     mTotalSize += (uint64_t)mNumSampleToChunkOffsets *
-             sizeof(SampleToChunkEntry);
-     if (mTotalSize > kMaxTotalSize) {
-         ALOGE("Sample-to-chunk table size would make sample table too large.\n"
-               "    Requested sample-to-chunk table size = %llu\n"
-               "    Eventual sample table size >= %llu\n"
-               "    Allowed sample table size = %llu\n",
-               (unsigned long long)mNumSampleToChunkOffsets *
-                       sizeof(SampleToChunkEntry),
-               (unsigned long long)mTotalSize,
-               (unsigned long long)kMaxTotalSize);
-         return ERROR_OUT_OF_RANGE;
-     }
- 
      mSampleToChunkEntries =
!         new (std::nothrow) SampleToChunkEntry[mNumSampleToChunkOffsets];
!     if (!mSampleToChunkEntries) {
!         ALOGE("Cannot allocate sample-to-chunk table with %llu entries.",
!                 (unsigned long long)mNumSampleToChunkOffsets);
!         return ERROR_OUT_OF_RANGE;
!     }
! 
!     if (mNumSampleToChunkOffsets == 0) {
!         return OK;
!     }
! 
!     if ((off64_t)(kMaxOffset - 8 -
!             ((mNumSampleToChunkOffsets - 1) * sizeof(SampleToChunkEntry)))
!             < mSampleToChunkOffset) {
!         return ERROR_MALFORMED;
!     }
  
      for (uint32_t i = 0; i < mNumSampleToChunkOffsets; ++i) {
!         uint8_t buffer[sizeof(SampleToChunkEntry)];
! 
          if (mDataSource->readAt(
!                     mSampleToChunkOffset + 8 + i * sizeof(SampleToChunkEntry),
!                     buffer,
!                     sizeof(buffer))
                  != (ssize_t)sizeof(buffer)) {
              return ERROR_IO;
          }
  
!         // chunk index is 1 based in the spec.
!         if (U32_AT(buffer) < 1) {
!             ALOGE("b/23534160");
!             return ERROR_OUT_OF_RANGE;
!         }
  
          // We want the chunk index to be 0-based.
          mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - 1;
--- 226,247 ----
  
      mNumSampleToChunkOffsets = U32_AT(&header[4]);
  
!     if (data_size < 8 + mNumSampleToChunkOffsets * 12) {
          return ERROR_MALFORMED;
      }
  
      mSampleToChunkEntries =
!         new SampleToChunkEntry[mNumSampleToChunkOffsets];
  
      for (uint32_t i = 0; i < mNumSampleToChunkOffsets; ++i) {
!         uint8_t buffer[12];
          if (mDataSource->readAt(
!                     mSampleToChunkOffset + 8 + i * 12, buffer, sizeof(buffer))
                  != (ssize_t)sizeof(buffer)) {
              return ERROR_IO;
          }
  
!         CHECK(U32_AT(buffer) >= 1);  // chunk index is 1 based in the spec.
  
          // We want the chunk index to be 0-based.
          mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - 1;
***************
*** 327,335 ****
  
      mDefaultSampleSize = U32_AT(&header[4]);
      mNumSampleSizes = U32_AT(&header[8]);
-     if (mNumSampleSizes > (UINT32_MAX - 12) / 16) {
-         return ERROR_MALFORMED;
-     }
  
      if (type == kSampleSizeType32) {
          mSampleSizeFieldSize = 32;
--- 279,284 ----
***************
*** 365,371 ****
  
  status_t SampleTable::setTimeToSampleParams(
          off64_t data_offset, size_t data_size) {
!     if (mHasTimeToSample || data_size < 8) {
          return ERROR_MALFORMED;
      }
  
--- 314,320 ----
  
  status_t SampleTable::setTimeToSampleParams(
          off64_t data_offset, size_t data_size) {
!     if (mTimeToSample != NULL || data_size < 8) {
          return ERROR_MALFORMED;
      }
  
***************
*** 381,431 ****
      }
  
      mTimeToSampleCount = U32_AT(&header[4]);
!     if (mTimeToSampleCount > UINT32_MAX / (2 * sizeof(uint32_t))) {
!         // Choose this bound because
!         // 1) 2 * sizeof(uint32_t) is the amount of memory needed for one
!         //    time-to-sample entry in the time-to-sample table.
!         // 2) mTimeToSampleCount is the number of entries of the time-to-sample
!         //    table.
!         // 3) We hope that the table size does not exceed UINT32_MAX.
!         ALOGE("Time-to-sample table size too large.");
!         return ERROR_OUT_OF_RANGE;
!     }
! 
!     // Note: At this point, we know that mTimeToSampleCount * 2 will not
!     // overflow because of the above condition.
! 
!     uint64_t allocSize = (uint64_t)mTimeToSampleCount * 2 * sizeof(uint32_t);
!     mTotalSize += allocSize;
!     if (mTotalSize > kMaxTotalSize) {
!         ALOGE("Time-to-sample table size would make sample table too large.\n"
!               "    Requested time-to-sample table size = %llu\n"
!               "    Eventual sample table size >= %llu\n"
!               "    Allowed sample table size = %llu\n",
!               (unsigned long long)allocSize,
!               (unsigned long long)mTotalSize,
!               (unsigned long long)kMaxTotalSize);
          return ERROR_OUT_OF_RANGE;
      }
  
!     mTimeToSample = new (std::nothrow) uint32_t[mTimeToSampleCount * 2];
!     if (!mTimeToSample) {
!         ALOGE("Cannot allocate time-to-sample table with %llu entries.",
!                 (unsigned long long)mTimeToSampleCount);
!         return ERROR_OUT_OF_RANGE;
!     }
! 
!     if (mDataSource->readAt(data_offset + 8, mTimeToSample,
!             (size_t)allocSize) < (ssize_t)allocSize) {
!         ALOGE("Incomplete data read for time-to-sample table.");
          return ERROR_IO;
      }
  
!     for (size_t i = 0; i < mTimeToSampleCount * 2; ++i) {
          mTimeToSample[i] = ntohl(mTimeToSample[i]);
      }
  
-     mHasTimeToSample = true;
      return OK;
  }
  
--- 330,351 ----
      }
  
      mTimeToSampleCount = U32_AT(&header[4]);
!     uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);
!     if (allocSize > SIZE_MAX) {
          return ERROR_OUT_OF_RANGE;
      }
+     mTimeToSample = new uint32_t[mTimeToSampleCount * 2];
  
!     size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;
!     if (mDataSource->readAt(
!                 data_offset + 8, mTimeToSample, size) < (ssize_t)size) {
          return ERROR_IO;
      }
  
!     for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {
          mTimeToSample[i] = ntohl(mTimeToSample[i]);
      }
  
      return OK;
  }
  
***************
*** 457,488 ****
      }
  
      mNumCompositionTimeDeltaEntries = numEntries;
!     uint64_t allocSize = (uint64_t)numEntries * 2 * sizeof(uint32_t);
!     if (allocSize > kMaxTotalSize) {
!         ALOGE("Composition-time-to-sample table size too large.");
          return ERROR_OUT_OF_RANGE;
      }
  
!     mTotalSize += allocSize;
!     if (mTotalSize > kMaxTotalSize) {
!         ALOGE("Composition-time-to-sample table would make sample table too large.\n"
!               "    Requested composition-time-to-sample table size = %llu\n"
!               "    Eventual sample table size >= %llu\n"
!               "    Allowed sample table size = %llu\n",
!               (unsigned long long)allocSize,
!               (unsigned long long)mTotalSize,
!               (unsigned long long)kMaxTotalSize);
!         return ERROR_OUT_OF_RANGE;
!     }
  
!     mCompositionTimeDeltaEntries = new (std::nothrow) uint32_t[2 * numEntries];
!     if (!mCompositionTimeDeltaEntries) {
!         ALOGE("Cannot allocate composition-time-to-sample table with %llu "
!                 "entries.", (unsigned long long)numEntries);
!         return ERROR_OUT_OF_RANGE;
!     }
!     if (mDataSource->readAt(data_offset + 8, mCompositionTimeDeltaEntries,
!             (size_t)allocSize) < (ssize_t)allocSize) {
          delete[] mCompositionTimeDeltaEntries;
          mCompositionTimeDeltaEntries = NULL;
  
--- 377,392 ----
      }
  
      mNumCompositionTimeDeltaEntries = numEntries;
!     uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);
!     if (allocSize > SIZE_MAX) {
          return ERROR_OUT_OF_RANGE;
      }
  
!     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];
  
!     if (mDataSource->readAt(
!                 data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)
!             < (ssize_t)numEntries * 8) {
          delete[] mCompositionTimeDeltaEntries;
          mCompositionTimeDeltaEntries = NULL;
  
***************
*** 523,555 ****
          ALOGV("Table of sync samples is empty or has only a single entry!");
      }
  
!     uint64_t allocSize = (uint64_t)mNumSyncSamples * sizeof(uint32_t);
!     if (allocSize > kMaxTotalSize) {
!           ALOGE("Sync sample table size too large.");
!           return ERROR_OUT_OF_RANGE;
!     }
! 
!     mTotalSize += allocSize;
!     if (mTotalSize > kMaxTotalSize) {
!         ALOGE("Sync sample table size would make sample table too large.\n"
!               "    Requested sync sample table size = %llu\n"
!               "    Eventual sample table size >= %llu\n"
!               "    Allowed sample table size = %llu\n",
!               (unsigned long long)allocSize,
!               (unsigned long long)mTotalSize,
!               (unsigned long long)kMaxTotalSize);
!         return ERROR_OUT_OF_RANGE;
!     }
! 
!     mSyncSamples = new (std::nothrow) uint32_t[mNumSyncSamples];
!     if (!mSyncSamples) {
!         ALOGE("Cannot allocate sync sample table with %llu entries.",
!                 (unsigned long long)mNumSyncSamples);
          return ERROR_OUT_OF_RANGE;
      }
  
!     if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples,
!             (size_t)allocSize) != (ssize_t)allocSize) {
          return ERROR_IO;
      }
  
--- 427,441 ----
          ALOGV("Table of sync samples is empty or has only a single entry!");
      }
  
!     uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);
!     if (allocSize > SIZE_MAX) {
          return ERROR_OUT_OF_RANGE;
      }
  
!     mSyncSamples = new uint32_t[mNumSyncSamples];
!     size_t size = mNumSyncSamples * sizeof(uint32_t);
!     if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)
!             != (ssize_t)size) {
          return ERROR_IO;
      }
  
***************
*** 610,637 ****
  void SampleTable::buildSampleEntriesTable() {
      Mutex::Autolock autoLock(mLock);
  
!     if (mSampleTimeEntries != NULL || mNumSampleSizes == 0) {
!         return;
!     }
! 
!     mTotalSize += (uint64_t)mNumSampleSizes * sizeof(SampleTimeEntry);
!     if (mTotalSize > kMaxTotalSize) {
!         ALOGE("Sample entry table size would make sample table too large.\n"
!               "    Requested sample entry table size = %llu\n"
!               "    Eventual sample table size >= %llu\n"
!               "    Allowed sample table size = %llu\n",
!               (unsigned long long)mNumSampleSizes * sizeof(SampleTimeEntry),
!               (unsigned long long)mTotalSize,
!               (unsigned long long)kMaxTotalSize);
          return;
      }
  
!     mSampleTimeEntries = new (std::nothrow) SampleTimeEntry[mNumSampleSizes];
!     if (!mSampleTimeEntries) {
!         ALOGE("Cannot allocate sample entry table with %llu entries.",
!                 (unsigned long long)mNumSampleSizes);
!         return;
!     }
  
      uint32_t sampleIndex = 0;
      uint64_t sampleTime = 0;
--- 496,506 ----
  void SampleTable::buildSampleEntriesTable() {
      Mutex::Autolock autoLock(mLock);
  
!     if (mSampleTimeEntries != NULL) {
          return;
      }
  
!     mSampleTimeEntries = new SampleTimeEntry[mNumSampleSizes];
  
      uint32_t sampleIndex = 0;
      uint64_t sampleTime = 0;
***************
*** 670,679 ****
          uint32_t *sample_index, uint32_t flags) {
      buildSampleEntriesTable();
  
-     if (mSampleTimeEntries == NULL) {
-         return ERROR_OUT_OF_RANGE;
-     }
- 
      uint32_t left = 0;
      uint32_t right_plus_one = mNumSampleSizes;
      while (left < right_plus_one) {
--- 539,544 ----
diff '--exclude=.git' -crB a/media/libstagefright/SkipCutBuffer.cpp b/media/libstagefright/SkipCutBuffer.cpp
*** a/media/libstagefright/SkipCutBuffer.cpp	2018-09-22 10:19:51.677278066 +0200
--- b/media/libstagefright/SkipCutBuffer.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 25,37 ****
  namespace android {
  
  SkipCutBuffer::SkipCutBuffer(int32_t skip, int32_t cut) {
- 
-     if (skip < 0 || cut < 0 || cut > 64 * 1024) {
-         ALOGW("out of range skip/cut: %d/%d, using passthrough instead", skip, cut);
-         skip = 0;
-         cut = 0;
-     }
- 
      mFrontPadding = skip;
      mBackPadding = cut;
      mWriteHead = 0;
--- 25,30 ----
Nur in a/media/libstagefright/tests: Utils_test.cpp.
diff '--exclude=.git' -crB a/media/libstagefright/timedtext/TextDescriptions.cpp b/media/libstagefright/timedtext/TextDescriptions.cpp
*** a/media/libstagefright/timedtext/TextDescriptions.cpp	2018-09-22 10:19:51.773278241 +0200
--- b/media/libstagefright/timedtext/TextDescriptions.cpp	2018-09-22 10:11:05.452312621 +0200
***************
*** 30,38 ****
  
      if (flags & IN_BAND_TEXT_3GPP) {
          if (flags & GLOBAL_DESCRIPTIONS) {
!             return extract3GPPGlobalDescriptions(data, size, parcel);
          } else if (flags & LOCAL_DESCRIPTIONS) {
!             return extract3GPPLocalDescriptions(data, size, timeMs, parcel);
          }
      } else if (flags & OUT_OF_BAND_TEXT_SRT) {
          if (flags & LOCAL_DESCRIPTIONS) {
--- 30,38 ----
  
      if (flags & IN_BAND_TEXT_3GPP) {
          if (flags & GLOBAL_DESCRIPTIONS) {
!             return extract3GPPGlobalDescriptions(data, size, parcel, 0);
          } else if (flags & LOCAL_DESCRIPTIONS) {
!             return extract3GPPLocalDescriptions(data, size, timeMs, parcel, 0);
          }
      } else if (flags & OUT_OF_BAND_TEXT_SRT) {
          if (flags & LOCAL_DESCRIPTIONS) {
***************
*** 69,370 ****
  // styles, and 'krok' box contains karaoke timing and positions.
  status_t TextDescriptions::extract3GPPLocalDescriptions(
          const uint8_t *data, ssize_t size,
!         int timeMs, Parcel *parcel) {
! 
!     parcel->writeInt32(KEY_LOCAL_SETTING);
! 
!     // write start time to display this text sample
!     parcel->writeInt32(KEY_START_TIME);
!     parcel->writeInt32(timeMs);
! 
!     if (size < 2) {
!         return OK;
      }
-     ssize_t textLen = (*data) << 8 | (*(data + 1));
  
!     if (size < textLen + 2) {
!         return OK;
!     }
  
!     // write text sample length and text sample itself
!     parcel->writeInt32(KEY_STRUCT_TEXT);
!     parcel->writeInt32(textLen);
!     parcel->writeInt32(textLen);
!     parcel->write(data + 2, textLen);
! 
!     if (size > textLen + 2) {
!         data += (textLen + 2);
!         size -= (textLen + 2);
!     } else {
          return OK;
      }
  
!     while (size >= 8) {
!         const uint8_t *tmpData = data;
!         ssize_t chunkSize = U32_AT(tmpData);      // size includes size and type
!         uint32_t chunkType = U32_AT(tmpData + 4);
! 
!         if (chunkSize <= 8 || chunkSize > size) {
!             return OK;
!         }
  
!         size_t remaining = chunkSize - 8;
  
!         tmpData += 8;
  
!         switch(chunkType) {
!             // 'styl' box specifies the style of the text.
!             case FOURCC('s', 't', 'y', 'l'):
!             {
!                 if (remaining < 2) {
!                     return OK;
!                 }
!                 size_t dataPos = parcel->dataPosition();
!                 uint16_t count = U16_AT(tmpData);
! 
!                 tmpData += 2;
!                 remaining -= 2;
! 
!                 for (int i = 0; i < count; i++) {
!                     if (remaining < 12) {
!                         // roll back
!                         parcel->setDataPosition(dataPos);
!                         return OK;
!                     }
!                     parcel->writeInt32(KEY_STRUCT_STYLE_LIST);
!                     parcel->writeInt32(KEY_START_CHAR);
!                     parcel->writeInt32(U16_AT(tmpData));
! 
!                     parcel->writeInt32(KEY_END_CHAR);
!                     parcel->writeInt32(U16_AT(tmpData + 2));
! 
!                     parcel->writeInt32(KEY_FONT_ID);
!                     parcel->writeInt32(U16_AT(tmpData + 4));
! 
!                     parcel->writeInt32(KEY_STYLE_FLAGS);
!                     parcel->writeInt32(*(tmpData + 6));
! 
!                     parcel->writeInt32(KEY_FONT_SIZE);
!                     parcel->writeInt32(*(tmpData + 7));
! 
!                     parcel->writeInt32(KEY_TEXT_COLOR_RGBA);
!                     uint32_t rgba = *(tmpData + 8) << 24 | *(tmpData + 9) << 16
!                         | *(tmpData + 10) << 8 | *(tmpData + 11);
!                     parcel->writeInt32(rgba);
! 
!                     tmpData += 12;
!                     remaining -= 12;
!                 }
! 
!                 break;
!             }
!             // 'krok' box. The number of highlight events is specified, and each
!             // event is specified by a starting and ending char offset and an end
!             // time for the event.
!             case FOURCC('k', 'r', 'o', 'k'):
!             {
!                 if (remaining < 6) {
!                     return OK;
!                 }
!                 size_t dataPos = parcel->dataPosition();
! 
!                 parcel->writeInt32(KEY_STRUCT_KARAOKE_LIST);
! 
!                 int startTime = U32_AT(tmpData);
!                 uint16_t count = U16_AT(tmpData + 4);
!                 parcel->writeInt32(count);
! 
!                 tmpData += 6;
!                 remaining -= 6;
!                 int lastEndTime = 0;
! 
!                 for (int i = 0; i < count; i++) {
!                     if (remaining < 8) {
!                         // roll back
!                         parcel->setDataPosition(dataPos);
!                         return OK;
!                     }
!                     parcel->writeInt32(startTime + lastEndTime);
! 
!                     lastEndTime = U32_AT(tmpData);
!                     parcel->writeInt32(lastEndTime);
! 
!                     parcel->writeInt32(U16_AT(tmpData + 4));
!                     parcel->writeInt32(U16_AT(tmpData + 6));
! 
!                     tmpData += 8;
!                     remaining -= 8;
!                 }
  
!                 break;
!             }
!             // 'hlit' box specifies highlighted text
!             case FOURCC('h', 'l', 'i', 't'):
!             {
!                 if (remaining < 4) {
!                     return OK;
!                 }
  
!                 parcel->writeInt32(KEY_STRUCT_HIGHLIGHT_LIST);
  
!                 // the start char offset to highlight
!                 parcel->writeInt32(U16_AT(tmpData));
!                 // the last char offset to highlight
!                 parcel->writeInt32(U16_AT(tmpData + 2));
  
!                 tmpData += 4;
!                 remaining -= 4;
!                 break;
!             }
!             // 'hclr' box specifies the RGBA color: 8 bits each of
!             // red, green, blue, and an alpha(transparency) value
!             case FOURCC('h', 'c', 'l', 'r'):
!             {
!                 if (remaining < 4) {
!                     return OK;
!                 }
!                 parcel->writeInt32(KEY_HIGHLIGHT_COLOR_RGBA);
  
!                 uint32_t rgba = *(tmpData) << 24 | *(tmpData + 1) << 16
!                     | *(tmpData + 2) << 8 | *(tmpData + 3);
                  parcel->writeInt32(rgba);
  
!                 tmpData += 4;
!                 remaining -= 4;
!                 break;
!             }
!             // 'dlay' box specifies a delay after a scroll in and/or
!             // before scroll out.
!             case FOURCC('d', 'l', 'a', 'y'):
!             {
!                 if (remaining < 4) {
!                     return OK;
!                 }
!                 parcel->writeInt32(KEY_SCROLL_DELAY);
! 
!                 uint32_t delay = *(tmpData) << 24 | *(tmpData + 1) << 16
!                     | *(tmpData + 2) << 8 | *(tmpData + 3);
!                 parcel->writeInt32(delay);
! 
!                 tmpData += 4;
!                 remaining -= 4;
!                 break;
              }
-             // 'href' box for hyper text link
-             case FOURCC('h', 'r', 'e', 'f'):
-             {
-                 if (remaining < 5) {
-                     return OK;
-                 }
  
!                 size_t dataPos = parcel->dataPosition();
  
!                 parcel->writeInt32(KEY_STRUCT_HYPER_TEXT_LIST);
  
!                 // the start offset of the text to be linked
!                 parcel->writeInt32(U16_AT(tmpData));
!                 // the end offset of the text
!                 parcel->writeInt32(U16_AT(tmpData + 2));
  
-                 // the number of bytes in the following URL
-                 size_t len = *(tmpData + 4);
-                 parcel->writeInt32(len);
- 
-                 remaining -= 5;
- 
-                 if (remaining  < len) {
-                     parcel->setDataPosition(dataPos);
-                     return OK;
-                 }
-                 // the linked-to URL
-                 parcel->writeInt32(len);
-                 parcel->write(tmpData + 5, len);
- 
-                 tmpData += (5 + len);
-                 remaining -= len;
- 
-                 if (remaining  < 1) {
-                     parcel->setDataPosition(dataPos);
-                     return OK;
-                 }
- 
-                 // the number of bytes in the following "alt" string
-                 len = *tmpData;
-                 parcel->writeInt32(len);
- 
-                 tmpData += 1;
-                 remaining -= 1;
-                 if (remaining  < len) {
-                     parcel->setDataPosition(dataPos);
-                     return OK;
-                 }
- 
-                 // an "alt" string for user display
-                 parcel->writeInt32(len);
-                 parcel->write(tmpData, len);
- 
-                 tmpData += 1;
-                 remaining -= 1;
-                 break;
-             }
-             // 'tbox' box to indicate the position of the text with values
-             // of top, left, bottom and right
-             case FOURCC('t', 'b', 'o', 'x'):
-             {
-                 if (remaining < 8) {
-                     return OK;
-                 }
-                 parcel->writeInt32(KEY_STRUCT_TEXT_POS);
-                 parcel->writeInt32(U16_AT(tmpData));
-                 parcel->writeInt32(U16_AT(tmpData + 2));
                  parcel->writeInt32(U16_AT(tmpData + 4));
                  parcel->writeInt32(U16_AT(tmpData + 6));
  
                  tmpData += 8;
-                 remaining -= 8;
-                 break;
              }
-             // 'blnk' to specify the char range to be blinked
-             case FOURCC('b', 'l', 'n', 'k'):
-             {
-                 if (remaining < 4) {
-                     return OK;
-                 }
  
!                 parcel->writeInt32(KEY_STRUCT_BLINKING_TEXT_LIST);
  
!                 // start char offset
!                 parcel->writeInt32(U16_AT(tmpData));
!                 // end char offset
!                 parcel->writeInt32(U16_AT(tmpData + 2));
  
!                 tmpData += 4;
!                 remaining -= 4;
!                 break;
!             }
!             // 'twrp' box specifies text wrap behavior. If the value if 0x00,
!             // then no wrap. If it's 0x01, then automatic 'soft' wrap is enabled.
!             // 0x02-0xff are reserved.
!             case FOURCC('t', 'w', 'r', 'p'):
!             {
!                 if (remaining < 1) {
!                     return OK;
!                 }
!                 parcel->writeInt32(KEY_WRAP_TEXT);
!                 parcel->writeInt32(*tmpData);
! 
!                 tmpData += 1;
!                 remaining -= 1;
!                 break;
!             }
!             default:
!             {
!                 break;
!             }
          }
  
          data += chunkSize;
          size -= chunkSize;
      }
  
      return OK;
--- 69,283 ----
  // styles, and 'krok' box contains karaoke timing and positions.
  status_t TextDescriptions::extract3GPPLocalDescriptions(
          const uint8_t *data, ssize_t size,
!         int timeMs, Parcel *parcel, int depth) {
!     if (depth == 0) {
!         parcel->writeInt32(KEY_LOCAL_SETTING);
! 
!         // write start time to display this text sample
!         parcel->writeInt32(KEY_START_TIME);
!         parcel->writeInt32(timeMs);
! 
!         ssize_t textLen = (*data) << 8 | (*(data + 1));
! 
!         // write text sample length and text sample itself
!         parcel->writeInt32(KEY_STRUCT_TEXT);
!         parcel->writeInt32(textLen);
!         parcel->writeInt32(textLen);
!         parcel->write(data + 2, textLen);
! 
!         if (size > textLen) {
!             data += (textLen + 2);
!             size -= (textLen + 2);
!         } else {
!             return OK;
!         }
      }
  
!     const uint8_t *tmpData = data;
!     ssize_t chunkSize = U32_AT(tmpData);
!     uint32_t chunkType = U32_AT(tmpData + 4);
  
!     if (chunkSize <= 0) {
          return OK;
      }
  
!     tmpData += 8;
  
!     switch(chunkType) {
!         // 'styl' box specifies the style of the text.
!         case FOURCC('s', 't', 'y', 'l'):
!         {
!             uint16_t count = U16_AT(tmpData);
  
!             tmpData += 2;
  
!             for (int i = 0; i < count; i++) {
!                 parcel->writeInt32(KEY_STRUCT_STYLE_LIST);
!                 parcel->writeInt32(KEY_START_CHAR);
!                 parcel->writeInt32(U16_AT(tmpData));
  
!                 parcel->writeInt32(KEY_END_CHAR);
!                 parcel->writeInt32(U16_AT(tmpData + 2));
  
!                 parcel->writeInt32(KEY_FONT_ID);
!                 parcel->writeInt32(U16_AT(tmpData + 4));
  
!                 parcel->writeInt32(KEY_STYLE_FLAGS);
!                 parcel->writeInt32(*(tmpData + 6));
  
!                 parcel->writeInt32(KEY_FONT_SIZE);
!                 parcel->writeInt32(*(tmpData + 7));
  
!                 parcel->writeInt32(KEY_TEXT_COLOR_RGBA);
!                 uint32_t rgba = *(tmpData + 8) << 24 | *(tmpData + 9) << 16
!                     | *(tmpData + 10) << 8 | *(tmpData + 11);
                  parcel->writeInt32(rgba);
  
!                 tmpData += 12;
              }
  
!             break;
!         }
!         // 'krok' box. The number of highlight events is specified, and each
!         // event is specified by a starting and ending char offset and an end
!         // time for the event.
!         case FOURCC('k', 'r', 'o', 'k'):
!         {
! 
!             parcel->writeInt32(KEY_STRUCT_KARAOKE_LIST);
! 
!             int startTime = U32_AT(tmpData);
!             uint16_t count = U16_AT(tmpData + 4);
!             parcel->writeInt32(count);
  
!             tmpData += 6;
!             int lastEndTime = 0;
  
!             for (int i = 0; i < count; i++) {
!                 parcel->writeInt32(startTime + lastEndTime);
! 
!                 lastEndTime = U32_AT(tmpData);
!                 parcel->writeInt32(lastEndTime);
  
                  parcel->writeInt32(U16_AT(tmpData + 4));
                  parcel->writeInt32(U16_AT(tmpData + 6));
  
                  tmpData += 8;
              }
  
!             break;
!         }
!         // 'hlit' box specifies highlighted text
!         case FOURCC('h', 'l', 'i', 't'):
!         {
!             parcel->writeInt32(KEY_STRUCT_HIGHLIGHT_LIST);
! 
!             // the start char offset to highlight
!             parcel->writeInt32(U16_AT(tmpData));
!             // the last char offset to highlight
!             parcel->writeInt32(U16_AT(tmpData + 2));
  
!             break;
!         }
!         // 'hclr' box specifies the RGBA color: 8 bits each of
!         // red, green, blue, and an alpha(transparency) value
!         case FOURCC('h', 'c', 'l', 'r'):
!         {
!             parcel->writeInt32(KEY_HIGHLIGHT_COLOR_RGBA);
! 
!             uint32_t rgba = *(tmpData) << 24 | *(tmpData + 1) << 16
!                 | *(tmpData + 2) << 8 | *(tmpData + 3);
!             parcel->writeInt32(rgba);
  
!             break;
!         }
!         // 'dlay' box specifies a delay after a scroll in and/or
!         // before scroll out.
!         case FOURCC('d', 'l', 'a', 'y'):
!         {
!             parcel->writeInt32(KEY_SCROLL_DELAY);
! 
!             uint32_t delay = *(tmpData) << 24 | *(tmpData + 1) << 16
!                 | *(tmpData + 2) << 8 | *(tmpData + 3);
!             parcel->writeInt32(delay);
! 
!             break;
          }
+         // 'href' box for hyper text link
+         case FOURCC('h', 'r', 'e', 'f'):
+         {
+             parcel->writeInt32(KEY_STRUCT_HYPER_TEXT_LIST);
+ 
+             // the start offset of the text to be linked
+             parcel->writeInt32(U16_AT(tmpData));
+             // the end offset of the text
+             parcel->writeInt32(U16_AT(tmpData + 2));
+ 
+             // the number of bytes in the following URL
+             int len = *(tmpData + 4);
+             parcel->writeInt32(len);
+ 
+             // the linked-to URL
+             parcel->writeInt32(len);
+             parcel->write(tmpData + 5, len);
+ 
+             tmpData += (5 + len);
+ 
+             // the number of bytes in the following "alt" string
+             len = *tmpData;
+             parcel->writeInt32(len);
+ 
+             // an "alt" string for user display
+             parcel->writeInt32(len);
+             parcel->write(tmpData + 1, len);
  
+             break;
+         }
+         // 'tbox' box to indicate the position of the text with values
+         // of top, left, bottom and right
+         case FOURCC('t', 'b', 'o', 'x'):
+         {
+             parcel->writeInt32(KEY_STRUCT_TEXT_POS);
+             parcel->writeInt32(U16_AT(tmpData));
+             parcel->writeInt32(U16_AT(tmpData + 2));
+             parcel->writeInt32(U16_AT(tmpData + 4));
+             parcel->writeInt32(U16_AT(tmpData + 6));
+ 
+             break;
+         }
+         // 'blnk' to specify the char range to be blinked
+         case FOURCC('b', 'l', 'n', 'k'):
+         {
+             parcel->writeInt32(KEY_STRUCT_BLINKING_TEXT_LIST);
+ 
+             // start char offset
+             parcel->writeInt32(U16_AT(tmpData));
+             // end char offset
+             parcel->writeInt32(U16_AT(tmpData + 2));
+ 
+             break;
+         }
+         // 'twrp' box specifies text wrap behavior. If the value if 0x00,
+         // then no wrap. If it's 0x01, then automatic 'soft' wrap is enabled.
+         // 0x02-0xff are reserved.
+         case FOURCC('t', 'w', 'r', 'p'):
+         {
+             parcel->writeInt32(KEY_WRAP_TEXT);
+             parcel->writeInt32(*tmpData);
+ 
+             break;
+         }
+         default:
+         {
+             break;
+         }
+     }
+ 
+     if (size > chunkSize) {
          data += chunkSize;
          size -= chunkSize;
+         // continue to parse next box
+         return extract3GPPLocalDescriptions(data, size, 0, parcel, 1);
      }
  
      return OK;
***************
*** 372,505 ****
  
  // To extract box 'tx3g' defined in 3GPP TS 26.245, and store it in a Parcel
  status_t TextDescriptions::extract3GPPGlobalDescriptions(
!         const uint8_t *data, ssize_t size, Parcel *parcel) {
! 
!     parcel->writeInt32(KEY_GLOBAL_SETTING);
! 
!     while (size >= 8) {
!         ssize_t chunkSize = U32_AT(data);
!         uint32_t chunkType = U32_AT(data + 4);
!         const uint8_t *tmpData = data;
!         tmpData += 8;
!         size_t remaining = size - 8;
! 
!         if (size < chunkSize) {
!             return OK;
!         }
!         switch(chunkType) {
!             case FOURCC('t', 'x', '3', 'g'):
!             {
!                 if (remaining < 18) { // 8 just below, and another 10 a little further down
!                     return OK;
!                 }
!                 tmpData += 8; // skip the first 8 bytes
!                 remaining -=8;
!                 parcel->writeInt32(KEY_DISPLAY_FLAGS);
!                 parcel->writeInt32(U32_AT(tmpData));
! 
!                 parcel->writeInt32(KEY_STRUCT_JUSTIFICATION);
!                 parcel->writeInt32(tmpData[4]);
!                 parcel->writeInt32(tmpData[5]);
! 
!                 parcel->writeInt32(KEY_BACKGROUND_COLOR_RGBA);
!                 uint32_t rgba = *(tmpData + 6) << 24 | *(tmpData + 7) << 16
!                     | *(tmpData + 8) << 8 | *(tmpData + 9);
!                 parcel->writeInt32(rgba);
  
!                 tmpData += 10;
!                 remaining -= 10;
  
!                 if (remaining < 8) {
!                     return OK;
!                 }
!                 parcel->writeInt32(KEY_STRUCT_TEXT_POS);
!                 parcel->writeInt32(U16_AT(tmpData));
!                 parcel->writeInt32(U16_AT(tmpData + 2));
!                 parcel->writeInt32(U16_AT(tmpData + 4));
!                 parcel->writeInt32(U16_AT(tmpData + 6));
! 
!                 tmpData += 8;
!                 remaining -= 8;
  
!                 if (remaining < 12) {
!                     return OK;
!                 }
!                 parcel->writeInt32(KEY_STRUCT_STYLE_LIST);
!                 parcel->writeInt32(KEY_START_CHAR);
                  parcel->writeInt32(U16_AT(tmpData));
  
!                 parcel->writeInt32(KEY_END_CHAR);
!                 parcel->writeInt32(U16_AT(tmpData + 2));
  
!                 parcel->writeInt32(KEY_FONT_ID);
!                 parcel->writeInt32(U16_AT(tmpData + 4));
  
!                 parcel->writeInt32(KEY_STYLE_FLAGS);
!                 parcel->writeInt32(*(tmpData + 6));
! 
!                 parcel->writeInt32(KEY_FONT_SIZE);
!                 parcel->writeInt32(*(tmpData + 7));
! 
!                 parcel->writeInt32(KEY_TEXT_COLOR_RGBA);
!                 rgba = *(tmpData + 8) << 24 | *(tmpData + 9) << 16
!                     | *(tmpData + 10) << 8 | *(tmpData + 11);
!                 parcel->writeInt32(rgba);
! 
!                 tmpData += 12;
!                 remaining -= 12;
! 
!                 if (remaining < 2) {
!                     return OK;
!                 }
! 
!                 size_t dataPos = parcel->dataPosition();
! 
!                 parcel->writeInt32(KEY_STRUCT_FONT_LIST);
!                 uint16_t count = U16_AT(tmpData);
!                 parcel->writeInt32(count);
! 
!                 tmpData += 2;
!                 remaining -= 2;
! 
!                 for (int i = 0; i < count; i++) {
!                     if (remaining < 3) {
!                         // roll back
!                         parcel->setDataPosition(dataPos);
!                         return OK;
!                     }
!                     // font ID
!                     parcel->writeInt32(U16_AT(tmpData));
! 
!                     // font name length
!                     parcel->writeInt32(*(tmpData + 2));
! 
!                     size_t len = *(tmpData + 2);
! 
!                     tmpData += 3;
!                     remaining -= 3;
! 
!                     if (remaining < len) {
!                         // roll back
!                         parcel->setDataPosition(dataPos);
!                         return OK;
!                     }
! 
!                     parcel->write(tmpData, len);
!                     tmpData += len;
!                     remaining -= len;
!                 }
! 
!                 // there is a "DisparityBox" after this according to the spec, but we ignore it
!                 break;
!             }
!             default:
!             {
!                 break;
              }
          }
  
!         data += chunkSize;
!         size -= chunkSize;
      }
  
      return OK;
--- 285,382 ----
  
  // To extract box 'tx3g' defined in 3GPP TS 26.245, and store it in a Parcel
  status_t TextDescriptions::extract3GPPGlobalDescriptions(
!         const uint8_t *data, ssize_t size, Parcel *parcel, int depth) {
  
!     ssize_t chunkSize = U32_AT(data);
!     uint32_t chunkType = U32_AT(data + 4);
!     const uint8_t *tmpData = data;
!     tmpData += 8;
  
!     if (size < chunkSize) {
!         return OK;
!     }
  
!     if (depth == 0) {
!         parcel->writeInt32(KEY_GLOBAL_SETTING);
!     }
!     switch(chunkType) {
!         case FOURCC('t', 'x', '3', 'g'):
!         {
!             tmpData += 8; // skip the first 8 bytes
!             parcel->writeInt32(KEY_DISPLAY_FLAGS);
!             parcel->writeInt32(U32_AT(tmpData));
! 
!             parcel->writeInt32(KEY_STRUCT_JUSTIFICATION);
!             parcel->writeInt32(tmpData[4]);
!             parcel->writeInt32(tmpData[5]);
! 
!             parcel->writeInt32(KEY_BACKGROUND_COLOR_RGBA);
!             uint32_t rgba = *(tmpData + 6) << 24 | *(tmpData + 7) << 16
!                 | *(tmpData + 8) << 8 | *(tmpData + 9);
!             parcel->writeInt32(rgba);
! 
!             tmpData += 10;
!             parcel->writeInt32(KEY_STRUCT_TEXT_POS);
!             parcel->writeInt32(U16_AT(tmpData));
!             parcel->writeInt32(U16_AT(tmpData + 2));
!             parcel->writeInt32(U16_AT(tmpData + 4));
!             parcel->writeInt32(U16_AT(tmpData + 6));
! 
!             tmpData += 8;
!             parcel->writeInt32(KEY_STRUCT_STYLE_LIST);
!             parcel->writeInt32(KEY_START_CHAR);
!             parcel->writeInt32(U16_AT(tmpData));
! 
!             parcel->writeInt32(KEY_END_CHAR);
!             parcel->writeInt32(U16_AT(tmpData + 2));
! 
!             parcel->writeInt32(KEY_FONT_ID);
!             parcel->writeInt32(U16_AT(tmpData + 4));
! 
!             parcel->writeInt32(KEY_STYLE_FLAGS);
!             parcel->writeInt32(*(tmpData + 6));
! 
!             parcel->writeInt32(KEY_FONT_SIZE);
!             parcel->writeInt32(*(tmpData + 7));
! 
!             parcel->writeInt32(KEY_TEXT_COLOR_RGBA);
!             rgba = *(tmpData + 8) << 24 | *(tmpData + 9) << 16
!                 | *(tmpData + 10) << 8 | *(tmpData + 11);
!             parcel->writeInt32(rgba);
! 
!             tmpData += 12;
!             parcel->writeInt32(KEY_STRUCT_FONT_LIST);
!             uint16_t count = U16_AT(tmpData);
!             parcel->writeInt32(count);
! 
!             tmpData += 2;
!             for (int i = 0; i < count; i++) {
!                 // font ID
                  parcel->writeInt32(U16_AT(tmpData));
  
!                 // font name length
!                 parcel->writeInt32(*(tmpData + 2));
  
!                 int len = *(tmpData + 2);
  
!                 parcel->write(tmpData + 3, len);
!                 tmpData += 3 + len;
              }
+ 
+             break;
+         }
+         default:
+         {
+             break;
          }
+     }
  
!     data += chunkSize;
!     size -= chunkSize;
! 
!     if (size > 0) {
!         // continue to extract next 'tx3g'
!         return extract3GPPGlobalDescriptions(data, size, parcel, 1);
      }
  
      return OK;
diff '--exclude=.git' -crB a/media/libstagefright/timedtext/TextDescriptions.h b/media/libstagefright/timedtext/TextDescriptions.h
*** a/media/libstagefright/timedtext/TextDescriptions.h	2018-09-22 10:19:51.773278241 +0200
--- b/media/libstagefright/timedtext/TextDescriptions.h	2018-09-22 10:11:05.452312621 +0200
***************
*** 72,81 ****
              int timeMs, Parcel *parcel);
      static status_t extract3GPPGlobalDescriptions(
              const uint8_t *data, ssize_t size,
!             Parcel *parcel);
      static status_t extract3GPPLocalDescriptions(
              const uint8_t *data, ssize_t size,
!             int timeMs, Parcel *parcel);
  
      DISALLOW_EVIL_CONSTRUCTORS(TextDescriptions);
  };
--- 72,81 ----
              int timeMs, Parcel *parcel);
      static status_t extract3GPPGlobalDescriptions(
              const uint8_t *data, ssize_t size,
!             Parcel *parcel, int depth);
      static status_t extract3GPPLocalDescriptions(
              const uint8_t *data, ssize_t size,
!             int timeMs, Parcel *parcel, int depth);
  
      DISALLOW_EVIL_CONSTRUCTORS(TextDescriptions);
  };
diff '--exclude=.git' -crB a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
*** a/media/libstagefright/Utils.cpp	2018-09-22 10:19:51.677278066 +0200
--- b/media/libstagefright/Utils.cpp	2018-09-22 10:11:05.448312615 +0200
***************
*** 81,103 ****
      return ((uint64_t)htonl(x & 0xffffffff) << 32) | htonl(x >> 32);
  }
  
- static status_t copyNALUToABuffer(sp<ABuffer> *buffer, const uint8_t *ptr, size_t length) {
-     if (((*buffer)->size() + 4 + length) > ((*buffer)->capacity() - (*buffer)->offset())) {
-         sp<ABuffer> tmpBuffer = new (std::nothrow) ABuffer((*buffer)->size() + 4 + length + 1024);
-         if (tmpBuffer.get() == NULL || tmpBuffer->base() == NULL) {
-             return NO_MEMORY;
-         }
-         memcpy(tmpBuffer->data(), (*buffer)->data(), (*buffer)->size());
-         tmpBuffer->setRange(0, (*buffer)->size());
-         (*buffer) = tmpBuffer;
-     }
- 
-     memcpy((*buffer)->data() + (*buffer)->size(), "\x00\x00\x00\x01", 4);
-     memcpy((*buffer)->data() + (*buffer)->size() + 4, ptr, length);
-     (*buffer)->setRange((*buffer)->offset(), (*buffer)->size() + 4 + length);
-     return OK;
- }
- 
  status_t convertMetaDataToMessage(
          const sp<MetaData> &meta, sp<AMessage> *format) {
      format->clear();
--- 81,86 ----
***************
*** 173,182 ****
  
          const uint8_t *ptr = (const uint8_t *)data;
  
!         if (size < 7 || ptr[0] != 1) {  // configurationVersion == 1
!             ALOGE("b/23680780");
!             return BAD_VALUE;
!         }
          uint8_t profile = ptr[1];
          uint8_t level = ptr[3];
  
--- 156,163 ----
  
          const uint8_t *ptr = (const uint8_t *)data;
  
!         CHECK(size >= 7);
!         CHECK_EQ((unsigned)ptr[0], 1u);  // configurationVersion == 1
          uint8_t profile = ptr[1];
          uint8_t level = ptr[3];
  
***************
*** 195,223 ****
          ptr += 6;
          size -= 6;
  
!         sp<ABuffer> buffer = new (std::nothrow) ABuffer(1024);
!         if (buffer.get() == NULL || buffer->base() == NULL) {
!             return NO_MEMORY;
!         }
          buffer->setRange(0, 0);
  
          for (size_t i = 0; i < numSeqParameterSets; ++i) {
!             if (size < 2) {
!                 ALOGE("b/23680780");
!                 return BAD_VALUE;
!             }
              size_t length = U16_AT(ptr);
  
              ptr += 2;
              size -= 2;
  
!             if (size < length) {
!                 return BAD_VALUE;
!             }
!             status_t err = copyNALUToABuffer(&buffer, ptr, length);
!             if (err != OK) {
!                 return err;
!             }
  
              ptr += length;
              size -= length;
--- 176,196 ----
          ptr += 6;
          size -= 6;
  
!         sp<ABuffer> buffer = new ABuffer(1024);
          buffer->setRange(0, 0);
  
          for (size_t i = 0; i < numSeqParameterSets; ++i) {
!             CHECK(size >= 2);
              size_t length = U16_AT(ptr);
  
              ptr += 2;
              size -= 2;
  
!             CHECK(size >= length);
! 
!             memcpy(buffer->data() + buffer->size(), "\x00\x00\x00\x01", 4);
!             memcpy(buffer->data() + buffer->size() + 4, ptr, length);
!             buffer->setRange(0, buffer->size() + 4 + length);
  
              ptr += length;
              size -= length;
***************
*** 228,264 ****
  
          msg->setBuffer("csd-0", buffer);
  
!         buffer = new (std::nothrow) ABuffer(1024);
!         if (buffer.get() == NULL || buffer->base() == NULL) {
!             return NO_MEMORY;
!         }
          buffer->setRange(0, 0);
  
!         if (size < 1) {
!             ALOGE("b/23680780");
!             return BAD_VALUE;
!         }
          size_t numPictureParameterSets = *ptr;
          ++ptr;
          --size;
  
          for (size_t i = 0; i < numPictureParameterSets; ++i) {
!             if (size < 2) {
!                 ALOGE("b/23680780");
!                 return BAD_VALUE;
!             }
              size_t length = U16_AT(ptr);
  
              ptr += 2;
              size -= 2;
  
!             if (size < length) {
!                 return BAD_VALUE;
!             }
!             status_t err = copyNALUToABuffer(&buffer, ptr, length);
!             if (err != OK) {
!                 return err;
!             }
  
              ptr += length;
              size -= length;
--- 201,226 ----
  
          msg->setBuffer("csd-0", buffer);
  
!         buffer = new ABuffer(1024);
          buffer->setRange(0, 0);
  
!         CHECK(size >= 1);
          size_t numPictureParameterSets = *ptr;
          ++ptr;
          --size;
  
          for (size_t i = 0; i < numPictureParameterSets; ++i) {
!             CHECK(size >= 2);
              size_t length = U16_AT(ptr);
  
              ptr += 2;
              size -= 2;
  
!             CHECK(size >= length);
! 
!             memcpy(buffer->data() + buffer->size(), "\x00\x00\x00\x01", 4);
!             memcpy(buffer->data() + buffer->size() + 4, ptr, length);
!             buffer->setRange(0, buffer->size() + 4 + length);
  
              ptr += length;
              size -= length;
***************
*** 276,285 ****
          esds.getCodecSpecificInfo(
                  &codec_specific_data, &codec_specific_data_size);
  
!         sp<ABuffer> buffer = new (std::nothrow) ABuffer(codec_specific_data_size);
!         if (buffer.get() == NULL || buffer->base() == NULL) {
!             return NO_MEMORY;
!         }
  
          memcpy(buffer->data(), codec_specific_data,
                 codec_specific_data_size);
--- 238,244 ----
          esds.getCodecSpecificInfo(
                  &codec_specific_data, &codec_specific_data_size);
  
!         sp<ABuffer> buffer = new ABuffer(codec_specific_data_size);
  
          memcpy(buffer->data(), codec_specific_data,
                 codec_specific_data_size);
***************
*** 288,297 ****
          buffer->meta()->setInt64("timeUs", 0);
          msg->setBuffer("csd-0", buffer);
      } else if (meta->findData(kKeyVorbisInfo, &type, &data, &size)) {
!         sp<ABuffer> buffer = new (std::nothrow) ABuffer(size);
!         if (buffer.get() == NULL || buffer->base() == NULL) {
!             return NO_MEMORY;
!         }
          memcpy(buffer->data(), data, size);
  
          buffer->meta()->setInt32("csd", true);
--- 247,253 ----
          buffer->meta()->setInt64("timeUs", 0);
          msg->setBuffer("csd-0", buffer);
      } else if (meta->findData(kKeyVorbisInfo, &type, &data, &size)) {
!         sp<ABuffer> buffer = new ABuffer(size);
          memcpy(buffer->data(), data, size);
  
          buffer->meta()->setInt32("csd", true);
***************
*** 302,311 ****
              return -EINVAL;
          }
  
!         buffer = new (std::nothrow) ABuffer(size);
!         if (buffer.get() == NULL || buffer->base() == NULL) {
!             return NO_MEMORY;
!         }
          memcpy(buffer->data(), data, size);
  
          buffer->meta()->setInt32("csd", true);
--- 258,264 ----
              return -EINVAL;
          }
  
!         buffer = new ABuffer(size);
          memcpy(buffer->data(), data, size);
  
          buffer->meta()->setInt32("csd", true);
***************
*** 500,538 ****
      // reassemble the csd data into its original form
      sp<ABuffer> csd0;
      if (msg->findBuffer("csd-0", &csd0)) {
-         int csd0size = csd0->size();
          if (mime.startsWith("video/")) { // do we need to be stricter than this?
              if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_VIDEO_AVC)) {
                  sp<ABuffer> csd1;
                  if (msg->findBuffer("csd-1", &csd1)) {
!                     Vector<char> avcc;
!                     int avccSize = csd0size + csd1->size() + 1024;
!                     if (avcc.resize(avccSize) < 0) {
!                         ALOGE("error allocating avcc (size %d); abort setting avcc.", avccSize);
!                     } else {
!                         size_t outsize = reassembleAVCC(csd0, csd1, avcc.editArray());
!                         meta->setData(kKeyAVCC, kKeyAVCC, avcc.array(), outsize);
!                     }
                  }
              } else if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_VIDEO_MPEG4)) {
!                 Vector<char> esds;
!                 int esdsSize = csd0size + 31;
!                 if (esds.resize(esdsSize) < 0) {
!                     ALOGE("error allocating esds (size %d); abort setting esds.", esdsSize);
!                 } else {
!                     reassembleESDS(csd0, esds.editArray());
!                     meta->setData(kKeyESDS, kKeyESDS, esds.array(), esds.size());
!                 }
              }
          } else if (mime.startsWith("audio/")) {
!             Vector<char> esds;
!             int esdsSize = csd0size + 31;
!             if (esds.resize(esdsSize) < 0) {
!                 ALOGE("error allocating esds (size %d); abort setting esds.", esdsSize);
!             } else {
!                 reassembleESDS(csd0, esds.editArray());
!                 meta->setData(kKeyESDS, kKeyESDS, esds.array(), esds.size());
!             }
          }
      }
  
--- 453,478 ----
      // reassemble the csd data into its original form
      sp<ABuffer> csd0;
      if (msg->findBuffer("csd-0", &csd0)) {
          if (mime.startsWith("video/")) { // do we need to be stricter than this?
              if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_VIDEO_AVC)) {
                  sp<ABuffer> csd1;
                  if (msg->findBuffer("csd-1", &csd1)) {
!                     char avcc[1024]; // that oughta be enough, right?
!                     size_t outsize = reassembleAVCC(csd0, csd1, avcc);
!                     meta->setData(kKeyAVCC, kKeyAVCC, avcc, outsize);
                  }
              } else if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_VIDEO_MPEG4)) {
!                 int csd0size = csd0->size();
!                 char esds[csd0size + 31];
!                 reassembleESDS(csd0, esds);
!                 meta->setData(kKeyESDS, kKeyESDS, esds, sizeof(esds));
              }
+ 
          } else if (mime.startsWith("audio/")) {
!             int csd0size = csd0->size();
!             char esds[csd0size + 31];
!             reassembleESDS(csd0, esds);
!             meta->setData(kKeyESDS, kKeyESDS, esds, sizeof(esds));
          }
      }
  
diff '--exclude=.git' -crB a/media/mediaserver/Android.mk b/media/mediaserver/Android.mk
*** a/media/mediaserver/Android.mk	2018-09-22 10:19:51.777278249 +0200
--- b/media/mediaserver/Android.mk	2018-09-22 10:11:05.456312630 +0200
***************
*** 35,41 ****
  
  LOCAL_C_INCLUDES := \
      frameworks/av/media/libmediaplayerservice \
-     frameworks/av/media/libmedia \
      frameworks/av/services/medialog \
      frameworks/av/services/audioflinger \
      frameworks/av/services/camera/libcameraservice
--- 35,40 ----
diff '--exclude=.git' -crB a/media/mediaserver/main_mediaserver.cpp b/media/mediaserver/main_mediaserver.cpp
*** a/media/mediaserver/main_mediaserver.cpp	2018-09-22 10:19:51.777278249 +0200
--- b/media/mediaserver/main_mediaserver.cpp	2018-09-22 10:11:05.456312630 +0200
***************
*** 33,39 ****
  #include "CameraService.h"
  #include "MediaLogService.h"
  #include "MediaPlayerService.h"
- #include "MediaUtils.h"
  #include "AudioPolicyService.h"
  #ifdef AUDIO_LISTEN_ENABLED
  #include "ListenService.h"
--- 33,38 ----
***************
*** 47,59 ****
  } }
  #endif
  
! int main(int argc __unused, char** argv)
  {
-     limitProcessMemory(
-         "ro.media.maxmem", /* property that defines limit */
-         SIZE_MAX, /* upper limit in bytes */
-         65 /* upper limit as percentage of physical RAM */);
- 
      signal(SIGPIPE, SIG_IGN);
      char value[PROPERTY_VALUE_MAX];
      bool doLog = (property_get("ro.test_harness", value, "0") > 0) && (atoi(value) == 1);
--- 46,53 ----
  } }
  #endif
  
! int main(int argc, char** argv)
  {
      signal(SIGPIPE, SIG_IGN);
      char value[PROPERTY_VALUE_MAX];
      bool doLog = (property_get("ro.test_harness", value, "0") > 0) && (atoi(value) == 1);
diff '--exclude=.git' -crB a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
*** a/services/audioflinger/AudioFlinger.cpp	2018-09-22 10:19:51.777278249 +0200
--- b/services/audioflinger/AudioFlinger.cpp	2018-09-22 10:11:05.456312630 +0200
***************
*** 860,871 ****
      // assigned to HALs which do not have master volume support will apply
      // master volume during the mix operation.  Threads with HALs which do
      // support master volume will simply ignore the setting.
!     for (size_t i = 0; i < mPlaybackThreads.size(); i++) {
!         if (mPlaybackThreads.valueAt(i)->isDuplicating()) {
!             continue;
!         }
          mPlaybackThreads.valueAt(i)->setMasterVolume(value);
-     }
  
      return NO_ERROR;
  }
--- 860,867 ----
      // assigned to HALs which do not have master volume support will apply
      // master volume during the mix operation.  Threads with HALs which do
      // support master volume will simply ignore the setting.
!     for (size_t i = 0; i < mPlaybackThreads.size(); i++)
          mPlaybackThreads.valueAt(i)->setMasterVolume(value);
  
      return NO_ERROR;
  }
***************
*** 972,983 ****
      // assigned to HALs which do not have master mute support will apply master
      // mute during the mix operation.  Threads with HALs which do support master
      // mute will simply ignore the setting.
!     for (size_t i = 0; i < mPlaybackThreads.size(); i++) {
!         if (mPlaybackThreads.valueAt(i)->isDuplicating()) {
!             continue;
!         }
          mPlaybackThreads.valueAt(i)->setMasterMute(muted);
-     }
  #endif
  
      return NO_ERROR;
--- 968,975 ----
      // assigned to HALs which do not have master mute support will apply master
      // mute during the mix operation.  Threads with HALs which do support master
      // mute will simply ignore the setting.
!     for (size_t i = 0; i < mPlaybackThreads.size(); i++)
          mPlaybackThreads.valueAt(i)->setMasterMute(muted);
  #endif
  
      return NO_ERROR;
***************
*** 2089,2095 ****
  
          if (thread->type() == ThreadBase::MIXER) {
              for (size_t i = 0; i < mPlaybackThreads.size(); i++) {
!                 if (mPlaybackThreads.valueAt(i)->isDuplicating()) {
                      DuplicatingThread *dupThread =
                              (DuplicatingThread *)mPlaybackThreads.valueAt(i).get();
                      dupThread->removeOutputTrack((MixerThread *)thread.get());
--- 2081,2087 ----
  
          if (thread->type() == ThreadBase::MIXER) {
              for (size_t i = 0; i < mPlaybackThreads.size(); i++) {
!                 if (mPlaybackThreads.valueAt(i)->type() == ThreadBase::DUPLICATING) {
                      DuplicatingThread *dupThread =
                              (DuplicatingThread *)mPlaybackThreads.valueAt(i).get();
                      dupThread->removeOutputTrack((MixerThread *)thread.get());
***************
*** 2120,2126 ****
      // The thread entity (active unit of execution) is no longer running here,
      // but the ThreadBase container still exists.
  
!     if (!thread->isDuplicating()) {
          AudioStreamOut *out = thread->clearOutput();
          ALOG_ASSERT(out != NULL, "out shouldn't be NULL");
          // from now on thread->mOutput is NULL
--- 2112,2118 ----
      // The thread entity (active unit of execution) is no longer running here,
      // but the ThreadBase container still exists.
  
!     if (thread->type() != ThreadBase::DUPLICATING) {
          AudioStreamOut *out = thread->clearOutput();
          ALOG_ASSERT(out != NULL, "out shouldn't be NULL");
          // from now on thread->mOutput is NULL
***************
*** 2515,2523 ****
  {
      for (size_t i = 0; i < mPlaybackThreads.size(); i++) {
          PlaybackThread *thread = mPlaybackThreads.valueAt(i).get();
-         if(thread->isDuplicating()) {
-             continue;
-         }
          AudioStreamOut *output = thread->getOutput();
          if (output != NULL && output->audioHwDev == mPrimaryHardwareDev) {
              return thread;
--- 2507,2512 ----
diff '--exclude=.git' -crB a/services/audioflinger/Effects.cpp b/services/audioflinger/Effects.cpp
*** a/services/audioflinger/Effects.cpp	2018-09-22 10:19:51.781278256 +0200
--- b/services/audioflinger/Effects.cpp	2018-09-22 10:11:05.456312630 +0200
***************
*** 559,571 ****
      return NO_ERROR;
  }
  
- // round up delta valid if value and divisor are positive.
- template <typename T>
- static T roundUpDelta(const T &value, const T &divisor) {
-     T remainder = value % divisor;
-     return remainder == 0 ? 0 : divisor - remainder;
- }
- 
  status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,
                                               uint32_t cmdSize,
                                               void *pCmdData,
--- 559,564 ----
***************
*** 581,608 ****
      if (mStatus != NO_ERROR) {
          return mStatus;
      }
-     if (cmdCode == EFFECT_CMD_GET_PARAM &&
-             (*replySize < sizeof(effect_param_t) ||
-                     ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {
-         android_errorWriteLog(0x534e4554, "29251553");
-         return -EINVAL;
-     }
-     if ((cmdCode == EFFECT_CMD_SET_PARAM
-             || cmdCode == EFFECT_CMD_SET_PARAM_DEFERRED) &&  // DEFERRED not generally used
-         (sizeof(effect_param_t) > cmdSize
-             || ((effect_param_t *)pCmdData)->psize > cmdSize
-                                                      - sizeof(effect_param_t)
-             || ((effect_param_t *)pCmdData)->vsize > cmdSize
-                                                      - sizeof(effect_param_t)
-                                                      - ((effect_param_t *)pCmdData)->psize
-             || roundUpDelta(((effect_param_t *)pCmdData)->psize, (uint32_t)sizeof(int)) >
-                                                      cmdSize
-                                                      - sizeof(effect_param_t)
-                                                      - ((effect_param_t *)pCmdData)->psize
-                                                      - ((effect_param_t *)pCmdData)->vsize)) {
-         android_errorWriteLog(0x534e4554, "30204301");
-         return -EINVAL;
-     }
      status_t status = (*mEffectInterface)->command(mEffectInterface,
                                                     cmdCode,
                                                     cmdSize,
--- 574,579 ----
diff '--exclude=.git' -crB a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
*** a/services/audioflinger/Threads.cpp	2018-09-22 10:19:51.785278264 +0200
--- b/services/audioflinger/Threads.cpp	2018-09-22 10:11:05.456312630 +0200
***************
*** 4720,4732 ****
              mOutputTracks[i]->destroy();
              mOutputTracks.removeAt(i);
              updateWaitTime_l();
-             if (thread->getOutput() == mOutput) {
-                 mOutput = NULL;
-             }
              return;
          }
      }
!     ALOGV("removeOutputTrack(): unknown thread: %p", thread);
  }
  
  // caller must hold mLock
--- 4720,4729 ----
              mOutputTracks[i]->destroy();
              mOutputTracks.removeAt(i);
              updateWaitTime_l();
              return;
          }
      }
!     ALOGV("removeOutputTrack(): unkonwn thread: %p", thread);
  }
  
  // caller must hold mLock
***************
*** 5714,5720 ****
      mBufferSize = mInput->stream->common.get_buffer_size(&mInput->stream->common);
      mFrameCount = mBufferSize / mFrameSize;
      mRsmpInBuffer = new int16_t[mFrameCount * mChannelCount];
-     memset(mRsmpInBuffer, 0, mFrameCount * mChannelCount * sizeof(mRsmpInBuffer[0]));
  
      if (mSampleRate != mReqSampleRate && mChannelCount <= FCC_2 && mReqChannelCount <= FCC_2)
      {
--- 5711,5716 ----
diff '--exclude=.git' -crB a/services/audioflinger/Threads.h b/services/audioflinger/Threads.h
*** a/services/audioflinger/Threads.h	2018-09-22 10:19:51.785278264 +0200
--- b/services/audioflinger/Threads.h	2018-09-22 10:11:05.460312636 +0200
***************
*** 119,126 ****
  
                  // static externally-visible
                  type_t      type() const { return mType; }
-                 bool isDuplicating() const { return (mType == DUPLICATING); }
- 
                  audio_io_handle_t id() const { return mId;}
  
                  // dynamic externally-visible
--- 119,124 ----
diff '--exclude=.git' -crB a/services/camera/libcameraservice/api1/Camera2Client.cpp b/services/camera/libcameraservice/api1/Camera2Client.cpp
*** a/services/camera/libcameraservice/api1/Camera2Client.cpp	2018-09-22 10:19:51.785278264 +0200
--- b/services/camera/libcameraservice/api1/Camera2Client.cpp	2018-09-22 10:11:05.460312636 +0200
***************
*** 158,167 ****
  }
  
  status_t Camera2Client::dump(int fd, const Vector<String16>& args) {
-     return BasicClient::dump(fd, args);
- }
- 
- status_t Camera2Client::dumpClient(int fd, const Vector<String16>& args) {
      String8 result;
      result.appendFormat("Client2[%d] (%p) Client: %s PID: %d, dump:\n",
              mCameraId,
--- 158,163 ----
diff '--exclude=.git' -crB a/services/camera/libcameraservice/api1/Camera2Client.h b/services/camera/libcameraservice/api1/Camera2Client.h
*** a/services/camera/libcameraservice/api1/Camera2Client.h	2018-09-22 10:19:51.785278264 +0200
--- b/services/camera/libcameraservice/api1/Camera2Client.h	2018-09-22 10:11:05.460312636 +0200
***************
*** 98,105 ****
  
      virtual status_t dump(int fd, const Vector<String16>& args);
  
-     virtual status_t dumpClient(int fd, const Vector<String16>& args);
- 
      /**
       * Interface used by CameraDeviceBase
       */
--- 98,103 ----
diff '--exclude=.git' -crB a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
*** a/services/camera/libcameraservice/api1/CameraClient.cpp	2018-09-22 10:19:51.785278264 +0200
--- b/services/camera/libcameraservice/api1/CameraClient.cpp	2018-09-22 10:11:05.460312636 +0200
***************
*** 116,125 ****
  }
  
  status_t CameraClient::dump(int fd, const Vector<String16>& args) {
-     return BasicClient::dump(fd, args);
- }
- 
- status_t CameraClient::dumpClient(int fd, const Vector<String16>& args) {
      const size_t SIZE = 256;
      char buffer[SIZE];
      status_t rc = INVALID_OPERATION;
--- 116,121 ----
diff '--exclude=.git' -crB a/services/camera/libcameraservice/api1/CameraClient.h b/services/camera/libcameraservice/api1/CameraClient.h
*** a/services/camera/libcameraservice/api1/CameraClient.h	2018-09-22 10:19:51.785278264 +0200
--- b/services/camera/libcameraservice/api1/CameraClient.h	2018-09-22 10:11:05.460312636 +0200
***************
*** 69,77 ****
  
      status_t initialize(camera_module_t *module);
  
!     virtual status_t dump(int fd, const Vector<String16>& args);
! 
!     virtual status_t dumpClient(int fd, const Vector<String16>& args);
  
  private:
  
--- 69,75 ----
  
      status_t initialize(camera_module_t *module);
  
!     status_t dump(int fd, const Vector<String16>& args);
  
  private:
  
diff '--exclude=.git' -crB a/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp b/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp
*** a/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp	2018-09-22 10:19:51.789278271 +0200
--- b/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp	2018-09-22 10:11:05.460312636 +0200
***************
*** 29,35 ****
  #include <utils/Trace.h>
  #include <gui/Surface.h>
  #include <media/hardware/MetadataBufferType.h>
- #include <camera/ICameraRecordingProxy.h>
  
  #include "common/CameraDeviceBase.h"
  #include "api1/Camera2Client.h"
--- 29,34 ----
***************
*** 709,718 ****
          uint8_t *data = (uint8_t*)heap->getBase() + offset;
          uint32_t type = kMetadataBufferTypeGrallocSource;
          *((uint32_t*)data) = type;
!         buffer_handle_t* pBuffer = (buffer_handle_t*)(data + 4);
!         *pBuffer = (buffer_handle_t)(
!                 (uint8_t*)imgBuffer.mGraphicBuffer->handle -
!                 ICameraRecordingProxy::getCommonBaseAddress());
          ALOGVV("%s: Camera %d: Sending out buffer_handle_t %p",
                  __FUNCTION__, mId,
                  imgBuffer.mGraphicBuffer->handle);
--- 708,714 ----
          uint8_t *data = (uint8_t*)heap->getBase() + offset;
          uint32_t type = kMetadataBufferTypeGrallocSource;
          *((uint32_t*)data) = type;
!         *((buffer_handle_t*)(data + 4)) = imgBuffer.mGraphicBuffer->handle;
          ALOGVV("%s: Camera %d: Sending out buffer_handle_t %p",
                  __FUNCTION__, mId,
                  imgBuffer.mGraphicBuffer->handle);
***************
*** 758,767 ****
      }
  
      // Release the buffer back to the recording queue
!     // b/28466701
!     buffer_handle_t* pBuffer = (buffer_handle_t*)(data + 4);
!     buffer_handle_t imgHandle = (buffer_handle_t)((uint8_t*)(*pBuffer) +
!             ICameraRecordingProxy::getCommonBaseAddress());
  
      size_t itemIndex;
      for (itemIndex = 0; itemIndex < mRecordingBuffers.size(); itemIndex++) {
--- 754,761 ----
      }
  
      // Release the buffer back to the recording queue
! 
!     buffer_handle_t imgHandle = *(buffer_handle_t*)(data + 4);
  
      size_t itemIndex;
      for (itemIndex = 0; itemIndex < mRecordingBuffers.size(); itemIndex++) {
diff '--exclude=.git' -crB a/services/camera/libcameraservice/api2/CameraDeviceClient.cpp b/services/camera/libcameraservice/api2/CameraDeviceClient.cpp
*** a/services/camera/libcameraservice/api2/CameraDeviceClient.cpp	2018-09-22 10:19:51.789278271 +0200
--- b/services/camera/libcameraservice/api2/CameraDeviceClient.cpp	2018-09-22 10:11:05.460312636 +0200
***************
*** 480,489 ****
  }
  
  status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {
-     return BasicClient::dump(fd, args);
- }
- 
- status_t CameraDeviceClient::dumpClient(int fd, const Vector<String16>& args) {
      String8 result;
      result.appendFormat("CameraDeviceClient[%d] (%p) PID: %d, dump:\n",
              mCameraId,
--- 480,485 ----
diff '--exclude=.git' -crB a/services/camera/libcameraservice/api2/CameraDeviceClient.h b/services/camera/libcameraservice/api2/CameraDeviceClient.h
*** a/services/camera/libcameraservice/api2/CameraDeviceClient.h	2018-09-22 10:19:51.789278271 +0200
--- b/services/camera/libcameraservice/api2/CameraDeviceClient.h	2018-09-22 10:11:05.460312636 +0200
***************
*** 109,116 ****
  
      virtual status_t      dump(int fd, const Vector<String16>& args);
  
-     virtual status_t      dumpClient(int fd, const Vector<String16>& args);
- 
      /**
       * Device listener interface
       */
--- 109,114 ----
diff '--exclude=.git' -crB a/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp b/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp
*** a/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp	2018-09-22 10:19:51.789278271 +0200
--- b/services/camera/libcameraservice/api_pro/ProCamera2Client.cpp	2018-09-22 10:11:05.460312636 +0200
***************
*** 331,340 ****
  }
  
  status_t ProCamera2Client::dump(int fd, const Vector<String16>& args) {
-     return BasicClient::dump(fd, args);
- }
- 
- status_t ProCamera2Client::dumpClient(int fd, const Vector<String16>& args) {
      String8 result;
      result.appendFormat("ProCamera2Client[%d] (%p) PID: %d, dump:\n",
              mCameraId,
--- 331,336 ----
diff '--exclude=.git' -crB a/services/camera/libcameraservice/api_pro/ProCamera2Client.h b/services/camera/libcameraservice/api_pro/ProCamera2Client.h
*** a/services/camera/libcameraservice/api_pro/ProCamera2Client.h	2018-09-22 10:19:51.789278271 +0200
--- b/services/camera/libcameraservice/api_pro/ProCamera2Client.h	2018-09-22 10:11:05.460312636 +0200
***************
*** 88,95 ****
  
      virtual status_t      dump(int fd, const Vector<String16>& args);
  
-     virtual status_t      dumpClient(int fd, const Vector<String16>& args);
- 
      // Callbacks from camera service
      virtual void onExclusiveLockStolen();
  
--- 88,93 ----
diff '--exclude=.git' -crB a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
*** a/services/camera/libcameraservice/CameraService.cpp	2018-09-22 10:19:51.785278264 +0200
--- b/services/camera/libcameraservice/CameraService.cpp	2018-09-22 10:11:05.460312636 +0200
***************
*** 1000,1013 ****
      mClientPid = 0;
  }
  
- status_t CameraService::BasicClient::dump(int, const Vector<String16>&) {
-     // No dumping of clients directly over Binder,
-     // must go through CameraService::dump
-     android_errorWriteWithInfoLog(SN_EVENT_LOG_ID, "26265403",
-             IPCThreadState::self()->getCallingUid(), NULL, 0);
-     return OK;
- }
- 
  status_t CameraService::BasicClient::startCameraOps() {
      int32_t res;
  
--- 1000,1005 ----
***************
*** 1245,1251 ****
              hasClient = true;
              result = String8::format("  Device is open. Client instance dump:\n");
              write(fd, result.string(), result.size());
!             client->dumpClient(fd, args);
          }
          if (!hasClient) {
              result = String8::format("\nNo active camera clients yet.\n");
--- 1237,1243 ----
              hasClient = true;
              result = String8::format("  Device is open. Client instance dump:\n");
              write(fd, result.string(), result.size());
!             client->dump(fd, args);
          }
          if (!hasClient) {
              result = String8::format("\nNo active camera clients yet.\n");
diff '--exclude=.git' -crB a/services/camera/libcameraservice/CameraService.h b/services/camera/libcameraservice/CameraService.h
*** a/services/camera/libcameraservice/CameraService.h	2018-09-22 10:19:51.785278264 +0200
--- b/services/camera/libcameraservice/CameraService.h	2018-09-22 10:11:05.460312636 +0200
***************
*** 59,67 ****
      class Client;
      class BasicClient;
  
-     // Event log ID
-     static const int SN_EVENT_LOG_ID = 0x534e4554;
- 
      // Implementation of BinderService<T>
      static char const* getServiceName() { return "media.camera"; }
  
--- 59,64 ----
***************
*** 151,160 ****
              return mRemoteBinder;
          }
  
!         // Disallows dumping over binder interface
!         virtual status_t      dump(int fd, const Vector<String16>& args);
!         // Internal dump method to be called by CameraService
!         virtual status_t      dumpClient(int fd, const Vector<String16>& args) = 0;
  
      protected:
          BasicClient(const sp<CameraService>& cameraService,
--- 148,154 ----
              return mRemoteBinder;
          }
  
!         virtual status_t      dump(int fd, const Vector<String16>& args) = 0;
  
      protected:
          BasicClient(const sp<CameraService>& cameraService,
diff '--exclude=.git' -crB a/services/camera/libcameraservice/common/Camera2ClientBase.cpp b/services/camera/libcameraservice/common/Camera2ClientBase.cpp
*** a/services/camera/libcameraservice/common/Camera2ClientBase.cpp	2018-09-22 10:19:51.789278271 +0200
--- b/services/camera/libcameraservice/common/Camera2ClientBase.cpp	2018-09-22 10:11:05.460312636 +0200
***************
*** 117,123 ****
  }
  
  template <typename TClientBase>
! status_t Camera2ClientBase<TClientBase>::dumpClient(int fd,
                                                const Vector<String16>& args) {
      String8 result;
      result.appendFormat("Camera2ClientBase[%d] (%p) PID: %d, dump:\n",
--- 117,123 ----
  }
  
  template <typename TClientBase>
! status_t Camera2ClientBase<TClientBase>::dump(int fd,
                                                const Vector<String16>& args) {
      String8 result;
      result.appendFormat("Camera2ClientBase[%d] (%p) PID: %d, dump:\n",
diff '--exclude=.git' -crB a/services/camera/libcameraservice/common/Camera2ClientBase.h b/services/camera/libcameraservice/common/Camera2ClientBase.h
*** a/services/camera/libcameraservice/common/Camera2ClientBase.h	2018-09-22 10:19:51.789278271 +0200
--- b/services/camera/libcameraservice/common/Camera2ClientBase.h	2018-09-22 10:11:05.460312636 +0200
***************
*** 55,61 ****
      virtual ~Camera2ClientBase();
  
      virtual status_t      initialize(camera_module_t *module);
!     virtual status_t      dumpClient(int fd, const Vector<String16>& args);
  
      /**
       * CameraDeviceBase::NotificationListener implementation
--- 55,61 ----
      virtual ~Camera2ClientBase();
  
      virtual status_t      initialize(camera_module_t *module);
!     virtual status_t      dump(int fd, const Vector<String16>& args);
  
      /**
       * CameraDeviceBase::NotificationListener implementation
diff '--exclude=.git' -crB a/services/camera/libcameraservice/device3/Camera3Device.cpp b/services/camera/libcameraservice/device3/Camera3Device.cpp
*** a/services/camera/libcameraservice/device3/Camera3Device.cpp	2018-09-22 10:19:51.789278271 +0200
--- b/services/camera/libcameraservice/device3/Camera3Device.cpp	2018-09-22 10:11:05.460312636 +0200
***************
*** 41,47 ****
  #include <utils/Trace.h>
  #include <utils/Timers.h>
  
- #include "CameraService.h"
  #include "utils/CameraTraces.h"
  #include "device3/Camera3Device.h"
  #include "device3/Camera3OutputStream.h"
--- 41,46 ----
***************
*** 875,887 ****
          CameraMetadata *request) {
      ATRACE_CALL();
      ALOGV("%s: for template %d", __FUNCTION__, templateId);
- 
-     if (templateId <= 0 || templateId >= CAMERA3_TEMPLATE_COUNT) {
-         android_errorWriteWithInfoLog(CameraService::SN_EVENT_LOG_ID, "26866110",
-                 IPCThreadState::self()->getCallingUid(), NULL, 0);
-         return BAD_VALUE;
-     }
- 
      Mutex::Autolock il(mInterfaceLock);
      Mutex::Autolock l(mLock);
  
--- 874,879 ----
